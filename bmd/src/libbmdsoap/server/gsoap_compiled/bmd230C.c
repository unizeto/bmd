/* bmd230C.c
   Generated by gSOAP 2.7.17 from ../bmdsoap.h
   Copyright(C) 2000-2010, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "bmd230H.h"

#ifdef __cplusplus
extern "C" {
#endif

SOAP_SOURCE_STAMP("@(#) bmd230C.c ver 2.7.17 2013-03-07 13:31:57 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (!soap->header)
	{	if ((soap->header = (struct SOAP_ENV__Header*)soap_malloc(soap, sizeof(struct SOAP_ENV__Header))))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = (struct SOAP_ENV__Fault*)soap_malloc(soap, sizeof(struct SOAP_ENV__Fault));
		if (!soap->fault)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = (struct SOAP_ENV__Reason*)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason));
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if (soap->error || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_xsd__int:
		return soap_in_xsd__int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_long:
		return soap_in_long(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_unsignedByte:
		return soap_in_unsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedInt:
		return soap_in_unsignedInt(soap, NULL, NULL, "xsd:unsignedInt");
	case SOAP_TYPE_groupAuthorizationType_e:
		return soap_in_groupAuthorizationType_e(soap, NULL, NULL, "groupAuthorizationType-e");
	case SOAP_TYPE_chunkCntr_t:
		return soap_in_chunkCntr_t(soap, NULL, NULL, "chunkCntr-t");
	case SOAP_TYPE_trans_t:
		return soap_in_trans_t(soap, NULL, NULL, "trans-t");
	case SOAP_TYPE_visibilityType_t:
		return soap_in_visibilityType_t(soap, NULL, NULL, "visibilityType-t");
	case SOAP_TYPE_grantingType_e:
		return soap_in_grantingType_e(soap, NULL, NULL, "grantingType-e");
	case SOAP_TYPE_wsse__FaultcodeEnum:
		return soap_in_wsse__FaultcodeEnum(soap, NULL, NULL, "wsse:FaultcodeEnum");
	case SOAP_TYPE_wsu__tTimestampFault:
		return soap_in_wsu__tTimestampFault(soap, NULL, NULL, "wsu:tTimestampFault");
	case SOAP_TYPE_bmd230__bmdDeleteReplacedLobs:
		return soap_in_bmd230__bmdDeleteReplacedLobs(soap, NULL, NULL, "bmd230:bmdDeleteReplacedLobs");
	case SOAP_TYPE_bmd230__bmdDeleteReplacedLobsResponse:
		return soap_in_bmd230__bmdDeleteReplacedLobsResponse(soap, NULL, NULL, "bmd230:bmdDeleteReplacedLobsResponse");
	case SOAP_TYPE_bmd230__bmdConservateTimestamps:
		return soap_in_bmd230__bmdConservateTimestamps(soap, NULL, NULL, "bmd230:bmdConservateTimestamps");
	case SOAP_TYPE_bmd230__bmdConservateTimestampsResponse:
		return soap_in_bmd230__bmdConservateTimestampsResponse(soap, NULL, NULL, "bmd230:bmdConservateTimestampsResponse");
	case SOAP_TYPE_bmd230__bmdDeleteCascadeLinks:
		return soap_in_bmd230__bmdDeleteCascadeLinks(soap, NULL, NULL, "bmd230:bmdDeleteCascadeLinks");
	case SOAP_TYPE_bmd230__bmdDeleteCascadeLinksResponse:
		return soap_in_bmd230__bmdDeleteCascadeLinksResponse(soap, NULL, NULL, "bmd230:bmdDeleteCascadeLinksResponse");
	case SOAP_TYPE_bmd230__bmdCreateManyCascadeLinks:
		return soap_in_bmd230__bmdCreateManyCascadeLinks(soap, NULL, NULL, "bmd230:bmdCreateManyCascadeLinks");
	case SOAP_TYPE_bmd230__bmdCreateManyCascadeLinksResponse:
		return soap_in_bmd230__bmdCreateManyCascadeLinksResponse(soap, NULL, NULL, "bmd230:bmdCreateManyCascadeLinksResponse");
	case SOAP_TYPE_bmd230__bmdCreateCascadeLinks:
		return soap_in_bmd230__bmdCreateCascadeLinks(soap, NULL, NULL, "bmd230:bmdCreateCascadeLinks");
	case SOAP_TYPE_bmd230__bmdCreateCascadeLinksResponse:
		return soap_in_bmd230__bmdCreateCascadeLinksResponse(soap, NULL, NULL, "bmd230:bmdCreateCascadeLinksResponse");
	case SOAP_TYPE_bmd230__bmdCreateLinks:
		return soap_in_bmd230__bmdCreateLinks(soap, NULL, NULL, "bmd230:bmdCreateLinks");
	case SOAP_TYPE_bmd230__bmdCreateLinksResponse:
		return soap_in_bmd230__bmdCreateLinksResponse(soap, NULL, NULL, "bmd230:bmdCreateLinksResponse");
	case SOAP_TYPE_bmd230__bmdCreateLink:
		return soap_in_bmd230__bmdCreateLink(soap, NULL, NULL, "bmd230:bmdCreateLink");
	case SOAP_TYPE_bmd230__bmdCreateLinkResponse:
		return soap_in_bmd230__bmdCreateLinkResponse(soap, NULL, NULL, "bmd230:bmdCreateLinkResponse");
	case SOAP_TYPE_bmd230__bmdGetDirectoryDetails:
		return soap_in_bmd230__bmdGetDirectoryDetails(soap, NULL, NULL, "bmd230:bmdGetDirectoryDetails");
	case SOAP_TYPE_bmd230__bmdGetDirectoryDetailsResponse:
		return soap_in_bmd230__bmdGetDirectoryDetailsResponse(soap, NULL, NULL, "bmd230:bmdGetDirectoryDetailsResponse");
	case SOAP_TYPE_bmd230__bmdCreateDirectory:
		return soap_in_bmd230__bmdCreateDirectory(soap, NULL, NULL, "bmd230:bmdCreateDirectory");
	case SOAP_TYPE_bmd230__bmdCreateDirectoryResponse:
		return soap_in_bmd230__bmdCreateDirectoryResponse(soap, NULL, NULL, "bmd230:bmdCreateDirectoryResponse");
	case SOAP_TYPE_bmd230__bmdStopTransaction:
		return soap_in_bmd230__bmdStopTransaction(soap, NULL, NULL, "bmd230:bmdStopTransaction");
	case SOAP_TYPE_bmd230__bmdStopTransactionResponse:
		return soap_in_bmd230__bmdStopTransactionResponse(soap, NULL, NULL, "bmd230:bmdStopTransactionResponse");
	case SOAP_TYPE_bmd230__bmdStartTransaction:
		return soap_in_bmd230__bmdStartTransaction(soap, NULL, NULL, "bmd230:bmdStartTransaction");
	case SOAP_TYPE_bmd230__bmdStartTransactionResponse:
		return soap_in_bmd230__bmdStartTransactionResponse(soap, NULL, NULL, "bmd230:bmdStartTransactionResponse");
	case SOAP_TYPE_bmd230__bmdGetArchPackInChunk:
		return soap_in_bmd230__bmdGetArchPackInChunk(soap, NULL, NULL, "bmd230:bmdGetArchPackInChunk");
	case SOAP_TYPE_bmd230__bmdGetArchPackInChunkResponse:
		return soap_in_bmd230__bmdGetArchPackInChunkResponse(soap, NULL, NULL, "bmd230:bmdGetArchPackInChunkResponse");
	case SOAP_TYPE_bmd230__bmdGetFileChunkIter:
		return soap_in_bmd230__bmdGetFileChunkIter(soap, NULL, NULL, "bmd230:bmdGetFileChunkIter");
	case SOAP_TYPE_bmd230__bmdGetFileChunkIterResponse:
		return soap_in_bmd230__bmdGetFileChunkIterResponse(soap, NULL, NULL, "bmd230:bmdGetFileChunkIterResponse");
	case SOAP_TYPE_bmd230__bmdGetFileChunkStart:
		return soap_in_bmd230__bmdGetFileChunkStart(soap, NULL, NULL, "bmd230:bmdGetFileChunkStart");
	case SOAP_TYPE_bmd230__bmdGetFileChunkStartResponse:
		return soap_in_bmd230__bmdGetFileChunkStartResponse(soap, NULL, NULL, "bmd230:bmdGetFileChunkStartResponse");
	case SOAP_TYPE_bmd230__bmdInsertFileChunkIter:
		return soap_in_bmd230__bmdInsertFileChunkIter(soap, NULL, NULL, "bmd230:bmdInsertFileChunkIter");
	case SOAP_TYPE_bmd230__bmdInsertFileChunkIterResponse:
		return soap_in_bmd230__bmdInsertFileChunkIterResponse(soap, NULL, NULL, "bmd230:bmdInsertFileChunkIterResponse");
	case SOAP_TYPE_bmd230__bmdInsertFileChunkStart:
		return soap_in_bmd230__bmdInsertFileChunkStart(soap, NULL, NULL, "bmd230:bmdInsertFileChunkStart");
	case SOAP_TYPE_bmd230__bmdInsertFileChunkStartResponse:
		return soap_in_bmd230__bmdInsertFileChunkStartResponse(soap, NULL, NULL, "bmd230:bmdInsertFileChunkStartResponse");
	case SOAP_TYPE_bmd230__getFile:
		return soap_in_bmd230__getFile(soap, NULL, NULL, "bmd230:getFile");
	case SOAP_TYPE_bmd230__getFileResponse:
		return soap_in_bmd230__getFileResponse(soap, NULL, NULL, "bmd230:getFileResponse");
	case SOAP_TYPE_bmd230__countInvoice:
		return soap_in_bmd230__countInvoice(soap, NULL, NULL, "bmd230:countInvoice");
	case SOAP_TYPE_bmd230__countInvoiceResponse:
		return soap_in_bmd230__countInvoiceResponse(soap, NULL, NULL, "bmd230:countInvoiceResponse");
	case SOAP_TYPE_bmd230__verifyInvoiceWithDetails:
		return soap_in_bmd230__verifyInvoiceWithDetails(soap, NULL, NULL, "bmd230:verifyInvoiceWithDetails");
	case SOAP_TYPE_bmd230__verifyInvoiceWithDetailsResponse:
		return soap_in_bmd230__verifyInvoiceWithDetailsResponse(soap, NULL, NULL, "bmd230:verifyInvoiceWithDetailsResponse");
	case SOAP_TYPE_bmd230__verifyInvoiceSimplified:
		return soap_in_bmd230__verifyInvoiceSimplified(soap, NULL, NULL, "bmd230:verifyInvoiceSimplified");
	case SOAP_TYPE_bmd230__verifyInvoiceSimplifiedResponse:
		return soap_in_bmd230__verifyInvoiceSimplifiedResponse(soap, NULL, NULL, "bmd230:verifyInvoiceSimplifiedResponse");
	case SOAP_TYPE_bmd230__verifyInvoice:
		return soap_in_bmd230__verifyInvoice(soap, NULL, NULL, "bmd230:verifyInvoice");
	case SOAP_TYPE_bmd230__verifyInvoiceResponse:
		return soap_in_bmd230__verifyInvoiceResponse(soap, NULL, NULL, "bmd230:verifyInvoiceResponse");
	case SOAP_TYPE_bmd230__getHTMLImage:
		return soap_in_bmd230__getHTMLImage(soap, NULL, NULL, "bmd230:getHTMLImage");
	case SOAP_TYPE_bmd230__getHTMLImageResponse:
		return soap_in_bmd230__getHTMLImageResponse(soap, NULL, NULL, "bmd230:getHTMLImageResponse");
	case SOAP_TYPE_bmd230__getInvoicePack:
		return soap_in_bmd230__getInvoicePack(soap, NULL, NULL, "bmd230:getInvoicePack");
	case SOAP_TYPE_bmd230__getInvoicePackResponse:
		return soap_in_bmd230__getInvoicePackResponse(soap, NULL, NULL, "bmd230:getInvoicePackResponse");
	case SOAP_TYPE_bmd230__SendAdviceWithParameters:
		return soap_in_bmd230__SendAdviceWithParameters(soap, NULL, NULL, "bmd230:SendAdviceWithParameters");
	case SOAP_TYPE_bmd230__SendAdviceWithParametersResponse:
		return soap_in_bmd230__SendAdviceWithParametersResponse(soap, NULL, NULL, "bmd230:SendAdviceWithParametersResponse");
	case SOAP_TYPE_bmd230__SendAdvice:
		return soap_in_bmd230__SendAdvice(soap, NULL, NULL, "bmd230:SendAdvice");
	case SOAP_TYPE_bmd230__SendAdviceResponse:
		return soap_in_bmd230__SendAdviceResponse(soap, NULL, NULL, "bmd230:SendAdviceResponse");
	case SOAP_TYPE_bmd230__verifyInvoiceWithDetailsById:
		return soap_in_bmd230__verifyInvoiceWithDetailsById(soap, NULL, NULL, "bmd230:verifyInvoiceWithDetailsById");
	case SOAP_TYPE_bmd230__verifyInvoiceWithDetailsByIdResponse:
		return soap_in_bmd230__verifyInvoiceWithDetailsByIdResponse(soap, NULL, NULL, "bmd230:verifyInvoiceWithDetailsByIdResponse");
	case SOAP_TYPE_bmd230__verifyInvoiceById:
		return soap_in_bmd230__verifyInvoiceById(soap, NULL, NULL, "bmd230:verifyInvoiceById");
	case SOAP_TYPE_bmd230__verifyInvoiceByIdResponse:
		return soap_in_bmd230__verifyInvoiceByIdResponse(soap, NULL, NULL, "bmd230:verifyInvoiceByIdResponse");
	case SOAP_TYPE_bmd230__getHTMLImageById:
		return soap_in_bmd230__getHTMLImageById(soap, NULL, NULL, "bmd230:getHTMLImageById");
	case SOAP_TYPE_bmd230__getHTMLImageByIdResponse:
		return soap_in_bmd230__getHTMLImageByIdResponse(soap, NULL, NULL, "bmd230:getHTMLImageByIdResponse");
	case SOAP_TYPE_bmd230__getInvoicePackById:
		return soap_in_bmd230__getInvoicePackById(soap, NULL, NULL, "bmd230:getInvoicePackById");
	case SOAP_TYPE_bmd230__getInvoicePackByIdResponse:
		return soap_in_bmd230__getInvoicePackByIdResponse(soap, NULL, NULL, "bmd230:getInvoicePackByIdResponse");
	case SOAP_TYPE_bmd230__bmdGetActionsHistoryById:
		return soap_in_bmd230__bmdGetActionsHistoryById(soap, NULL, NULL, "bmd230:bmdGetActionsHistoryById");
	case SOAP_TYPE_bmd230__bmdGetActionsHistoryByIdResponse:
		return soap_in_bmd230__bmdGetActionsHistoryByIdResponse(soap, NULL, NULL, "bmd230:bmdGetActionsHistoryByIdResponse");
	case SOAP_TYPE_bmd230__bmdGetVersionsHistory:
		return soap_in_bmd230__bmdGetVersionsHistory(soap, NULL, NULL, "bmd230:bmdGetVersionsHistory");
	case SOAP_TYPE_bmd230__bmdGetVersionsHistoryResponse:
		return soap_in_bmd230__bmdGetVersionsHistoryResponse(soap, NULL, NULL, "bmd230:bmdGetVersionsHistoryResponse");
	case SOAP_TYPE_bmd230__bmdGetAccessObjects:
		return soap_in_bmd230__bmdGetAccessObjects(soap, NULL, NULL, "bmd230:bmdGetAccessObjects");
	case SOAP_TYPE_bmd230__bmdGetAccessObjectsResponse:
		return soap_in_bmd230__bmdGetAccessObjectsResponse(soap, NULL, NULL, "bmd230:bmdGetAccessObjectsResponse");
	case SOAP_TYPE_bmd230__bmdGetArchPack:
		return soap_in_bmd230__bmdGetArchPack(soap, NULL, NULL, "bmd230:bmdGetArchPack");
	case SOAP_TYPE_bmd230__bmdGetArchPackResponse:
		return soap_in_bmd230__bmdGetArchPackResponse(soap, NULL, NULL, "bmd230:bmdGetArchPackResponse");
	case SOAP_TYPE_bmd230__bmdGetTimeStamp:
		return soap_in_bmd230__bmdGetTimeStamp(soap, NULL, NULL, "bmd230:bmdGetTimeStamp");
	case SOAP_TYPE_bmd230__bmdGetTimeStampResponse:
		return soap_in_bmd230__bmdGetTimeStampResponse(soap, NULL, NULL, "bmd230:bmdGetTimeStampResponse");
	case SOAP_TYPE_bmd230__bmdGetFilePKIById:
		return soap_in_bmd230__bmdGetFilePKIById(soap, NULL, NULL, "bmd230:bmdGetFilePKIById");
	case SOAP_TYPE_bmd230__bmdGetFilePKIByIdResponse:
		return soap_in_bmd230__bmdGetFilePKIByIdResponse(soap, NULL, NULL, "bmd230:bmdGetFilePKIByIdResponse");
	case SOAP_TYPE_bmd230__bmdGetFilePropByID:
		return soap_in_bmd230__bmdGetFilePropByID(soap, NULL, NULL, "bmd230:bmdGetFilePropByID");
	case SOAP_TYPE_bmd230__bmdGetFilePropByIDResponse:
		return soap_in_bmd230__bmdGetFilePropByIDResponse(soap, NULL, NULL, "bmd230:bmdGetFilePropByIDResponse");
	case SOAP_TYPE_bmd230__bmdGetFileByIdInZipPack:
		return soap_in_bmd230__bmdGetFileByIdInZipPack(soap, NULL, NULL, "bmd230:bmdGetFileByIdInZipPack");
	case SOAP_TYPE_bmd230__bmdGetFileByIdInZipPackResponse:
		return soap_in_bmd230__bmdGetFileByIdInZipPackResponse(soap, NULL, NULL, "bmd230:bmdGetFileByIdInZipPackResponse");
	case SOAP_TYPE_bmd230__bmdGetFileByHash:
		return soap_in_bmd230__bmdGetFileByHash(soap, NULL, NULL, "bmd230:bmdGetFileByHash");
	case SOAP_TYPE_bmd230__bmdGetFileByHashResponse:
		return soap_in_bmd230__bmdGetFileByHashResponse(soap, NULL, NULL, "bmd230:bmdGetFileByHashResponse");
	case SOAP_TYPE_bmd230__bmdGetArchiveFileVersion:
		return soap_in_bmd230__bmdGetArchiveFileVersion(soap, NULL, NULL, "bmd230:bmdGetArchiveFileVersion");
	case SOAP_TYPE_bmd230__bmdGetArchiveFileVersionResponse:
		return soap_in_bmd230__bmdGetArchiveFileVersionResponse(soap, NULL, NULL, "bmd230:bmdGetArchiveFileVersionResponse");
	case SOAP_TYPE_bmd230__bmdGetFileById:
		return soap_in_bmd230__bmdGetFileById(soap, NULL, NULL, "bmd230:bmdGetFileById");
	case SOAP_TYPE_bmd230__bmdGetFileByIdResponse:
		return soap_in_bmd230__bmdGetFileByIdResponse(soap, NULL, NULL, "bmd230:bmdGetFileByIdResponse");
	case SOAP_TYPE_bmd230__bmdGetSecurityList:
		return soap_in_bmd230__bmdGetSecurityList(soap, NULL, NULL, "bmd230:bmdGetSecurityList");
	case SOAP_TYPE_bmd230__bmdGetSecurityListResponse:
		return soap_in_bmd230__bmdGetSecurityListResponse(soap, NULL, NULL, "bmd230:bmdGetSecurityListResponse");
	case SOAP_TYPE_bmd230__bmdRegisterNewSecurityCategory:
		return soap_in_bmd230__bmdRegisterNewSecurityCategory(soap, NULL, NULL, "bmd230:bmdRegisterNewSecurityCategory");
	case SOAP_TYPE_bmd230__bmdRegisterNewSecurityCategoryResponse:
		return soap_in_bmd230__bmdRegisterNewSecurityCategoryResponse(soap, NULL, NULL, "bmd230:bmdRegisterNewSecurityCategoryResponse");
	case SOAP_TYPE_bmd230__bmdDeleteClass:
		return soap_in_bmd230__bmdDeleteClass(soap, NULL, NULL, "bmd230:bmdDeleteClass");
	case SOAP_TYPE_bmd230__bmdDeleteClassResponse:
		return soap_in_bmd230__bmdDeleteClassResponse(soap, NULL, NULL, "bmd230:bmdDeleteClassResponse");
	case SOAP_TYPE_bmd230__bmdGetClassList:
		return soap_in_bmd230__bmdGetClassList(soap, NULL, NULL, "bmd230:bmdGetClassList");
	case SOAP_TYPE_bmd230__bmdGetClassListResponse:
		return soap_in_bmd230__bmdGetClassListResponse(soap, NULL, NULL, "bmd230:bmdGetClassListResponse");
	case SOAP_TYPE_bmd230__bmdUpdateClass:
		return soap_in_bmd230__bmdUpdateClass(soap, NULL, NULL, "bmd230:bmdUpdateClass");
	case SOAP_TYPE_bmd230__bmdUpdateClassResponse:
		return soap_in_bmd230__bmdUpdateClassResponse(soap, NULL, NULL, "bmd230:bmdUpdateClassResponse");
	case SOAP_TYPE_bmd230__bmdRegisterNewClass:
		return soap_in_bmd230__bmdRegisterNewClass(soap, NULL, NULL, "bmd230:bmdRegisterNewClass");
	case SOAP_TYPE_bmd230__bmdRegisterNewClassResponse:
		return soap_in_bmd230__bmdRegisterNewClassResponse(soap, NULL, NULL, "bmd230:bmdRegisterNewClassResponse");
	case SOAP_TYPE_bmd230__bmdDeleteGroup:
		return soap_in_bmd230__bmdDeleteGroup(soap, NULL, NULL, "bmd230:bmdDeleteGroup");
	case SOAP_TYPE_bmd230__bmdDeleteGroupResponse:
		return soap_in_bmd230__bmdDeleteGroupResponse(soap, NULL, NULL, "bmd230:bmdDeleteGroupResponse");
	case SOAP_TYPE_bmd230__bmdGetGroupsList:
		return soap_in_bmd230__bmdGetGroupsList(soap, NULL, NULL, "bmd230:bmdGetGroupsList");
	case SOAP_TYPE_bmd230__bmdGetGroupsListResponse:
		return soap_in_bmd230__bmdGetGroupsListResponse(soap, NULL, NULL, "bmd230:bmdGetGroupsListResponse");
	case SOAP_TYPE_bmd230__bmdUpdateGroup:
		return soap_in_bmd230__bmdUpdateGroup(soap, NULL, NULL, "bmd230:bmdUpdateGroup");
	case SOAP_TYPE_bmd230__bmdUpdateGroupResponse:
		return soap_in_bmd230__bmdUpdateGroupResponse(soap, NULL, NULL, "bmd230:bmdUpdateGroupResponse");
	case SOAP_TYPE_bmd230__bmdRegisterNewGroup:
		return soap_in_bmd230__bmdRegisterNewGroup(soap, NULL, NULL, "bmd230:bmdRegisterNewGroup");
	case SOAP_TYPE_bmd230__bmdRegisterNewGroupResponse:
		return soap_in_bmd230__bmdRegisterNewGroupResponse(soap, NULL, NULL, "bmd230:bmdRegisterNewGroupResponse");
	case SOAP_TYPE_bmd230__bmdDeleteRole:
		return soap_in_bmd230__bmdDeleteRole(soap, NULL, NULL, "bmd230:bmdDeleteRole");
	case SOAP_TYPE_bmd230__bmdDeleteRoleResponse:
		return soap_in_bmd230__bmdDeleteRoleResponse(soap, NULL, NULL, "bmd230:bmdDeleteRoleResponse");
	case SOAP_TYPE_bmd230__bmdGetRolesList:
		return soap_in_bmd230__bmdGetRolesList(soap, NULL, NULL, "bmd230:bmdGetRolesList");
	case SOAP_TYPE_bmd230__bmdGetRolesListResponse:
		return soap_in_bmd230__bmdGetRolesListResponse(soap, NULL, NULL, "bmd230:bmdGetRolesListResponse");
	case SOAP_TYPE_bmd230__bmdUpdateRole:
		return soap_in_bmd230__bmdUpdateRole(soap, NULL, NULL, "bmd230:bmdUpdateRole");
	case SOAP_TYPE_bmd230__bmdUpdateRoleResponse:
		return soap_in_bmd230__bmdUpdateRoleResponse(soap, NULL, NULL, "bmd230:bmdUpdateRoleResponse");
	case SOAP_TYPE_bmd230__bmdRegisterNewRole:
		return soap_in_bmd230__bmdRegisterNewRole(soap, NULL, NULL, "bmd230:bmdRegisterNewRole");
	case SOAP_TYPE_bmd230__bmdRegisterNewRoleResponse:
		return soap_in_bmd230__bmdRegisterNewRoleResponse(soap, NULL, NULL, "bmd230:bmdRegisterNewRoleResponse");
	case SOAP_TYPE_bmd230__bmdDisableIdentity:
		return soap_in_bmd230__bmdDisableIdentity(soap, NULL, NULL, "bmd230:bmdDisableIdentity");
	case SOAP_TYPE_bmd230__bmdDisableIdentityResponse:
		return soap_in_bmd230__bmdDisableIdentityResponse(soap, NULL, NULL, "bmd230:bmdDisableIdentityResponse");
	case SOAP_TYPE_bmd230__bmdDisableUser:
		return soap_in_bmd230__bmdDisableUser(soap, NULL, NULL, "bmd230:bmdDisableUser");
	case SOAP_TYPE_bmd230__bmdDisableUserResponse:
		return soap_in_bmd230__bmdDisableUserResponse(soap, NULL, NULL, "bmd230:bmdDisableUserResponse");
	case SOAP_TYPE_bmd230__bmdDeleteUser:
		return soap_in_bmd230__bmdDeleteUser(soap, NULL, NULL, "bmd230:bmdDeleteUser");
	case SOAP_TYPE_bmd230__bmdDeleteUserResponse:
		return soap_in_bmd230__bmdDeleteUserResponse(soap, NULL, NULL, "bmd230:bmdDeleteUserResponse");
	case SOAP_TYPE_bmd230__bmdGetUsersList:
		return soap_in_bmd230__bmdGetUsersList(soap, NULL, NULL, "bmd230:bmdGetUsersList");
	case SOAP_TYPE_bmd230__bmdGetUsersListResponse:
		return soap_in_bmd230__bmdGetUsersListResponse(soap, NULL, NULL, "bmd230:bmdGetUsersListResponse");
	case SOAP_TYPE_bmd230__bmdUpdateUserRights:
		return soap_in_bmd230__bmdUpdateUserRights(soap, NULL, NULL, "bmd230:bmdUpdateUserRights");
	case SOAP_TYPE_bmd230__bmdUpdateUserRightsResponse:
		return soap_in_bmd230__bmdUpdateUserRightsResponse(soap, NULL, NULL, "bmd230:bmdUpdateUserRightsResponse");
	case SOAP_TYPE_bmd230__bmdAddCertificateToIdentity:
		return soap_in_bmd230__bmdAddCertificateToIdentity(soap, NULL, NULL, "bmd230:bmdAddCertificateToIdentity");
	case SOAP_TYPE_bmd230__bmdAddCertificateToIdentityResponse:
		return soap_in_bmd230__bmdAddCertificateToIdentityResponse(soap, NULL, NULL, "bmd230:bmdAddCertificateToIdentityResponse");
	case SOAP_TYPE_bmd230__bmdRegisterNewUser:
		return soap_in_bmd230__bmdRegisterNewUser(soap, NULL, NULL, "bmd230:bmdRegisterNewUser");
	case SOAP_TYPE_bmd230__bmdRegisterNewUserResponse:
		return soap_in_bmd230__bmdRegisterNewUserResponse(soap, NULL, NULL, "bmd230:bmdRegisterNewUserResponse");
	case SOAP_TYPE_bmd230__bmdSearchUnreceived:
		return soap_in_bmd230__bmdSearchUnreceived(soap, NULL, NULL, "bmd230:bmdSearchUnreceived");
	case SOAP_TYPE_bmd230__bmdSearchUnreceivedResponse:
		return soap_in_bmd230__bmdSearchUnreceivedResponse(soap, NULL, NULL, "bmd230:bmdSearchUnreceivedResponse");
	case SOAP_TYPE_bmd230__bmdHistory:
		return soap_in_bmd230__bmdHistory(soap, NULL, NULL, "bmd230:bmdHistory");
	case SOAP_TYPE_bmd230__bmdHistoryResponse:
		return soap_in_bmd230__bmdHistoryResponse(soap, NULL, NULL, "bmd230:bmdHistoryResponse");
	case SOAP_TYPE_bmd230__bmdAdvancedCountFiles:
		return soap_in_bmd230__bmdAdvancedCountFiles(soap, NULL, NULL, "bmd230:bmdAdvancedCountFiles");
	case SOAP_TYPE_bmd230__bmdAdvancedCountFilesResponse:
		return soap_in_bmd230__bmdAdvancedCountFilesResponse(soap, NULL, NULL, "bmd230:bmdAdvancedCountFilesResponse");
	case SOAP_TYPE_bmd230__bmdAdvancedSearchFiles:
		return soap_in_bmd230__bmdAdvancedSearchFiles(soap, NULL, NULL, "bmd230:bmdAdvancedSearchFiles");
	case SOAP_TYPE_bmd230__bmdAdvancedSearchFilesResponse:
		return soap_in_bmd230__bmdAdvancedSearchFilesResponse(soap, NULL, NULL, "bmd230:bmdAdvancedSearchFilesResponse");
	case SOAP_TYPE_bmd230__bmdSearchFilesCSV:
		return soap_in_bmd230__bmdSearchFilesCSV(soap, NULL, NULL, "bmd230:bmdSearchFilesCSV");
	case SOAP_TYPE_bmd230__bmdSearchFilesCSVResponse:
		return soap_in_bmd230__bmdSearchFilesCSVResponse(soap, NULL, NULL, "bmd230:bmdSearchFilesCSVResponse");
	case SOAP_TYPE_bmd230__bmdSearchFiles:
		return soap_in_bmd230__bmdSearchFiles(soap, NULL, NULL, "bmd230:bmdSearchFiles");
	case SOAP_TYPE_bmd230__bmdSearchFilesResponse:
		return soap_in_bmd230__bmdSearchFilesResponse(soap, NULL, NULL, "bmd230:bmdSearchFilesResponse");
	case SOAP_TYPE_bmd230__bmdLogin:
		return soap_in_bmd230__bmdLogin(soap, NULL, NULL, "bmd230:bmdLogin");
	case SOAP_TYPE_bmd230__bmdLoginResponse:
		return soap_in_bmd230__bmdLoginResponse(soap, NULL, NULL, "bmd230:bmdLoginResponse");
	case SOAP_TYPE_bmd230__bmdAddSignature:
		return soap_in_bmd230__bmdAddSignature(soap, NULL, NULL, "bmd230:bmdAddSignature");
	case SOAP_TYPE_bmd230__bmdAddSignatureResponse:
		return soap_in_bmd230__bmdAddSignatureResponse(soap, NULL, NULL, "bmd230:bmdAddSignatureResponse");
	case SOAP_TYPE_bmd230__bmdUpdateDefaultMetadataValue:
		return soap_in_bmd230__bmdUpdateDefaultMetadataValue(soap, NULL, NULL, "bmd230:bmdUpdateDefaultMetadataValue");
	case SOAP_TYPE_bmd230__bmdUpdateDefaultMetadataValueResponse:
		return soap_in_bmd230__bmdUpdateDefaultMetadataValueResponse(soap, NULL, NULL, "bmd230:bmdUpdateDefaultMetadataValueResponse");
	case SOAP_TYPE_bmd230__bmdUpdateSystemMetadata:
		return soap_in_bmd230__bmdUpdateSystemMetadata(soap, NULL, NULL, "bmd230:bmdUpdateSystemMetadata");
	case SOAP_TYPE_bmd230__bmdUpdateSystemMetadataResponse:
		return soap_in_bmd230__bmdUpdateSystemMetadataResponse(soap, NULL, NULL, "bmd230:bmdUpdateSystemMetadataResponse");
	case SOAP_TYPE_bmd230__bmdUpdateMetadata:
		return soap_in_bmd230__bmdUpdateMetadata(soap, NULL, NULL, "bmd230:bmdUpdateMetadata");
	case SOAP_TYPE_bmd230__bmdUpdateMetadataResponse:
		return soap_in_bmd230__bmdUpdateMetadataResponse(soap, NULL, NULL, "bmd230:bmdUpdateMetadataResponse");
	case SOAP_TYPE_bmd230__bmdDeleteDirByID:
		return soap_in_bmd230__bmdDeleteDirByID(soap, NULL, NULL, "bmd230:bmdDeleteDirByID");
	case SOAP_TYPE_bmd230__bmdDeleteDirByIDResponse:
		return soap_in_bmd230__bmdDeleteDirByIDResponse(soap, NULL, NULL, "bmd230:bmdDeleteDirByIDResponse");
	case SOAP_TYPE_bmd230__bmdDeleteFileByID:
		return soap_in_bmd230__bmdDeleteFileByID(soap, NULL, NULL, "bmd230:bmdDeleteFileByID");
	case SOAP_TYPE_bmd230__bmdDeleteFileByIDResponse:
		return soap_in_bmd230__bmdDeleteFileByIDResponse(soap, NULL, NULL, "bmd230:bmdDeleteFileByIDResponse");
	case SOAP_TYPE_bmd230__bmdUpdateFileVersion:
		return soap_in_bmd230__bmdUpdateFileVersion(soap, NULL, NULL, "bmd230:bmdUpdateFileVersion");
	case SOAP_TYPE_bmd230__bmdUpdateFileVersionResponse:
		return soap_in_bmd230__bmdUpdateFileVersionResponse(soap, NULL, NULL, "bmd230:bmdUpdateFileVersionResponse");
	case SOAP_TYPE_bmd230__bmdInsertFileList:
		return soap_in_bmd230__bmdInsertFileList(soap, NULL, NULL, "bmd230:bmdInsertFileList");
	case SOAP_TYPE_bmd230__bmdInsertFileListResponse:
		return soap_in_bmd230__bmdInsertFileListResponse(soap, NULL, NULL, "bmd230:bmdInsertFileListResponse");
	case SOAP_TYPE_bmd230__bmdInsertSignedFile:
		return soap_in_bmd230__bmdInsertSignedFile(soap, NULL, NULL, "bmd230:bmdInsertSignedFile");
	case SOAP_TYPE_bmd230__bmdInsertSignedFileResponse:
		return soap_in_bmd230__bmdInsertSignedFileResponse(soap, NULL, NULL, "bmd230:bmdInsertSignedFileResponse");
	case SOAP_TYPE_bmd230__bmdInsertFile:
		return soap_in_bmd230__bmdInsertFile(soap, NULL, NULL, "bmd230:bmdInsertFile");
	case SOAP_TYPE_bmd230__bmdInsertFileResponse:
		return soap_in_bmd230__bmdInsertFileResponse(soap, NULL, NULL, "bmd230:bmdInsertFileResponse");
	case SOAP_TYPE_bmd230__testConnection:
		return soap_in_bmd230__testConnection(soap, NULL, NULL, "bmd230:testConnection");
	case SOAP_TYPE_bmd230__testConnectionResponse:
		return soap_in_bmd230__testConnectionResponse(soap, NULL, NULL, "bmd230:testConnectionResponse");
	case SOAP_TYPE_bmd230__ActionsHistoryList:
		return soap_in_bmd230__ActionsHistoryList(soap, NULL, NULL, "bmd230:ActionsHistoryList");
	case SOAP_TYPE_bmd230__ActionsHistoryElement:
		return soap_in_bmd230__ActionsHistoryElement(soap, NULL, NULL, "bmd230:ActionsHistoryElement");
	case SOAP_TYPE_bmd230__GetVersionsHistoryResultList:
		return soap_in_bmd230__GetVersionsHistoryResultList(soap, NULL, NULL, "bmd230:GetVersionsHistoryResultList");
	case SOAP_TYPE_bmd230__GetVersionsHistoryResult:
		return soap_in_bmd230__GetVersionsHistoryResult(soap, NULL, NULL, "bmd230:GetVersionsHistoryResult");
	case SOAP_TYPE_bmd230__FileVersionInfoList:
		return soap_in_bmd230__FileVersionInfoList(soap, NULL, NULL, "bmd230:FileVersionInfoList");
	case SOAP_TYPE_bmd230__FileVersionInfo:
		return soap_in_bmd230__FileVersionInfo(soap, NULL, NULL, "bmd230:FileVersionInfo");
	case SOAP_TYPE_bmd230__accessObjectList:
		return soap_in_bmd230__accessObjectList(soap, NULL, NULL, "bmd230:accessObjectList");
	case SOAP_TYPE_bmd230__accessObject:
		return soap_in_bmd230__accessObject(soap, NULL, NULL, "bmd230:accessObject");
	case SOAP_TYPE_bmd230__archPackOut:
		return soap_in_bmd230__archPackOut(soap, NULL, NULL, "bmd230:archPackOut");
	case SOAP_TYPE_bmd230__deleteCascadeLinksList:
		return soap_in_bmd230__deleteCascadeLinksList(soap, NULL, NULL, "bmd230:deleteCascadeLinksList");
	case SOAP_TYPE_bmd230__deleteCascadeLinksElement:
		return soap_in_bmd230__deleteCascadeLinksElement(soap, NULL, NULL, "bmd230:deleteCascadeLinksElement");
	case SOAP_TYPE_bmd230__manyCascadeLinksResult:
		return soap_in_bmd230__manyCascadeLinksResult(soap, NULL, NULL, "bmd230:manyCascadeLinksResult");
	case SOAP_TYPE_bmd230__manyCascadeLinksElement:
		return soap_in_bmd230__manyCascadeLinksElement(soap, NULL, NULL, "bmd230:manyCascadeLinksElement");
	case SOAP_TYPE_bmd230__cascadeLinksInfo:
		return soap_in_bmd230__cascadeLinksInfo(soap, NULL, NULL, "bmd230:cascadeLinksInfo");
	case SOAP_TYPE_bmd230__singleCascadeLinkInfo:
		return soap_in_bmd230__singleCascadeLinkInfo(soap, NULL, NULL, "bmd230:singleCascadeLinkInfo");
	case SOAP_TYPE_bmd230__linksInfo:
		return soap_in_bmd230__linksInfo(soap, NULL, NULL, "bmd230:linksInfo");
	case SOAP_TYPE_bmd230__DateTime:
		return soap_in_bmd230__DateTime(soap, NULL, NULL, "bmd230:DateTime");
	case SOAP_TYPE_bmd230__singleLinkInfo:
		return soap_in_bmd230__singleLinkInfo(soap, NULL, NULL, "bmd230:singleLinkInfo");
	case SOAP_TYPE_bmd230__securityInfo:
		return soap_in_bmd230__securityInfo(soap, NULL, NULL, "bmd230:securityInfo");
	case SOAP_TYPE_bmd230__secLevelInfo:
		return soap_in_bmd230__secLevelInfo(soap, NULL, NULL, "bmd230:secLevelInfo");
	case SOAP_TYPE_bmd230__singleSecLevelInfo:
		return soap_in_bmd230__singleSecLevelInfo(soap, NULL, NULL, "bmd230:singleSecLevelInfo");
	case SOAP_TYPE_bmd230__secCategoryInfo:
		return soap_in_bmd230__secCategoryInfo(soap, NULL, NULL, "bmd230:secCategoryInfo");
	case SOAP_TYPE_bmd230__singleSecCategoryInfo:
		return soap_in_bmd230__singleSecCategoryInfo(soap, NULL, NULL, "bmd230:singleSecCategoryInfo");
	case SOAP_TYPE_bmd230__classInfo:
		return soap_in_bmd230__classInfo(soap, NULL, NULL, "bmd230:classInfo");
	case SOAP_TYPE_bmd230__singleClassInfo:
		return soap_in_bmd230__singleClassInfo(soap, NULL, NULL, "bmd230:singleClassInfo");
	case SOAP_TYPE_bmd230__groupInfo:
		return soap_in_bmd230__groupInfo(soap, NULL, NULL, "bmd230:groupInfo");
	case SOAP_TYPE_bmd230__singleGroupInfo:
		return soap_in_bmd230__singleGroupInfo(soap, NULL, NULL, "bmd230:singleGroupInfo");
	case SOAP_TYPE_bmd230__userRoleInfo:
		return soap_in_bmd230__userRoleInfo(soap, NULL, NULL, "bmd230:userRoleInfo");
	case SOAP_TYPE_bmd230__singleRoleInfo:
		return soap_in_bmd230__singleRoleInfo(soap, NULL, NULL, "bmd230:singleRoleInfo");
	case SOAP_TYPE_bmd230__loginResponse:
		return soap_in_bmd230__loginResponse(soap, NULL, NULL, "bmd230:loginResponse");
	case SOAP_TYPE_bmd230__userRegistrationResult:
		return soap_in_bmd230__userRegistrationResult(soap, NULL, NULL, "bmd230:userRegistrationResult");
	case SOAP_TYPE_bmd230__userListInfo:
		return soap_in_bmd230__userListInfo(soap, NULL, NULL, "bmd230:userListInfo");
	case SOAP_TYPE_bmd230__singleUserInfo:
		return soap_in_bmd230__singleUserInfo(soap, NULL, NULL, "bmd230:singleUserInfo");
	case SOAP_TYPE_bmd230__userNewGroupInfo:
		return soap_in_bmd230__userNewGroupInfo(soap, NULL, NULL, "bmd230:userNewGroupInfo");
	case SOAP_TYPE_bmd230__stringList:
		return soap_in_bmd230__stringList(soap, NULL, NULL, "bmd230:stringList");
	case SOAP_TYPE_bmd230__mtdsSearchValues:
		return soap_in_bmd230__mtdsSearchValues(soap, NULL, NULL, "bmd230:mtdsSearchValues");
	case SOAP_TYPE_bmd230__mtdSearchSingleValue:
		return soap_in_bmd230__mtdSearchSingleValue(soap, NULL, NULL, "bmd230:mtdSearchSingleValue");
	case SOAP_TYPE_bmd230__bmdTimestamp:
		return soap_in_bmd230__bmdTimestamp(soap, NULL, NULL, "bmd230:bmdTimestamp");
	case SOAP_TYPE_bmd230__historyResults:
		return soap_in_bmd230__historyResults(soap, NULL, NULL, "bmd230:historyResults");
	case SOAP_TYPE_bmd230__historySingleResult:
		return soap_in_bmd230__historySingleResult(soap, NULL, NULL, "bmd230:historySingleResult");
	case SOAP_TYPE_bmd230__searchResults:
		return soap_in_bmd230__searchResults(soap, NULL, NULL, "bmd230:searchResults");
	case SOAP_TYPE_bmd230__searchSingleResult:
		return soap_in_bmd230__searchSingleResult(soap, NULL, NULL, "bmd230:searchSingleResult");
	case SOAP_TYPE_bmd230__mtdsInfo:
		return soap_in_bmd230__mtdsInfo(soap, NULL, NULL, "bmd230:mtdsInfo");
	case SOAP_TYPE_bmd230__mtdSingleInfo:
		return soap_in_bmd230__mtdSingleInfo(soap, NULL, NULL, "bmd230:mtdSingleInfo");
	case SOAP_TYPE_bmd230__searchSortInfoList:
		return soap_in_bmd230__searchSortInfoList(soap, NULL, NULL, "bmd230:searchSortInfoList");
	case SOAP_TYPE_bmd230__searchSortInfo:
		return soap_in_bmd230__searchSortInfo(soap, NULL, NULL, "bmd230:searchSortInfo");
	case SOAP_TYPE_bmd230__idList:
		return soap_in_bmd230__idList(soap, NULL, NULL, "bmd230:idList");
	case SOAP_TYPE_bmd230__fileComplexList:
		return soap_in_bmd230__fileComplexList(soap, NULL, NULL, "bmd230:fileComplexList");
	case SOAP_TYPE_bmd230__fileComplex:
		return soap_in_bmd230__fileComplex(soap, NULL, NULL, "bmd230:fileComplex");
	case SOAP_TYPE_bmd230__mtdsValues:
		return soap_in_bmd230__mtdsValues(soap, NULL, NULL, "bmd230:mtdsValues");
	case SOAP_TYPE_bmd230__mtdSingleValue:
		return soap_in_bmd230__mtdSingleValue(soap, NULL, NULL, "bmd230:mtdSingleValue");
	case SOAP_TYPE_bmd230__fileInfoList:
		return soap_in_bmd230__fileInfoList(soap, NULL, NULL, "bmd230:fileInfoList");
	case SOAP_TYPE_bmd230__fileInfo:
		return soap_in_bmd230__fileInfo(soap, NULL, NULL, "bmd230:fileInfo");
	case SOAP_TYPE_bmd230__PkiFileInfo:
		return soap_in_bmd230__PkiFileInfo(soap, NULL, NULL, "bmd230:PkiFileInfo");
	case SOAP_TYPE_bmd230__SignatureList:
		return soap_in_bmd230__SignatureList(soap, NULL, NULL, "bmd230:SignatureList");
	case SOAP_TYPE_bmd230__DVCSList:
		return soap_in_bmd230__DVCSList(soap, NULL, NULL, "bmd230:DVCSList");
	case SOAP_TYPE_bmd230__SignatureSingle:
		return soap_in_bmd230__SignatureSingle(soap, NULL, NULL, "bmd230:SignatureSingle");
	case SOAP_TYPE_bmd230__TimestampList:
		return soap_in_bmd230__TimestampList(soap, NULL, NULL, "bmd230:TimestampList");
	case SOAP_TYPE_bmd230__DVCSSingle:
		return soap_in_bmd230__DVCSSingle(soap, NULL, NULL, "bmd230:DVCSSingle");
	case SOAP_TYPE_bmd230__TimestampSingle:
		return soap_in_bmd230__TimestampSingle(soap, NULL, NULL, "bmd230:TimestampSingle");
	case SOAP_TYPE_bmd230__LongNumbersList:
		return soap_in_bmd230__LongNumbersList(soap, NULL, NULL, "bmd230:LongNumbersList");
	case SOAP_TYPE_bmd230__myBinaryDataType:
		return soap_in_bmd230__myBinaryDataType(soap, NULL, NULL, "bmd230:myBinaryDataType");
	case SOAP_TYPE_xsd__base64Binary:
		return soap_in_xsd__base64Binary(soap, NULL, NULL, "xsd:base64Binary");
	case SOAP_TYPE_ds__RSAKeyValueType:
		return soap_in_ds__RSAKeyValueType(soap, NULL, NULL, "ds:RSAKeyValueType");
	case SOAP_TYPE_ds__DSAKeyValueType:
		return soap_in_ds__DSAKeyValueType(soap, NULL, NULL, "ds:DSAKeyValueType");
	case SOAP_TYPE_ds__X509IssuerSerialType:
		return soap_in_ds__X509IssuerSerialType(soap, NULL, NULL, "ds:X509IssuerSerialType");
	case SOAP_TYPE_ds__X509DataType:
		return soap_in_ds__X509DataType(soap, NULL, NULL, "ds:X509DataType");
	case SOAP_TYPE_ds__RetrievalMethodType:
		return soap_in_ds__RetrievalMethodType(soap, NULL, NULL, "ds:RetrievalMethodType");
	case SOAP_TYPE_ds__KeyValueType:
		return soap_in_ds__KeyValueType(soap, NULL, NULL, "ds:KeyValueType");
	case SOAP_TYPE_ds__DigestMethodType:
		return soap_in_ds__DigestMethodType(soap, NULL, NULL, "ds:DigestMethodType");
	case SOAP_TYPE_ds__TransformType:
		return soap_in_ds__TransformType(soap, NULL, NULL, "ds:TransformType");
	case SOAP_TYPE_ds__TransformsType:
		return soap_in_ds__TransformsType(soap, NULL, NULL, "ds:TransformsType");
	case SOAP_TYPE_ds__ReferenceType:
		return soap_in_ds__ReferenceType(soap, NULL, NULL, "ds:ReferenceType");
	case SOAP_TYPE_ds__SignatureMethodType:
		return soap_in_ds__SignatureMethodType(soap, NULL, NULL, "ds:SignatureMethodType");
	case SOAP_TYPE_ds__CanonicalizationMethodType:
		return soap_in_ds__CanonicalizationMethodType(soap, NULL, NULL, "ds:CanonicalizationMethodType");
	case SOAP_TYPE_ds__KeyInfoType:
		return soap_in_ds__KeyInfoType(soap, NULL, NULL, "ds:KeyInfoType");
	case SOAP_TYPE_ds__SignedInfoType:
		return soap_in_ds__SignedInfoType(soap, NULL, NULL, "ds:SignedInfoType");
	case SOAP_TYPE_ds__SignatureType:
		return soap_in_ds__SignatureType(soap, NULL, NULL, "ds:SignatureType");
	case SOAP_TYPE_PointerTobmd230__deleteCascadeLinksList:
		return soap_in_PointerTobmd230__deleteCascadeLinksList(soap, NULL, NULL, "bmd230:deleteCascadeLinksList");
	case SOAP_TYPE_PointerToPointerTobmd230__manyCascadeLinksResult:
		return soap_in_PointerToPointerTobmd230__manyCascadeLinksResult(soap, NULL, NULL, "bmd230:manyCascadeLinksResult");
	case SOAP_TYPE_PointerTobmd230__manyCascadeLinksResult:
		return soap_in_PointerTobmd230__manyCascadeLinksResult(soap, NULL, NULL, "bmd230:manyCascadeLinksResult");
	case SOAP_TYPE_PointerTobmd230__cascadeLinksInfo:
		return soap_in_PointerTobmd230__cascadeLinksInfo(soap, NULL, NULL, "bmd230:cascadeLinksInfo");
	case SOAP_TYPE_PointerTobmd230__linksInfo:
		return soap_in_PointerTobmd230__linksInfo(soap, NULL, NULL, "bmd230:linksInfo");
	case SOAP_TYPE_PointerToPointerTobmd230__archPackOut:
		return soap_in_PointerToPointerTobmd230__archPackOut(soap, NULL, NULL, "bmd230:archPackOut");
	case SOAP_TYPE_PointerTobmd230__archPackOut:
		return soap_in_PointerTobmd230__archPackOut(soap, NULL, NULL, "bmd230:archPackOut");
	case SOAP_TYPE_PointerToPointerTobmd230__fileInfoList:
		return soap_in_PointerToPointerTobmd230__fileInfoList(soap, NULL, NULL, "bmd230:fileInfoList");
	case SOAP_TYPE_PointerTobmd230__fileInfoList:
		return soap_in_PointerTobmd230__fileInfoList(soap, NULL, NULL, "bmd230:fileInfoList");
	case SOAP_TYPE_PointerToPointerTobmd230__stringList:
		return soap_in_PointerToPointerTobmd230__stringList(soap, NULL, NULL, "bmd230:stringList");
	case SOAP_TYPE_PointerToPointerTobmd230__ActionsHistoryList:
		return soap_in_PointerToPointerTobmd230__ActionsHistoryList(soap, NULL, NULL, "bmd230:ActionsHistoryList");
	case SOAP_TYPE_PointerTobmd230__ActionsHistoryList:
		return soap_in_PointerTobmd230__ActionsHistoryList(soap, NULL, NULL, "bmd230:ActionsHistoryList");
	case SOAP_TYPE_PointerToPointerTobmd230__GetVersionsHistoryResultList:
		return soap_in_PointerToPointerTobmd230__GetVersionsHistoryResultList(soap, NULL, NULL, "bmd230:GetVersionsHistoryResultList");
	case SOAP_TYPE_PointerTobmd230__GetVersionsHistoryResultList:
		return soap_in_PointerTobmd230__GetVersionsHistoryResultList(soap, NULL, NULL, "bmd230:GetVersionsHistoryResultList");
	case SOAP_TYPE_PointerTobmd230__LongNumbersList:
		return soap_in_PointerTobmd230__LongNumbersList(soap, NULL, NULL, "bmd230:LongNumbersList");
	case SOAP_TYPE_PointerToPointerTobmd230__accessObjectList:
		return soap_in_PointerToPointerTobmd230__accessObjectList(soap, NULL, NULL, "bmd230:accessObjectList");
	case SOAP_TYPE_PointerTobmd230__accessObjectList:
		return soap_in_PointerTobmd230__accessObjectList(soap, NULL, NULL, "bmd230:accessObjectList");
	case SOAP_TYPE_PointerToPointerTobmd230__bmdTimestamp:
		return soap_in_PointerToPointerTobmd230__bmdTimestamp(soap, NULL, NULL, "bmd230:bmdTimestamp");
	case SOAP_TYPE_PointerTobmd230__bmdTimestamp:
		return soap_in_PointerTobmd230__bmdTimestamp(soap, NULL, NULL, "bmd230:bmdTimestamp");
	case SOAP_TYPE_PointerToPointerTobmd230__PkiFileInfo:
		return soap_in_PointerToPointerTobmd230__PkiFileInfo(soap, NULL, NULL, "bmd230:PkiFileInfo");
	case SOAP_TYPE_PointerTobmd230__PkiFileInfo:
		return soap_in_PointerTobmd230__PkiFileInfo(soap, NULL, NULL, "bmd230:PkiFileInfo");
	case SOAP_TYPE_PointerToPointerTobmd230__securityInfo:
		return soap_in_PointerToPointerTobmd230__securityInfo(soap, NULL, NULL, "bmd230:securityInfo");
	case SOAP_TYPE_PointerTobmd230__securityInfo:
		return soap_in_PointerTobmd230__securityInfo(soap, NULL, NULL, "bmd230:securityInfo");
	case SOAP_TYPE_PointerToPointerTobmd230__classInfo:
		return soap_in_PointerToPointerTobmd230__classInfo(soap, NULL, NULL, "bmd230:classInfo");
	case SOAP_TYPE_PointerTobmd230__classInfo:
		return soap_in_PointerTobmd230__classInfo(soap, NULL, NULL, "bmd230:classInfo");
	case SOAP_TYPE_PointerToPointerTobmd230__groupInfo:
		return soap_in_PointerToPointerTobmd230__groupInfo(soap, NULL, NULL, "bmd230:groupInfo");
	case SOAP_TYPE_PointerTobmd230__groupInfo:
		return soap_in_PointerTobmd230__groupInfo(soap, NULL, NULL, "bmd230:groupInfo");
	case SOAP_TYPE_PointerToPointerTobmd230__userRoleInfo:
		return soap_in_PointerToPointerTobmd230__userRoleInfo(soap, NULL, NULL, "bmd230:userRoleInfo");
	case SOAP_TYPE_PointerTobmd230__userRoleInfo:
		return soap_in_PointerTobmd230__userRoleInfo(soap, NULL, NULL, "bmd230:userRoleInfo");
	case SOAP_TYPE_PointerToPointerTobmd230__userListInfo:
		return soap_in_PointerToPointerTobmd230__userListInfo(soap, NULL, NULL, "bmd230:userListInfo");
	case SOAP_TYPE_PointerTobmd230__userListInfo:
		return soap_in_PointerTobmd230__userListInfo(soap, NULL, NULL, "bmd230:userListInfo");
	case SOAP_TYPE_PointerToPointerTobmd230__userRegistrationResult:
		return soap_in_PointerToPointerTobmd230__userRegistrationResult(soap, NULL, NULL, "bmd230:userRegistrationResult");
	case SOAP_TYPE_PointerTobmd230__userRegistrationResult:
		return soap_in_PointerTobmd230__userRegistrationResult(soap, NULL, NULL, "bmd230:userRegistrationResult");
	case SOAP_TYPE_PointerToPointerTobmd230__historyResults:
		return soap_in_PointerToPointerTobmd230__historyResults(soap, NULL, NULL, "bmd230:historyResults");
	case SOAP_TYPE_PointerTobmd230__historyResults:
		return soap_in_PointerTobmd230__historyResults(soap, NULL, NULL, "bmd230:historyResults");
	case SOAP_TYPE_PointerTobmd230__mtdsSearchValues:
		return soap_in_PointerTobmd230__mtdsSearchValues(soap, NULL, NULL, "bmd230:mtdsSearchValues");
	case SOAP_TYPE_PointerToPointerTobmd230__fileInfo:
		return soap_in_PointerToPointerTobmd230__fileInfo(soap, NULL, NULL, "bmd230:fileInfo");
	case SOAP_TYPE_PointerToPointerTobmd230__searchResults:
		return soap_in_PointerToPointerTobmd230__searchResults(soap, NULL, NULL, "bmd230:searchResults");
	case SOAP_TYPE_PointerTobmd230__searchResults:
		return soap_in_PointerTobmd230__searchResults(soap, NULL, NULL, "bmd230:searchResults");
	case SOAP_TYPE_PointerTobmd230__searchSortInfoList:
		return soap_in_PointerTobmd230__searchSortInfoList(soap, NULL, NULL, "bmd230:searchSortInfoList");
	case SOAP_TYPE_PointerToPointerTobmd230__loginResponse:
		return soap_in_PointerToPointerTobmd230__loginResponse(soap, NULL, NULL, "bmd230:loginResponse");
	case SOAP_TYPE_PointerTobmd230__loginResponse:
		return soap_in_PointerTobmd230__loginResponse(soap, NULL, NULL, "bmd230:loginResponse");
	case SOAP_TYPE_PointerToPointerTobmd230__idList:
		return soap_in_PointerToPointerTobmd230__idList(soap, NULL, NULL, "bmd230:idList");
	case SOAP_TYPE_PointerTobmd230__fileComplexList:
		return soap_in_PointerTobmd230__fileComplexList(soap, NULL, NULL, "bmd230:fileComplexList");
	case SOAP_TYPE_PointerTostring:
		return soap_in_PointerTostring(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerTobmd230__ActionsHistoryElement:
		return soap_in_PointerTobmd230__ActionsHistoryElement(soap, NULL, NULL, "bmd230:ActionsHistoryElement");
	case SOAP_TYPE_PointerTobmd230__GetVersionsHistoryResult:
		return soap_in_PointerTobmd230__GetVersionsHistoryResult(soap, NULL, NULL, "bmd230:GetVersionsHistoryResult");
	case SOAP_TYPE_PointerTobmd230__FileVersionInfoList:
		return soap_in_PointerTobmd230__FileVersionInfoList(soap, NULL, NULL, "bmd230:FileVersionInfoList");
	case SOAP_TYPE_PointerTobmd230__FileVersionInfo:
		return soap_in_PointerTobmd230__FileVersionInfo(soap, NULL, NULL, "bmd230:FileVersionInfo");
	case SOAP_TYPE_PointerTobmd230__accessObject:
		return soap_in_PointerTobmd230__accessObject(soap, NULL, NULL, "bmd230:accessObject");
	case SOAP_TYPE_PointerTobmd230__deleteCascadeLinksElement:
		return soap_in_PointerTobmd230__deleteCascadeLinksElement(soap, NULL, NULL, "bmd230:deleteCascadeLinksElement");
	case SOAP_TYPE_PointerTobmd230__manyCascadeLinksElement:
		return soap_in_PointerTobmd230__manyCascadeLinksElement(soap, NULL, NULL, "bmd230:manyCascadeLinksElement");
	case SOAP_TYPE_PointerTobmd230__idList:
		return soap_in_PointerTobmd230__idList(soap, NULL, NULL, "bmd230:idList");
	case SOAP_TYPE_PointerTobmd230__singleCascadeLinkInfo:
		return soap_in_PointerTobmd230__singleCascadeLinkInfo(soap, NULL, NULL, "bmd230:singleCascadeLinkInfo");
	case SOAP_TYPE_PointerTobmd230__singleLinkInfo:
		return soap_in_PointerTobmd230__singleLinkInfo(soap, NULL, NULL, "bmd230:singleLinkInfo");
	case SOAP_TYPE_PointerTobmd230__DateTime:
		return soap_in_PointerTobmd230__DateTime(soap, NULL, NULL, "bmd230:DateTime");
	case SOAP_TYPE_PointerTobmd230__secLevelInfo:
		return soap_in_PointerTobmd230__secLevelInfo(soap, NULL, NULL, "bmd230:secLevelInfo");
	case SOAP_TYPE_PointerTobmd230__secCategoryInfo:
		return soap_in_PointerTobmd230__secCategoryInfo(soap, NULL, NULL, "bmd230:secCategoryInfo");
	case SOAP_TYPE_PointerTobmd230__singleSecLevelInfo:
		return soap_in_PointerTobmd230__singleSecLevelInfo(soap, NULL, NULL, "bmd230:singleSecLevelInfo");
	case SOAP_TYPE_PointerTobmd230__singleSecCategoryInfo:
		return soap_in_PointerTobmd230__singleSecCategoryInfo(soap, NULL, NULL, "bmd230:singleSecCategoryInfo");
	case SOAP_TYPE_PointerTobmd230__singleClassInfo:
		return soap_in_PointerTobmd230__singleClassInfo(soap, NULL, NULL, "bmd230:singleClassInfo");
	case SOAP_TYPE_PointerTobmd230__singleGroupInfo:
		return soap_in_PointerTobmd230__singleGroupInfo(soap, NULL, NULL, "bmd230:singleGroupInfo");
	case SOAP_TYPE_PointerTobmd230__singleRoleInfo:
		return soap_in_PointerTobmd230__singleRoleInfo(soap, NULL, NULL, "bmd230:singleRoleInfo");
	case SOAP_TYPE_PointerTobmd230__mtdsInfo:
		return soap_in_PointerTobmd230__mtdsInfo(soap, NULL, NULL, "bmd230:mtdsInfo");
	case SOAP_TYPE_PointerTobmd230__singleUserInfo:
		return soap_in_PointerTobmd230__singleUserInfo(soap, NULL, NULL, "bmd230:singleUserInfo");
	case SOAP_TYPE_PointerTobmd230__userNewGroupInfo:
		return soap_in_PointerTobmd230__userNewGroupInfo(soap, NULL, NULL, "bmd230:userNewGroupInfo");
	case SOAP_TYPE_PointerTobmd230__stringList:
		return soap_in_PointerTobmd230__stringList(soap, NULL, NULL, "bmd230:stringList");
	case SOAP_TYPE_PointerToxsd__string:
		return soap_in_PointerToxsd__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerTobmd230__mtdSearchSingleValue:
		return soap_in_PointerTobmd230__mtdSearchSingleValue(soap, NULL, NULL, "bmd230:mtdSearchSingleValue");
	case SOAP_TYPE_PointerTobmd230__historySingleResult:
		return soap_in_PointerTobmd230__historySingleResult(soap, NULL, NULL, "bmd230:historySingleResult");
	case SOAP_TYPE_PointerTobmd230__searchSingleResult:
		return soap_in_PointerTobmd230__searchSingleResult(soap, NULL, NULL, "bmd230:searchSingleResult");
	case SOAP_TYPE_PointerTobmd230__mtdSingleInfo:
		return soap_in_PointerTobmd230__mtdSingleInfo(soap, NULL, NULL, "bmd230:mtdSingleInfo");
	case SOAP_TYPE_PointerTobmd230__searchSortInfo:
		return soap_in_PointerTobmd230__searchSortInfo(soap, NULL, NULL, "bmd230:searchSortInfo");
	case SOAP_TYPE_PointerTobmd230__fileComplex:
		return soap_in_PointerTobmd230__fileComplex(soap, NULL, NULL, "bmd230:fileComplex");
	case SOAP_TYPE_PointerTobmd230__mtdsValues:
		return soap_in_PointerTobmd230__mtdsValues(soap, NULL, NULL, "bmd230:mtdsValues");
	case SOAP_TYPE_PointerTobmd230__mtdSingleValue:
		return soap_in_PointerTobmd230__mtdSingleValue(soap, NULL, NULL, "bmd230:mtdSingleValue");
	case SOAP_TYPE_PointerTobmd230__fileInfo:
		return soap_in_PointerTobmd230__fileInfo(soap, NULL, NULL, "bmd230:fileInfo");
	case SOAP_TYPE_PointerTobmd230__myBinaryDataType:
		return soap_in_PointerTobmd230__myBinaryDataType(soap, NULL, NULL, "bmd230:myBinaryDataType");
	case SOAP_TYPE_PointerTobmd230__SignatureList:
		return soap_in_PointerTobmd230__SignatureList(soap, NULL, NULL, "bmd230:SignatureList");
	case SOAP_TYPE_PointerTobmd230__SignatureSingle:
		return soap_in_PointerTobmd230__SignatureSingle(soap, NULL, NULL, "bmd230:SignatureSingle");
	case SOAP_TYPE_PointerTobmd230__DVCSSingle:
		return soap_in_PointerTobmd230__DVCSSingle(soap, NULL, NULL, "bmd230:DVCSSingle");
	case SOAP_TYPE_PointerTobmd230__TimestampSingle:
		return soap_in_PointerTobmd230__TimestampSingle(soap, NULL, NULL, "bmd230:TimestampSingle");
	case SOAP_TYPE_PointerTobmd230__DVCSList:
		return soap_in_PointerTobmd230__DVCSList(soap, NULL, NULL, "bmd230:DVCSList");
	case SOAP_TYPE_PointerTobmd230__TimestampList:
		return soap_in_PointerTobmd230__TimestampList(soap, NULL, NULL, "bmd230:TimestampList");
	case SOAP_TYPE_PointerToxsd__base64Binary:
		return soap_in_PointerToxsd__base64Binary(soap, NULL, NULL, "xsd:base64Binary");
	case SOAP_TYPE_PointerTolong:
		return soap_in_PointerTolong(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_PointerTounsignedByte:
		return soap_in_PointerTounsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
	case SOAP_TYPE_xsd__string:
	{	char **s;
		s = soap_in_xsd__string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_PointerTo_wsse__Security:
		return soap_in_PointerTo_wsse__Security(soap, NULL, NULL, "wsse:Security");
	case SOAP_TYPE_PointerTods__SignatureType:
		return soap_in_PointerTods__SignatureType(soap, NULL, NULL, "ds:SignatureType");
	case SOAP_TYPE_PointerTo_wsse__BinarySecurityToken:
		return soap_in_PointerTo_wsse__BinarySecurityToken(soap, NULL, NULL, "wsse:BinarySecurityToken");
	case SOAP_TYPE_PointerTo_wsse__UsernameToken:
		return soap_in_PointerTo_wsse__UsernameToken(soap, NULL, NULL, "wsse:UsernameToken");
	case SOAP_TYPE_PointerTo_wsu__Timestamp:
		return soap_in_PointerTo_wsu__Timestamp(soap, NULL, NULL, "wsu:Timestamp");
	case SOAP_TYPE_PointerTods__X509IssuerSerialType:
		return soap_in_PointerTods__X509IssuerSerialType(soap, NULL, NULL, "ds:X509IssuerSerialType");
	case SOAP_TYPE_PointerTods__RSAKeyValueType:
		return soap_in_PointerTods__RSAKeyValueType(soap, NULL, NULL, "ds:RSAKeyValueType");
	case SOAP_TYPE_PointerTods__DSAKeyValueType:
		return soap_in_PointerTods__DSAKeyValueType(soap, NULL, NULL, "ds:DSAKeyValueType");
	case SOAP_TYPE_PointerTods__TransformType:
		return soap_in_PointerTods__TransformType(soap, NULL, NULL, "ds:TransformType");
	case SOAP_TYPE_PointerTods__DigestMethodType:
		return soap_in_PointerTods__DigestMethodType(soap, NULL, NULL, "ds:DigestMethodType");
	case SOAP_TYPE_PointerTods__TransformsType:
		return soap_in_PointerTods__TransformsType(soap, NULL, NULL, "ds:TransformsType");
	case SOAP_TYPE_PointerToint:
		return soap_in_PointerToint(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_PointerToPointerTods__ReferenceType:
		return soap_in_PointerToPointerTods__ReferenceType(soap, NULL, NULL, "ds:ReferenceType");
	case SOAP_TYPE_PointerTods__ReferenceType:
		return soap_in_PointerTods__ReferenceType(soap, NULL, NULL, "ds:ReferenceType");
	case SOAP_TYPE_PointerTods__SignatureMethodType:
		return soap_in_PointerTods__SignatureMethodType(soap, NULL, NULL, "ds:SignatureMethodType");
	case SOAP_TYPE_PointerTods__CanonicalizationMethodType:
		return soap_in_PointerTods__CanonicalizationMethodType(soap, NULL, NULL, "ds:CanonicalizationMethodType");
	case SOAP_TYPE_PointerTo_wsse__SecurityTokenReference:
		return soap_in_PointerTo_wsse__SecurityTokenReference(soap, NULL, NULL, "wsse:SecurityTokenReference");
	case SOAP_TYPE_PointerTods__X509DataType:
		return soap_in_PointerTods__X509DataType(soap, NULL, NULL, "ds:X509DataType");
	case SOAP_TYPE_PointerTods__RetrievalMethodType:
		return soap_in_PointerTods__RetrievalMethodType(soap, NULL, NULL, "ds:RetrievalMethodType");
	case SOAP_TYPE_PointerTods__KeyValueType:
		return soap_in_PointerTods__KeyValueType(soap, NULL, NULL, "ds:KeyValueType");
	case SOAP_TYPE_PointerTo_c14n__InclusiveNamespaces:
		return soap_in_PointerTo_c14n__InclusiveNamespaces(soap, NULL, NULL, "c14n:InclusiveNamespaces");
	case SOAP_TYPE_PointerTods__KeyInfoType:
		return soap_in_PointerTods__KeyInfoType(soap, NULL, NULL, "ds:KeyInfoType");
	case SOAP_TYPE_PointerTods__SignedInfoType:
		return soap_in_PointerTods__SignedInfoType(soap, NULL, NULL, "ds:SignedInfoType");
	case SOAP_TYPE_PointerTo_wsse__Embedded:
		return soap_in_PointerTo_wsse__Embedded(soap, NULL, NULL, "wsse:Embedded");
	case SOAP_TYPE_PointerTo_wsse__KeyIdentifier:
		return soap_in_PointerTo_wsse__KeyIdentifier(soap, NULL, NULL, "wsse:KeyIdentifier");
	case SOAP_TYPE_PointerTo_wsse__Reference:
		return soap_in_PointerTo_wsse__Reference(soap, NULL, NULL, "wsse:Reference");
	case SOAP_TYPE_PointerTo_wsse__Password:
		return soap_in_PointerTo_wsse__Password(soap, NULL, NULL, "wsse:Password");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_xsd__int;
			return soap_in_xsd__int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_long;
			return soap_in_long(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedByte"))
		{	*type = SOAP_TYPE_unsignedByte;
			return soap_in_unsignedByte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedInt"))
		{	*type = SOAP_TYPE_unsignedInt;
			return soap_in_unsignedInt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "groupAuthorizationType-e"))
		{	*type = SOAP_TYPE_groupAuthorizationType_e;
			return soap_in_groupAuthorizationType_e(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "chunkCntr-t"))
		{	*type = SOAP_TYPE_chunkCntr_t;
			return soap_in_chunkCntr_t(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "trans-t"))
		{	*type = SOAP_TYPE_trans_t;
			return soap_in_trans_t(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "visibilityType-t"))
		{	*type = SOAP_TYPE_visibilityType_t;
			return soap_in_visibilityType_t(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "grantingType-e"))
		{	*type = SOAP_TYPE_grantingType_e;
			return soap_in_grantingType_e(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:FaultcodeEnum"))
		{	*type = SOAP_TYPE_wsse__FaultcodeEnum;
			return soap_in_wsse__FaultcodeEnum(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsu:tTimestampFault"))
		{	*type = SOAP_TYPE_wsu__tTimestampFault;
			return soap_in_wsu__tTimestampFault(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdDeleteReplacedLobs"))
		{	*type = SOAP_TYPE_bmd230__bmdDeleteReplacedLobs;
			return soap_in_bmd230__bmdDeleteReplacedLobs(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdDeleteReplacedLobsResponse"))
		{	*type = SOAP_TYPE_bmd230__bmdDeleteReplacedLobsResponse;
			return soap_in_bmd230__bmdDeleteReplacedLobsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdConservateTimestamps"))
		{	*type = SOAP_TYPE_bmd230__bmdConservateTimestamps;
			return soap_in_bmd230__bmdConservateTimestamps(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdConservateTimestampsResponse"))
		{	*type = SOAP_TYPE_bmd230__bmdConservateTimestampsResponse;
			return soap_in_bmd230__bmdConservateTimestampsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdDeleteCascadeLinks"))
		{	*type = SOAP_TYPE_bmd230__bmdDeleteCascadeLinks;
			return soap_in_bmd230__bmdDeleteCascadeLinks(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdDeleteCascadeLinksResponse"))
		{	*type = SOAP_TYPE_bmd230__bmdDeleteCascadeLinksResponse;
			return soap_in_bmd230__bmdDeleteCascadeLinksResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdCreateManyCascadeLinks"))
		{	*type = SOAP_TYPE_bmd230__bmdCreateManyCascadeLinks;
			return soap_in_bmd230__bmdCreateManyCascadeLinks(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdCreateManyCascadeLinksResponse"))
		{	*type = SOAP_TYPE_bmd230__bmdCreateManyCascadeLinksResponse;
			return soap_in_bmd230__bmdCreateManyCascadeLinksResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdCreateCascadeLinks"))
		{	*type = SOAP_TYPE_bmd230__bmdCreateCascadeLinks;
			return soap_in_bmd230__bmdCreateCascadeLinks(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdCreateCascadeLinksResponse"))
		{	*type = SOAP_TYPE_bmd230__bmdCreateCascadeLinksResponse;
			return soap_in_bmd230__bmdCreateCascadeLinksResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdCreateLinks"))
		{	*type = SOAP_TYPE_bmd230__bmdCreateLinks;
			return soap_in_bmd230__bmdCreateLinks(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdCreateLinksResponse"))
		{	*type = SOAP_TYPE_bmd230__bmdCreateLinksResponse;
			return soap_in_bmd230__bmdCreateLinksResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdCreateLink"))
		{	*type = SOAP_TYPE_bmd230__bmdCreateLink;
			return soap_in_bmd230__bmdCreateLink(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdCreateLinkResponse"))
		{	*type = SOAP_TYPE_bmd230__bmdCreateLinkResponse;
			return soap_in_bmd230__bmdCreateLinkResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdGetDirectoryDetails"))
		{	*type = SOAP_TYPE_bmd230__bmdGetDirectoryDetails;
			return soap_in_bmd230__bmdGetDirectoryDetails(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdGetDirectoryDetailsResponse"))
		{	*type = SOAP_TYPE_bmd230__bmdGetDirectoryDetailsResponse;
			return soap_in_bmd230__bmdGetDirectoryDetailsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdCreateDirectory"))
		{	*type = SOAP_TYPE_bmd230__bmdCreateDirectory;
			return soap_in_bmd230__bmdCreateDirectory(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdCreateDirectoryResponse"))
		{	*type = SOAP_TYPE_bmd230__bmdCreateDirectoryResponse;
			return soap_in_bmd230__bmdCreateDirectoryResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdStopTransaction"))
		{	*type = SOAP_TYPE_bmd230__bmdStopTransaction;
			return soap_in_bmd230__bmdStopTransaction(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdStopTransactionResponse"))
		{	*type = SOAP_TYPE_bmd230__bmdStopTransactionResponse;
			return soap_in_bmd230__bmdStopTransactionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdStartTransaction"))
		{	*type = SOAP_TYPE_bmd230__bmdStartTransaction;
			return soap_in_bmd230__bmdStartTransaction(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdStartTransactionResponse"))
		{	*type = SOAP_TYPE_bmd230__bmdStartTransactionResponse;
			return soap_in_bmd230__bmdStartTransactionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdGetArchPackInChunk"))
		{	*type = SOAP_TYPE_bmd230__bmdGetArchPackInChunk;
			return soap_in_bmd230__bmdGetArchPackInChunk(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdGetArchPackInChunkResponse"))
		{	*type = SOAP_TYPE_bmd230__bmdGetArchPackInChunkResponse;
			return soap_in_bmd230__bmdGetArchPackInChunkResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdGetFileChunkIter"))
		{	*type = SOAP_TYPE_bmd230__bmdGetFileChunkIter;
			return soap_in_bmd230__bmdGetFileChunkIter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdGetFileChunkIterResponse"))
		{	*type = SOAP_TYPE_bmd230__bmdGetFileChunkIterResponse;
			return soap_in_bmd230__bmdGetFileChunkIterResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdGetFileChunkStart"))
		{	*type = SOAP_TYPE_bmd230__bmdGetFileChunkStart;
			return soap_in_bmd230__bmdGetFileChunkStart(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdGetFileChunkStartResponse"))
		{	*type = SOAP_TYPE_bmd230__bmdGetFileChunkStartResponse;
			return soap_in_bmd230__bmdGetFileChunkStartResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdInsertFileChunkIter"))
		{	*type = SOAP_TYPE_bmd230__bmdInsertFileChunkIter;
			return soap_in_bmd230__bmdInsertFileChunkIter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdInsertFileChunkIterResponse"))
		{	*type = SOAP_TYPE_bmd230__bmdInsertFileChunkIterResponse;
			return soap_in_bmd230__bmdInsertFileChunkIterResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdInsertFileChunkStart"))
		{	*type = SOAP_TYPE_bmd230__bmdInsertFileChunkStart;
			return soap_in_bmd230__bmdInsertFileChunkStart(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdInsertFileChunkStartResponse"))
		{	*type = SOAP_TYPE_bmd230__bmdInsertFileChunkStartResponse;
			return soap_in_bmd230__bmdInsertFileChunkStartResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:getFile"))
		{	*type = SOAP_TYPE_bmd230__getFile;
			return soap_in_bmd230__getFile(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:getFileResponse"))
		{	*type = SOAP_TYPE_bmd230__getFileResponse;
			return soap_in_bmd230__getFileResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:countInvoice"))
		{	*type = SOAP_TYPE_bmd230__countInvoice;
			return soap_in_bmd230__countInvoice(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:countInvoiceResponse"))
		{	*type = SOAP_TYPE_bmd230__countInvoiceResponse;
			return soap_in_bmd230__countInvoiceResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:verifyInvoiceWithDetails"))
		{	*type = SOAP_TYPE_bmd230__verifyInvoiceWithDetails;
			return soap_in_bmd230__verifyInvoiceWithDetails(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:verifyInvoiceWithDetailsResponse"))
		{	*type = SOAP_TYPE_bmd230__verifyInvoiceWithDetailsResponse;
			return soap_in_bmd230__verifyInvoiceWithDetailsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:verifyInvoiceSimplified"))
		{	*type = SOAP_TYPE_bmd230__verifyInvoiceSimplified;
			return soap_in_bmd230__verifyInvoiceSimplified(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:verifyInvoiceSimplifiedResponse"))
		{	*type = SOAP_TYPE_bmd230__verifyInvoiceSimplifiedResponse;
			return soap_in_bmd230__verifyInvoiceSimplifiedResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:verifyInvoice"))
		{	*type = SOAP_TYPE_bmd230__verifyInvoice;
			return soap_in_bmd230__verifyInvoice(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:verifyInvoiceResponse"))
		{	*type = SOAP_TYPE_bmd230__verifyInvoiceResponse;
			return soap_in_bmd230__verifyInvoiceResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:getHTMLImage"))
		{	*type = SOAP_TYPE_bmd230__getHTMLImage;
			return soap_in_bmd230__getHTMLImage(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:getHTMLImageResponse"))
		{	*type = SOAP_TYPE_bmd230__getHTMLImageResponse;
			return soap_in_bmd230__getHTMLImageResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:getInvoicePack"))
		{	*type = SOAP_TYPE_bmd230__getInvoicePack;
			return soap_in_bmd230__getInvoicePack(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:getInvoicePackResponse"))
		{	*type = SOAP_TYPE_bmd230__getInvoicePackResponse;
			return soap_in_bmd230__getInvoicePackResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:SendAdviceWithParameters"))
		{	*type = SOAP_TYPE_bmd230__SendAdviceWithParameters;
			return soap_in_bmd230__SendAdviceWithParameters(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:SendAdviceWithParametersResponse"))
		{	*type = SOAP_TYPE_bmd230__SendAdviceWithParametersResponse;
			return soap_in_bmd230__SendAdviceWithParametersResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:SendAdvice"))
		{	*type = SOAP_TYPE_bmd230__SendAdvice;
			return soap_in_bmd230__SendAdvice(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:SendAdviceResponse"))
		{	*type = SOAP_TYPE_bmd230__SendAdviceResponse;
			return soap_in_bmd230__SendAdviceResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:verifyInvoiceWithDetailsById"))
		{	*type = SOAP_TYPE_bmd230__verifyInvoiceWithDetailsById;
			return soap_in_bmd230__verifyInvoiceWithDetailsById(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:verifyInvoiceWithDetailsByIdResponse"))
		{	*type = SOAP_TYPE_bmd230__verifyInvoiceWithDetailsByIdResponse;
			return soap_in_bmd230__verifyInvoiceWithDetailsByIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:verifyInvoiceById"))
		{	*type = SOAP_TYPE_bmd230__verifyInvoiceById;
			return soap_in_bmd230__verifyInvoiceById(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:verifyInvoiceByIdResponse"))
		{	*type = SOAP_TYPE_bmd230__verifyInvoiceByIdResponse;
			return soap_in_bmd230__verifyInvoiceByIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:getHTMLImageById"))
		{	*type = SOAP_TYPE_bmd230__getHTMLImageById;
			return soap_in_bmd230__getHTMLImageById(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:getHTMLImageByIdResponse"))
		{	*type = SOAP_TYPE_bmd230__getHTMLImageByIdResponse;
			return soap_in_bmd230__getHTMLImageByIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:getInvoicePackById"))
		{	*type = SOAP_TYPE_bmd230__getInvoicePackById;
			return soap_in_bmd230__getInvoicePackById(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:getInvoicePackByIdResponse"))
		{	*type = SOAP_TYPE_bmd230__getInvoicePackByIdResponse;
			return soap_in_bmd230__getInvoicePackByIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdGetActionsHistoryById"))
		{	*type = SOAP_TYPE_bmd230__bmdGetActionsHistoryById;
			return soap_in_bmd230__bmdGetActionsHistoryById(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdGetActionsHistoryByIdResponse"))
		{	*type = SOAP_TYPE_bmd230__bmdGetActionsHistoryByIdResponse;
			return soap_in_bmd230__bmdGetActionsHistoryByIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdGetVersionsHistory"))
		{	*type = SOAP_TYPE_bmd230__bmdGetVersionsHistory;
			return soap_in_bmd230__bmdGetVersionsHistory(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdGetVersionsHistoryResponse"))
		{	*type = SOAP_TYPE_bmd230__bmdGetVersionsHistoryResponse;
			return soap_in_bmd230__bmdGetVersionsHistoryResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdGetAccessObjects"))
		{	*type = SOAP_TYPE_bmd230__bmdGetAccessObjects;
			return soap_in_bmd230__bmdGetAccessObjects(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdGetAccessObjectsResponse"))
		{	*type = SOAP_TYPE_bmd230__bmdGetAccessObjectsResponse;
			return soap_in_bmd230__bmdGetAccessObjectsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdGetArchPack"))
		{	*type = SOAP_TYPE_bmd230__bmdGetArchPack;
			return soap_in_bmd230__bmdGetArchPack(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdGetArchPackResponse"))
		{	*type = SOAP_TYPE_bmd230__bmdGetArchPackResponse;
			return soap_in_bmd230__bmdGetArchPackResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdGetTimeStamp"))
		{	*type = SOAP_TYPE_bmd230__bmdGetTimeStamp;
			return soap_in_bmd230__bmdGetTimeStamp(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdGetTimeStampResponse"))
		{	*type = SOAP_TYPE_bmd230__bmdGetTimeStampResponse;
			return soap_in_bmd230__bmdGetTimeStampResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdGetFilePKIById"))
		{	*type = SOAP_TYPE_bmd230__bmdGetFilePKIById;
			return soap_in_bmd230__bmdGetFilePKIById(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdGetFilePKIByIdResponse"))
		{	*type = SOAP_TYPE_bmd230__bmdGetFilePKIByIdResponse;
			return soap_in_bmd230__bmdGetFilePKIByIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdGetFilePropByID"))
		{	*type = SOAP_TYPE_bmd230__bmdGetFilePropByID;
			return soap_in_bmd230__bmdGetFilePropByID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdGetFilePropByIDResponse"))
		{	*type = SOAP_TYPE_bmd230__bmdGetFilePropByIDResponse;
			return soap_in_bmd230__bmdGetFilePropByIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdGetFileByIdInZipPack"))
		{	*type = SOAP_TYPE_bmd230__bmdGetFileByIdInZipPack;
			return soap_in_bmd230__bmdGetFileByIdInZipPack(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdGetFileByIdInZipPackResponse"))
		{	*type = SOAP_TYPE_bmd230__bmdGetFileByIdInZipPackResponse;
			return soap_in_bmd230__bmdGetFileByIdInZipPackResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdGetFileByHash"))
		{	*type = SOAP_TYPE_bmd230__bmdGetFileByHash;
			return soap_in_bmd230__bmdGetFileByHash(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdGetFileByHashResponse"))
		{	*type = SOAP_TYPE_bmd230__bmdGetFileByHashResponse;
			return soap_in_bmd230__bmdGetFileByHashResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdGetArchiveFileVersion"))
		{	*type = SOAP_TYPE_bmd230__bmdGetArchiveFileVersion;
			return soap_in_bmd230__bmdGetArchiveFileVersion(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdGetArchiveFileVersionResponse"))
		{	*type = SOAP_TYPE_bmd230__bmdGetArchiveFileVersionResponse;
			return soap_in_bmd230__bmdGetArchiveFileVersionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdGetFileById"))
		{	*type = SOAP_TYPE_bmd230__bmdGetFileById;
			return soap_in_bmd230__bmdGetFileById(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdGetFileByIdResponse"))
		{	*type = SOAP_TYPE_bmd230__bmdGetFileByIdResponse;
			return soap_in_bmd230__bmdGetFileByIdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdGetSecurityList"))
		{	*type = SOAP_TYPE_bmd230__bmdGetSecurityList;
			return soap_in_bmd230__bmdGetSecurityList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdGetSecurityListResponse"))
		{	*type = SOAP_TYPE_bmd230__bmdGetSecurityListResponse;
			return soap_in_bmd230__bmdGetSecurityListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdRegisterNewSecurityCategory"))
		{	*type = SOAP_TYPE_bmd230__bmdRegisterNewSecurityCategory;
			return soap_in_bmd230__bmdRegisterNewSecurityCategory(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdRegisterNewSecurityCategoryResponse"))
		{	*type = SOAP_TYPE_bmd230__bmdRegisterNewSecurityCategoryResponse;
			return soap_in_bmd230__bmdRegisterNewSecurityCategoryResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdDeleteClass"))
		{	*type = SOAP_TYPE_bmd230__bmdDeleteClass;
			return soap_in_bmd230__bmdDeleteClass(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdDeleteClassResponse"))
		{	*type = SOAP_TYPE_bmd230__bmdDeleteClassResponse;
			return soap_in_bmd230__bmdDeleteClassResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdGetClassList"))
		{	*type = SOAP_TYPE_bmd230__bmdGetClassList;
			return soap_in_bmd230__bmdGetClassList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdGetClassListResponse"))
		{	*type = SOAP_TYPE_bmd230__bmdGetClassListResponse;
			return soap_in_bmd230__bmdGetClassListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdUpdateClass"))
		{	*type = SOAP_TYPE_bmd230__bmdUpdateClass;
			return soap_in_bmd230__bmdUpdateClass(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdUpdateClassResponse"))
		{	*type = SOAP_TYPE_bmd230__bmdUpdateClassResponse;
			return soap_in_bmd230__bmdUpdateClassResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdRegisterNewClass"))
		{	*type = SOAP_TYPE_bmd230__bmdRegisterNewClass;
			return soap_in_bmd230__bmdRegisterNewClass(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdRegisterNewClassResponse"))
		{	*type = SOAP_TYPE_bmd230__bmdRegisterNewClassResponse;
			return soap_in_bmd230__bmdRegisterNewClassResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdDeleteGroup"))
		{	*type = SOAP_TYPE_bmd230__bmdDeleteGroup;
			return soap_in_bmd230__bmdDeleteGroup(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdDeleteGroupResponse"))
		{	*type = SOAP_TYPE_bmd230__bmdDeleteGroupResponse;
			return soap_in_bmd230__bmdDeleteGroupResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdGetGroupsList"))
		{	*type = SOAP_TYPE_bmd230__bmdGetGroupsList;
			return soap_in_bmd230__bmdGetGroupsList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdGetGroupsListResponse"))
		{	*type = SOAP_TYPE_bmd230__bmdGetGroupsListResponse;
			return soap_in_bmd230__bmdGetGroupsListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdUpdateGroup"))
		{	*type = SOAP_TYPE_bmd230__bmdUpdateGroup;
			return soap_in_bmd230__bmdUpdateGroup(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdUpdateGroupResponse"))
		{	*type = SOAP_TYPE_bmd230__bmdUpdateGroupResponse;
			return soap_in_bmd230__bmdUpdateGroupResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdRegisterNewGroup"))
		{	*type = SOAP_TYPE_bmd230__bmdRegisterNewGroup;
			return soap_in_bmd230__bmdRegisterNewGroup(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdRegisterNewGroupResponse"))
		{	*type = SOAP_TYPE_bmd230__bmdRegisterNewGroupResponse;
			return soap_in_bmd230__bmdRegisterNewGroupResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdDeleteRole"))
		{	*type = SOAP_TYPE_bmd230__bmdDeleteRole;
			return soap_in_bmd230__bmdDeleteRole(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdDeleteRoleResponse"))
		{	*type = SOAP_TYPE_bmd230__bmdDeleteRoleResponse;
			return soap_in_bmd230__bmdDeleteRoleResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdGetRolesList"))
		{	*type = SOAP_TYPE_bmd230__bmdGetRolesList;
			return soap_in_bmd230__bmdGetRolesList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdGetRolesListResponse"))
		{	*type = SOAP_TYPE_bmd230__bmdGetRolesListResponse;
			return soap_in_bmd230__bmdGetRolesListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdUpdateRole"))
		{	*type = SOAP_TYPE_bmd230__bmdUpdateRole;
			return soap_in_bmd230__bmdUpdateRole(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdUpdateRoleResponse"))
		{	*type = SOAP_TYPE_bmd230__bmdUpdateRoleResponse;
			return soap_in_bmd230__bmdUpdateRoleResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdRegisterNewRole"))
		{	*type = SOAP_TYPE_bmd230__bmdRegisterNewRole;
			return soap_in_bmd230__bmdRegisterNewRole(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdRegisterNewRoleResponse"))
		{	*type = SOAP_TYPE_bmd230__bmdRegisterNewRoleResponse;
			return soap_in_bmd230__bmdRegisterNewRoleResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdDisableIdentity"))
		{	*type = SOAP_TYPE_bmd230__bmdDisableIdentity;
			return soap_in_bmd230__bmdDisableIdentity(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdDisableIdentityResponse"))
		{	*type = SOAP_TYPE_bmd230__bmdDisableIdentityResponse;
			return soap_in_bmd230__bmdDisableIdentityResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdDisableUser"))
		{	*type = SOAP_TYPE_bmd230__bmdDisableUser;
			return soap_in_bmd230__bmdDisableUser(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdDisableUserResponse"))
		{	*type = SOAP_TYPE_bmd230__bmdDisableUserResponse;
			return soap_in_bmd230__bmdDisableUserResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdDeleteUser"))
		{	*type = SOAP_TYPE_bmd230__bmdDeleteUser;
			return soap_in_bmd230__bmdDeleteUser(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdDeleteUserResponse"))
		{	*type = SOAP_TYPE_bmd230__bmdDeleteUserResponse;
			return soap_in_bmd230__bmdDeleteUserResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdGetUsersList"))
		{	*type = SOAP_TYPE_bmd230__bmdGetUsersList;
			return soap_in_bmd230__bmdGetUsersList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdGetUsersListResponse"))
		{	*type = SOAP_TYPE_bmd230__bmdGetUsersListResponse;
			return soap_in_bmd230__bmdGetUsersListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdUpdateUserRights"))
		{	*type = SOAP_TYPE_bmd230__bmdUpdateUserRights;
			return soap_in_bmd230__bmdUpdateUserRights(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdUpdateUserRightsResponse"))
		{	*type = SOAP_TYPE_bmd230__bmdUpdateUserRightsResponse;
			return soap_in_bmd230__bmdUpdateUserRightsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdAddCertificateToIdentity"))
		{	*type = SOAP_TYPE_bmd230__bmdAddCertificateToIdentity;
			return soap_in_bmd230__bmdAddCertificateToIdentity(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdAddCertificateToIdentityResponse"))
		{	*type = SOAP_TYPE_bmd230__bmdAddCertificateToIdentityResponse;
			return soap_in_bmd230__bmdAddCertificateToIdentityResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdRegisterNewUser"))
		{	*type = SOAP_TYPE_bmd230__bmdRegisterNewUser;
			return soap_in_bmd230__bmdRegisterNewUser(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdRegisterNewUserResponse"))
		{	*type = SOAP_TYPE_bmd230__bmdRegisterNewUserResponse;
			return soap_in_bmd230__bmdRegisterNewUserResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdSearchUnreceived"))
		{	*type = SOAP_TYPE_bmd230__bmdSearchUnreceived;
			return soap_in_bmd230__bmdSearchUnreceived(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdSearchUnreceivedResponse"))
		{	*type = SOAP_TYPE_bmd230__bmdSearchUnreceivedResponse;
			return soap_in_bmd230__bmdSearchUnreceivedResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdHistory"))
		{	*type = SOAP_TYPE_bmd230__bmdHistory;
			return soap_in_bmd230__bmdHistory(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdHistoryResponse"))
		{	*type = SOAP_TYPE_bmd230__bmdHistoryResponse;
			return soap_in_bmd230__bmdHistoryResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdAdvancedCountFiles"))
		{	*type = SOAP_TYPE_bmd230__bmdAdvancedCountFiles;
			return soap_in_bmd230__bmdAdvancedCountFiles(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdAdvancedCountFilesResponse"))
		{	*type = SOAP_TYPE_bmd230__bmdAdvancedCountFilesResponse;
			return soap_in_bmd230__bmdAdvancedCountFilesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdAdvancedSearchFiles"))
		{	*type = SOAP_TYPE_bmd230__bmdAdvancedSearchFiles;
			return soap_in_bmd230__bmdAdvancedSearchFiles(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdAdvancedSearchFilesResponse"))
		{	*type = SOAP_TYPE_bmd230__bmdAdvancedSearchFilesResponse;
			return soap_in_bmd230__bmdAdvancedSearchFilesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdSearchFilesCSV"))
		{	*type = SOAP_TYPE_bmd230__bmdSearchFilesCSV;
			return soap_in_bmd230__bmdSearchFilesCSV(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdSearchFilesCSVResponse"))
		{	*type = SOAP_TYPE_bmd230__bmdSearchFilesCSVResponse;
			return soap_in_bmd230__bmdSearchFilesCSVResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdSearchFiles"))
		{	*type = SOAP_TYPE_bmd230__bmdSearchFiles;
			return soap_in_bmd230__bmdSearchFiles(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdSearchFilesResponse"))
		{	*type = SOAP_TYPE_bmd230__bmdSearchFilesResponse;
			return soap_in_bmd230__bmdSearchFilesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdLogin"))
		{	*type = SOAP_TYPE_bmd230__bmdLogin;
			return soap_in_bmd230__bmdLogin(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdLoginResponse"))
		{	*type = SOAP_TYPE_bmd230__bmdLoginResponse;
			return soap_in_bmd230__bmdLoginResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdAddSignature"))
		{	*type = SOAP_TYPE_bmd230__bmdAddSignature;
			return soap_in_bmd230__bmdAddSignature(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdAddSignatureResponse"))
		{	*type = SOAP_TYPE_bmd230__bmdAddSignatureResponse;
			return soap_in_bmd230__bmdAddSignatureResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdUpdateDefaultMetadataValue"))
		{	*type = SOAP_TYPE_bmd230__bmdUpdateDefaultMetadataValue;
			return soap_in_bmd230__bmdUpdateDefaultMetadataValue(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdUpdateDefaultMetadataValueResponse"))
		{	*type = SOAP_TYPE_bmd230__bmdUpdateDefaultMetadataValueResponse;
			return soap_in_bmd230__bmdUpdateDefaultMetadataValueResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdUpdateSystemMetadata"))
		{	*type = SOAP_TYPE_bmd230__bmdUpdateSystemMetadata;
			return soap_in_bmd230__bmdUpdateSystemMetadata(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdUpdateSystemMetadataResponse"))
		{	*type = SOAP_TYPE_bmd230__bmdUpdateSystemMetadataResponse;
			return soap_in_bmd230__bmdUpdateSystemMetadataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdUpdateMetadata"))
		{	*type = SOAP_TYPE_bmd230__bmdUpdateMetadata;
			return soap_in_bmd230__bmdUpdateMetadata(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdUpdateMetadataResponse"))
		{	*type = SOAP_TYPE_bmd230__bmdUpdateMetadataResponse;
			return soap_in_bmd230__bmdUpdateMetadataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdDeleteDirByID"))
		{	*type = SOAP_TYPE_bmd230__bmdDeleteDirByID;
			return soap_in_bmd230__bmdDeleteDirByID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdDeleteDirByIDResponse"))
		{	*type = SOAP_TYPE_bmd230__bmdDeleteDirByIDResponse;
			return soap_in_bmd230__bmdDeleteDirByIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdDeleteFileByID"))
		{	*type = SOAP_TYPE_bmd230__bmdDeleteFileByID;
			return soap_in_bmd230__bmdDeleteFileByID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdDeleteFileByIDResponse"))
		{	*type = SOAP_TYPE_bmd230__bmdDeleteFileByIDResponse;
			return soap_in_bmd230__bmdDeleteFileByIDResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdUpdateFileVersion"))
		{	*type = SOAP_TYPE_bmd230__bmdUpdateFileVersion;
			return soap_in_bmd230__bmdUpdateFileVersion(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdUpdateFileVersionResponse"))
		{	*type = SOAP_TYPE_bmd230__bmdUpdateFileVersionResponse;
			return soap_in_bmd230__bmdUpdateFileVersionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdInsertFileList"))
		{	*type = SOAP_TYPE_bmd230__bmdInsertFileList;
			return soap_in_bmd230__bmdInsertFileList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdInsertFileListResponse"))
		{	*type = SOAP_TYPE_bmd230__bmdInsertFileListResponse;
			return soap_in_bmd230__bmdInsertFileListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdInsertSignedFile"))
		{	*type = SOAP_TYPE_bmd230__bmdInsertSignedFile;
			return soap_in_bmd230__bmdInsertSignedFile(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdInsertSignedFileResponse"))
		{	*type = SOAP_TYPE_bmd230__bmdInsertSignedFileResponse;
			return soap_in_bmd230__bmdInsertSignedFileResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdInsertFile"))
		{	*type = SOAP_TYPE_bmd230__bmdInsertFile;
			return soap_in_bmd230__bmdInsertFile(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdInsertFileResponse"))
		{	*type = SOAP_TYPE_bmd230__bmdInsertFileResponse;
			return soap_in_bmd230__bmdInsertFileResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:testConnection"))
		{	*type = SOAP_TYPE_bmd230__testConnection;
			return soap_in_bmd230__testConnection(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:testConnectionResponse"))
		{	*type = SOAP_TYPE_bmd230__testConnectionResponse;
			return soap_in_bmd230__testConnectionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:ActionsHistoryList"))
		{	*type = SOAP_TYPE_bmd230__ActionsHistoryList;
			return soap_in_bmd230__ActionsHistoryList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:ActionsHistoryElement"))
		{	*type = SOAP_TYPE_bmd230__ActionsHistoryElement;
			return soap_in_bmd230__ActionsHistoryElement(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:GetVersionsHistoryResultList"))
		{	*type = SOAP_TYPE_bmd230__GetVersionsHistoryResultList;
			return soap_in_bmd230__GetVersionsHistoryResultList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:GetVersionsHistoryResult"))
		{	*type = SOAP_TYPE_bmd230__GetVersionsHistoryResult;
			return soap_in_bmd230__GetVersionsHistoryResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:FileVersionInfoList"))
		{	*type = SOAP_TYPE_bmd230__FileVersionInfoList;
			return soap_in_bmd230__FileVersionInfoList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:FileVersionInfo"))
		{	*type = SOAP_TYPE_bmd230__FileVersionInfo;
			return soap_in_bmd230__FileVersionInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:accessObjectList"))
		{	*type = SOAP_TYPE_bmd230__accessObjectList;
			return soap_in_bmd230__accessObjectList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:accessObject"))
		{	*type = SOAP_TYPE_bmd230__accessObject;
			return soap_in_bmd230__accessObject(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:archPackOut"))
		{	*type = SOAP_TYPE_bmd230__archPackOut;
			return soap_in_bmd230__archPackOut(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:deleteCascadeLinksList"))
		{	*type = SOAP_TYPE_bmd230__deleteCascadeLinksList;
			return soap_in_bmd230__deleteCascadeLinksList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:deleteCascadeLinksElement"))
		{	*type = SOAP_TYPE_bmd230__deleteCascadeLinksElement;
			return soap_in_bmd230__deleteCascadeLinksElement(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:manyCascadeLinksResult"))
		{	*type = SOAP_TYPE_bmd230__manyCascadeLinksResult;
			return soap_in_bmd230__manyCascadeLinksResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:manyCascadeLinksElement"))
		{	*type = SOAP_TYPE_bmd230__manyCascadeLinksElement;
			return soap_in_bmd230__manyCascadeLinksElement(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:cascadeLinksInfo"))
		{	*type = SOAP_TYPE_bmd230__cascadeLinksInfo;
			return soap_in_bmd230__cascadeLinksInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:singleCascadeLinkInfo"))
		{	*type = SOAP_TYPE_bmd230__singleCascadeLinkInfo;
			return soap_in_bmd230__singleCascadeLinkInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:linksInfo"))
		{	*type = SOAP_TYPE_bmd230__linksInfo;
			return soap_in_bmd230__linksInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:DateTime"))
		{	*type = SOAP_TYPE_bmd230__DateTime;
			return soap_in_bmd230__DateTime(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:singleLinkInfo"))
		{	*type = SOAP_TYPE_bmd230__singleLinkInfo;
			return soap_in_bmd230__singleLinkInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:securityInfo"))
		{	*type = SOAP_TYPE_bmd230__securityInfo;
			return soap_in_bmd230__securityInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:secLevelInfo"))
		{	*type = SOAP_TYPE_bmd230__secLevelInfo;
			return soap_in_bmd230__secLevelInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:singleSecLevelInfo"))
		{	*type = SOAP_TYPE_bmd230__singleSecLevelInfo;
			return soap_in_bmd230__singleSecLevelInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:secCategoryInfo"))
		{	*type = SOAP_TYPE_bmd230__secCategoryInfo;
			return soap_in_bmd230__secCategoryInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:singleSecCategoryInfo"))
		{	*type = SOAP_TYPE_bmd230__singleSecCategoryInfo;
			return soap_in_bmd230__singleSecCategoryInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:classInfo"))
		{	*type = SOAP_TYPE_bmd230__classInfo;
			return soap_in_bmd230__classInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:singleClassInfo"))
		{	*type = SOAP_TYPE_bmd230__singleClassInfo;
			return soap_in_bmd230__singleClassInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:groupInfo"))
		{	*type = SOAP_TYPE_bmd230__groupInfo;
			return soap_in_bmd230__groupInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:singleGroupInfo"))
		{	*type = SOAP_TYPE_bmd230__singleGroupInfo;
			return soap_in_bmd230__singleGroupInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:userRoleInfo"))
		{	*type = SOAP_TYPE_bmd230__userRoleInfo;
			return soap_in_bmd230__userRoleInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:singleRoleInfo"))
		{	*type = SOAP_TYPE_bmd230__singleRoleInfo;
			return soap_in_bmd230__singleRoleInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:loginResponse"))
		{	*type = SOAP_TYPE_bmd230__loginResponse;
			return soap_in_bmd230__loginResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:userRegistrationResult"))
		{	*type = SOAP_TYPE_bmd230__userRegistrationResult;
			return soap_in_bmd230__userRegistrationResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:userListInfo"))
		{	*type = SOAP_TYPE_bmd230__userListInfo;
			return soap_in_bmd230__userListInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:singleUserInfo"))
		{	*type = SOAP_TYPE_bmd230__singleUserInfo;
			return soap_in_bmd230__singleUserInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:userNewGroupInfo"))
		{	*type = SOAP_TYPE_bmd230__userNewGroupInfo;
			return soap_in_bmd230__userNewGroupInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:stringList"))
		{	*type = SOAP_TYPE_bmd230__stringList;
			return soap_in_bmd230__stringList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:mtdsSearchValues"))
		{	*type = SOAP_TYPE_bmd230__mtdsSearchValues;
			return soap_in_bmd230__mtdsSearchValues(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:mtdSearchSingleValue"))
		{	*type = SOAP_TYPE_bmd230__mtdSearchSingleValue;
			return soap_in_bmd230__mtdSearchSingleValue(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:bmdTimestamp"))
		{	*type = SOAP_TYPE_bmd230__bmdTimestamp;
			return soap_in_bmd230__bmdTimestamp(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:historyResults"))
		{	*type = SOAP_TYPE_bmd230__historyResults;
			return soap_in_bmd230__historyResults(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:historySingleResult"))
		{	*type = SOAP_TYPE_bmd230__historySingleResult;
			return soap_in_bmd230__historySingleResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:searchResults"))
		{	*type = SOAP_TYPE_bmd230__searchResults;
			return soap_in_bmd230__searchResults(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:searchSingleResult"))
		{	*type = SOAP_TYPE_bmd230__searchSingleResult;
			return soap_in_bmd230__searchSingleResult(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:mtdsInfo"))
		{	*type = SOAP_TYPE_bmd230__mtdsInfo;
			return soap_in_bmd230__mtdsInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:mtdSingleInfo"))
		{	*type = SOAP_TYPE_bmd230__mtdSingleInfo;
			return soap_in_bmd230__mtdSingleInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:searchSortInfoList"))
		{	*type = SOAP_TYPE_bmd230__searchSortInfoList;
			return soap_in_bmd230__searchSortInfoList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:searchSortInfo"))
		{	*type = SOAP_TYPE_bmd230__searchSortInfo;
			return soap_in_bmd230__searchSortInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:idList"))
		{	*type = SOAP_TYPE_bmd230__idList;
			return soap_in_bmd230__idList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:fileComplexList"))
		{	*type = SOAP_TYPE_bmd230__fileComplexList;
			return soap_in_bmd230__fileComplexList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:fileComplex"))
		{	*type = SOAP_TYPE_bmd230__fileComplex;
			return soap_in_bmd230__fileComplex(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:mtdsValues"))
		{	*type = SOAP_TYPE_bmd230__mtdsValues;
			return soap_in_bmd230__mtdsValues(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:mtdSingleValue"))
		{	*type = SOAP_TYPE_bmd230__mtdSingleValue;
			return soap_in_bmd230__mtdSingleValue(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:fileInfoList"))
		{	*type = SOAP_TYPE_bmd230__fileInfoList;
			return soap_in_bmd230__fileInfoList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:fileInfo"))
		{	*type = SOAP_TYPE_bmd230__fileInfo;
			return soap_in_bmd230__fileInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:PkiFileInfo"))
		{	*type = SOAP_TYPE_bmd230__PkiFileInfo;
			return soap_in_bmd230__PkiFileInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:SignatureList"))
		{	*type = SOAP_TYPE_bmd230__SignatureList;
			return soap_in_bmd230__SignatureList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:DVCSList"))
		{	*type = SOAP_TYPE_bmd230__DVCSList;
			return soap_in_bmd230__DVCSList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:SignatureSingle"))
		{	*type = SOAP_TYPE_bmd230__SignatureSingle;
			return soap_in_bmd230__SignatureSingle(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:TimestampList"))
		{	*type = SOAP_TYPE_bmd230__TimestampList;
			return soap_in_bmd230__TimestampList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:DVCSSingle"))
		{	*type = SOAP_TYPE_bmd230__DVCSSingle;
			return soap_in_bmd230__DVCSSingle(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:TimestampSingle"))
		{	*type = SOAP_TYPE_bmd230__TimestampSingle;
			return soap_in_bmd230__TimestampSingle(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:LongNumbersList"))
		{	*type = SOAP_TYPE_bmd230__LongNumbersList;
			return soap_in_bmd230__LongNumbersList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "bmd230:myBinaryDataType"))
		{	*type = SOAP_TYPE_bmd230__myBinaryDataType;
			return soap_in_bmd230__myBinaryDataType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:base64Binary"))
		{	*type = SOAP_TYPE_xsd__base64Binary;
			return soap_in_xsd__base64Binary(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:RSAKeyValueType"))
		{	*type = SOAP_TYPE_ds__RSAKeyValueType;
			return soap_in_ds__RSAKeyValueType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:DSAKeyValueType"))
		{	*type = SOAP_TYPE_ds__DSAKeyValueType;
			return soap_in_ds__DSAKeyValueType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:X509IssuerSerialType"))
		{	*type = SOAP_TYPE_ds__X509IssuerSerialType;
			return soap_in_ds__X509IssuerSerialType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:X509DataType"))
		{	*type = SOAP_TYPE_ds__X509DataType;
			return soap_in_ds__X509DataType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:RetrievalMethodType"))
		{	*type = SOAP_TYPE_ds__RetrievalMethodType;
			return soap_in_ds__RetrievalMethodType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:KeyValueType"))
		{	*type = SOAP_TYPE_ds__KeyValueType;
			return soap_in_ds__KeyValueType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:DigestMethodType"))
		{	*type = SOAP_TYPE_ds__DigestMethodType;
			return soap_in_ds__DigestMethodType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:TransformType"))
		{	*type = SOAP_TYPE_ds__TransformType;
			return soap_in_ds__TransformType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:TransformsType"))
		{	*type = SOAP_TYPE_ds__TransformsType;
			return soap_in_ds__TransformsType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:ReferenceType"))
		{	*type = SOAP_TYPE_ds__ReferenceType;
			return soap_in_ds__ReferenceType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:SignatureMethodType"))
		{	*type = SOAP_TYPE_ds__SignatureMethodType;
			return soap_in_ds__SignatureMethodType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:CanonicalizationMethodType"))
		{	*type = SOAP_TYPE_ds__CanonicalizationMethodType;
			return soap_in_ds__CanonicalizationMethodType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:KeyInfoType"))
		{	*type = SOAP_TYPE_ds__KeyInfoType;
			return soap_in_ds__KeyInfoType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:SignedInfoType"))
		{	*type = SOAP_TYPE_ds__SignedInfoType;
			return soap_in_ds__SignedInfoType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ds:SignatureType"))
		{	*type = SOAP_TYPE_ds__SignatureType;
			return soap_in_ds__SignatureType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_xsd__string;
			s = soap_in_xsd__string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "wsse:Security"))
		{	*type = SOAP_TYPE__wsse__Security;
			return soap_in__wsse__Security(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "c14n:InclusiveNamespaces"))
		{	*type = SOAP_TYPE__c14n__InclusiveNamespaces;
			return soap_in__c14n__InclusiveNamespaces(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:SecurityTokenReference"))
		{	*type = SOAP_TYPE__wsse__SecurityTokenReference;
			return soap_in__wsse__SecurityTokenReference(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:KeyIdentifier"))
		{	*type = SOAP_TYPE__wsse__KeyIdentifier;
			return soap_in__wsse__KeyIdentifier(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:Embedded"))
		{	*type = SOAP_TYPE__wsse__Embedded;
			return soap_in__wsse__Embedded(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:Reference"))
		{	*type = SOAP_TYPE__wsse__Reference;
			return soap_in__wsse__Reference(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:BinarySecurityToken"))
		{	*type = SOAP_TYPE__wsse__BinarySecurityToken;
			return soap_in__wsse__BinarySecurityToken(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:Password"))
		{	*type = SOAP_TYPE__wsse__Password;
			return soap_in__wsse__Password(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsse:UsernameToken"))
		{	*type = SOAP_TYPE__wsse__UsernameToken;
			return soap_in__wsse__UsernameToken(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsu:Timestamp"))
		{	*type = SOAP_TYPE__wsu__Timestamp;
			return soap_in__wsu__Timestamp(soap, NULL, NULL, NULL);
		}
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_xsd__int:
		return soap_out_xsd__int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_long:
		return soap_out_long(soap, tag, id, (const long *)ptr, "xsd:long");
	case SOAP_TYPE_unsignedByte:
		return soap_out_unsignedByte(soap, tag, id, (const unsigned char *)ptr, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedInt:
		return soap_out_unsignedInt(soap, tag, id, (const unsigned int *)ptr, "xsd:unsignedInt");
	case SOAP_TYPE_groupAuthorizationType_e:
		return soap_out_groupAuthorizationType_e(soap, tag, id, (const enum groupAuthorizationType_e *)ptr, "groupAuthorizationType-e");
	case SOAP_TYPE_chunkCntr_t:
		return soap_out_chunkCntr_t(soap, tag, id, (const enum chunkCntr_t *)ptr, "chunkCntr-t");
	case SOAP_TYPE_trans_t:
		return soap_out_trans_t(soap, tag, id, (const enum trans_t *)ptr, "trans-t");
	case SOAP_TYPE_visibilityType_t:
		return soap_out_visibilityType_t(soap, tag, id, (const enum visibilityType_t *)ptr, "visibilityType-t");
	case SOAP_TYPE_grantingType_e:
		return soap_out_grantingType_e(soap, tag, id, (const enum grantingType_e *)ptr, "grantingType-e");
	case SOAP_TYPE_wsse__FaultcodeEnum:
		return soap_out_wsse__FaultcodeEnum(soap, tag, id, (const enum wsse__FaultcodeEnum *)ptr, "wsse:FaultcodeEnum");
	case SOAP_TYPE_wsu__tTimestampFault:
		return soap_out_wsu__tTimestampFault(soap, tag, id, (const enum wsu__tTimestampFault *)ptr, "wsu:tTimestampFault");
	case SOAP_TYPE_bmd230__bmdDeleteReplacedLobs:
		return soap_out_bmd230__bmdDeleteReplacedLobs(soap, tag, id, (const struct bmd230__bmdDeleteReplacedLobs *)ptr, "bmd230:bmdDeleteReplacedLobs");
	case SOAP_TYPE_bmd230__bmdDeleteReplacedLobsResponse:
		return soap_out_bmd230__bmdDeleteReplacedLobsResponse(soap, tag, id, (const struct bmd230__bmdDeleteReplacedLobsResponse *)ptr, "bmd230:bmdDeleteReplacedLobsResponse");
	case SOAP_TYPE_bmd230__bmdConservateTimestamps:
		return soap_out_bmd230__bmdConservateTimestamps(soap, tag, id, (const struct bmd230__bmdConservateTimestamps *)ptr, "bmd230:bmdConservateTimestamps");
	case SOAP_TYPE_bmd230__bmdConservateTimestampsResponse:
		return soap_out_bmd230__bmdConservateTimestampsResponse(soap, tag, id, (const struct bmd230__bmdConservateTimestampsResponse *)ptr, "bmd230:bmdConservateTimestampsResponse");
	case SOAP_TYPE_bmd230__bmdDeleteCascadeLinks:
		return soap_out_bmd230__bmdDeleteCascadeLinks(soap, tag, id, (const struct bmd230__bmdDeleteCascadeLinks *)ptr, "bmd230:bmdDeleteCascadeLinks");
	case SOAP_TYPE_bmd230__bmdDeleteCascadeLinksResponse:
		return soap_out_bmd230__bmdDeleteCascadeLinksResponse(soap, tag, id, (const struct bmd230__bmdDeleteCascadeLinksResponse *)ptr, "bmd230:bmdDeleteCascadeLinksResponse");
	case SOAP_TYPE_bmd230__bmdCreateManyCascadeLinks:
		return soap_out_bmd230__bmdCreateManyCascadeLinks(soap, tag, id, (const struct bmd230__bmdCreateManyCascadeLinks *)ptr, "bmd230:bmdCreateManyCascadeLinks");
	case SOAP_TYPE_bmd230__bmdCreateManyCascadeLinksResponse:
		return soap_out_bmd230__bmdCreateManyCascadeLinksResponse(soap, tag, id, (const struct bmd230__bmdCreateManyCascadeLinksResponse *)ptr, "bmd230:bmdCreateManyCascadeLinksResponse");
	case SOAP_TYPE_bmd230__bmdCreateCascadeLinks:
		return soap_out_bmd230__bmdCreateCascadeLinks(soap, tag, id, (const struct bmd230__bmdCreateCascadeLinks *)ptr, "bmd230:bmdCreateCascadeLinks");
	case SOAP_TYPE_bmd230__bmdCreateCascadeLinksResponse:
		return soap_out_bmd230__bmdCreateCascadeLinksResponse(soap, tag, id, (const struct bmd230__bmdCreateCascadeLinksResponse *)ptr, "bmd230:bmdCreateCascadeLinksResponse");
	case SOAP_TYPE_bmd230__bmdCreateLinks:
		return soap_out_bmd230__bmdCreateLinks(soap, tag, id, (const struct bmd230__bmdCreateLinks *)ptr, "bmd230:bmdCreateLinks");
	case SOAP_TYPE_bmd230__bmdCreateLinksResponse:
		return soap_out_bmd230__bmdCreateLinksResponse(soap, tag, id, (const struct bmd230__bmdCreateLinksResponse *)ptr, "bmd230:bmdCreateLinksResponse");
	case SOAP_TYPE_bmd230__bmdCreateLink:
		return soap_out_bmd230__bmdCreateLink(soap, tag, id, (const struct bmd230__bmdCreateLink *)ptr, "bmd230:bmdCreateLink");
	case SOAP_TYPE_bmd230__bmdCreateLinkResponse:
		return soap_out_bmd230__bmdCreateLinkResponse(soap, tag, id, (const struct bmd230__bmdCreateLinkResponse *)ptr, "bmd230:bmdCreateLinkResponse");
	case SOAP_TYPE_bmd230__bmdGetDirectoryDetails:
		return soap_out_bmd230__bmdGetDirectoryDetails(soap, tag, id, (const struct bmd230__bmdGetDirectoryDetails *)ptr, "bmd230:bmdGetDirectoryDetails");
	case SOAP_TYPE_bmd230__bmdGetDirectoryDetailsResponse:
		return soap_out_bmd230__bmdGetDirectoryDetailsResponse(soap, tag, id, (const struct bmd230__bmdGetDirectoryDetailsResponse *)ptr, "bmd230:bmdGetDirectoryDetailsResponse");
	case SOAP_TYPE_bmd230__bmdCreateDirectory:
		return soap_out_bmd230__bmdCreateDirectory(soap, tag, id, (const struct bmd230__bmdCreateDirectory *)ptr, "bmd230:bmdCreateDirectory");
	case SOAP_TYPE_bmd230__bmdCreateDirectoryResponse:
		return soap_out_bmd230__bmdCreateDirectoryResponse(soap, tag, id, (const struct bmd230__bmdCreateDirectoryResponse *)ptr, "bmd230:bmdCreateDirectoryResponse");
	case SOAP_TYPE_bmd230__bmdStopTransaction:
		return soap_out_bmd230__bmdStopTransaction(soap, tag, id, (const struct bmd230__bmdStopTransaction *)ptr, "bmd230:bmdStopTransaction");
	case SOAP_TYPE_bmd230__bmdStopTransactionResponse:
		return soap_out_bmd230__bmdStopTransactionResponse(soap, tag, id, (const struct bmd230__bmdStopTransactionResponse *)ptr, "bmd230:bmdStopTransactionResponse");
	case SOAP_TYPE_bmd230__bmdStartTransaction:
		return soap_out_bmd230__bmdStartTransaction(soap, tag, id, (const struct bmd230__bmdStartTransaction *)ptr, "bmd230:bmdStartTransaction");
	case SOAP_TYPE_bmd230__bmdStartTransactionResponse:
		return soap_out_bmd230__bmdStartTransactionResponse(soap, tag, id, (const struct bmd230__bmdStartTransactionResponse *)ptr, "bmd230:bmdStartTransactionResponse");
	case SOAP_TYPE_bmd230__bmdGetArchPackInChunk:
		return soap_out_bmd230__bmdGetArchPackInChunk(soap, tag, id, (const struct bmd230__bmdGetArchPackInChunk *)ptr, "bmd230:bmdGetArchPackInChunk");
	case SOAP_TYPE_bmd230__bmdGetArchPackInChunkResponse:
		return soap_out_bmd230__bmdGetArchPackInChunkResponse(soap, tag, id, (const struct bmd230__bmdGetArchPackInChunkResponse *)ptr, "bmd230:bmdGetArchPackInChunkResponse");
	case SOAP_TYPE_bmd230__bmdGetFileChunkIter:
		return soap_out_bmd230__bmdGetFileChunkIter(soap, tag, id, (const struct bmd230__bmdGetFileChunkIter *)ptr, "bmd230:bmdGetFileChunkIter");
	case SOAP_TYPE_bmd230__bmdGetFileChunkIterResponse:
		return soap_out_bmd230__bmdGetFileChunkIterResponse(soap, tag, id, (const struct bmd230__bmdGetFileChunkIterResponse *)ptr, "bmd230:bmdGetFileChunkIterResponse");
	case SOAP_TYPE_bmd230__bmdGetFileChunkStart:
		return soap_out_bmd230__bmdGetFileChunkStart(soap, tag, id, (const struct bmd230__bmdGetFileChunkStart *)ptr, "bmd230:bmdGetFileChunkStart");
	case SOAP_TYPE_bmd230__bmdGetFileChunkStartResponse:
		return soap_out_bmd230__bmdGetFileChunkStartResponse(soap, tag, id, (const struct bmd230__bmdGetFileChunkStartResponse *)ptr, "bmd230:bmdGetFileChunkStartResponse");
	case SOAP_TYPE_bmd230__bmdInsertFileChunkIter:
		return soap_out_bmd230__bmdInsertFileChunkIter(soap, tag, id, (const struct bmd230__bmdInsertFileChunkIter *)ptr, "bmd230:bmdInsertFileChunkIter");
	case SOAP_TYPE_bmd230__bmdInsertFileChunkIterResponse:
		return soap_out_bmd230__bmdInsertFileChunkIterResponse(soap, tag, id, (const struct bmd230__bmdInsertFileChunkIterResponse *)ptr, "bmd230:bmdInsertFileChunkIterResponse");
	case SOAP_TYPE_bmd230__bmdInsertFileChunkStart:
		return soap_out_bmd230__bmdInsertFileChunkStart(soap, tag, id, (const struct bmd230__bmdInsertFileChunkStart *)ptr, "bmd230:bmdInsertFileChunkStart");
	case SOAP_TYPE_bmd230__bmdInsertFileChunkStartResponse:
		return soap_out_bmd230__bmdInsertFileChunkStartResponse(soap, tag, id, (const struct bmd230__bmdInsertFileChunkStartResponse *)ptr, "bmd230:bmdInsertFileChunkStartResponse");
	case SOAP_TYPE_bmd230__getFile:
		return soap_out_bmd230__getFile(soap, tag, id, (const struct bmd230__getFile *)ptr, "bmd230:getFile");
	case SOAP_TYPE_bmd230__getFileResponse:
		return soap_out_bmd230__getFileResponse(soap, tag, id, (const struct bmd230__getFileResponse *)ptr, "bmd230:getFileResponse");
	case SOAP_TYPE_bmd230__countInvoice:
		return soap_out_bmd230__countInvoice(soap, tag, id, (const struct bmd230__countInvoice *)ptr, "bmd230:countInvoice");
	case SOAP_TYPE_bmd230__countInvoiceResponse:
		return soap_out_bmd230__countInvoiceResponse(soap, tag, id, (const struct bmd230__countInvoiceResponse *)ptr, "bmd230:countInvoiceResponse");
	case SOAP_TYPE_bmd230__verifyInvoiceWithDetails:
		return soap_out_bmd230__verifyInvoiceWithDetails(soap, tag, id, (const struct bmd230__verifyInvoiceWithDetails *)ptr, "bmd230:verifyInvoiceWithDetails");
	case SOAP_TYPE_bmd230__verifyInvoiceWithDetailsResponse:
		return soap_out_bmd230__verifyInvoiceWithDetailsResponse(soap, tag, id, (const struct bmd230__verifyInvoiceWithDetailsResponse *)ptr, "bmd230:verifyInvoiceWithDetailsResponse");
	case SOAP_TYPE_bmd230__verifyInvoiceSimplified:
		return soap_out_bmd230__verifyInvoiceSimplified(soap, tag, id, (const struct bmd230__verifyInvoiceSimplified *)ptr, "bmd230:verifyInvoiceSimplified");
	case SOAP_TYPE_bmd230__verifyInvoiceSimplifiedResponse:
		return soap_out_bmd230__verifyInvoiceSimplifiedResponse(soap, tag, id, (const struct bmd230__verifyInvoiceSimplifiedResponse *)ptr, "bmd230:verifyInvoiceSimplifiedResponse");
	case SOAP_TYPE_bmd230__verifyInvoice:
		return soap_out_bmd230__verifyInvoice(soap, tag, id, (const struct bmd230__verifyInvoice *)ptr, "bmd230:verifyInvoice");
	case SOAP_TYPE_bmd230__verifyInvoiceResponse:
		return soap_out_bmd230__verifyInvoiceResponse(soap, tag, id, (const struct bmd230__verifyInvoiceResponse *)ptr, "bmd230:verifyInvoiceResponse");
	case SOAP_TYPE_bmd230__getHTMLImage:
		return soap_out_bmd230__getHTMLImage(soap, tag, id, (const struct bmd230__getHTMLImage *)ptr, "bmd230:getHTMLImage");
	case SOAP_TYPE_bmd230__getHTMLImageResponse:
		return soap_out_bmd230__getHTMLImageResponse(soap, tag, id, (const struct bmd230__getHTMLImageResponse *)ptr, "bmd230:getHTMLImageResponse");
	case SOAP_TYPE_bmd230__getInvoicePack:
		return soap_out_bmd230__getInvoicePack(soap, tag, id, (const struct bmd230__getInvoicePack *)ptr, "bmd230:getInvoicePack");
	case SOAP_TYPE_bmd230__getInvoicePackResponse:
		return soap_out_bmd230__getInvoicePackResponse(soap, tag, id, (const struct bmd230__getInvoicePackResponse *)ptr, "bmd230:getInvoicePackResponse");
	case SOAP_TYPE_bmd230__SendAdviceWithParameters:
		return soap_out_bmd230__SendAdviceWithParameters(soap, tag, id, (const struct bmd230__SendAdviceWithParameters *)ptr, "bmd230:SendAdviceWithParameters");
	case SOAP_TYPE_bmd230__SendAdviceWithParametersResponse:
		return soap_out_bmd230__SendAdviceWithParametersResponse(soap, tag, id, (const struct bmd230__SendAdviceWithParametersResponse *)ptr, "bmd230:SendAdviceWithParametersResponse");
	case SOAP_TYPE_bmd230__SendAdvice:
		return soap_out_bmd230__SendAdvice(soap, tag, id, (const struct bmd230__SendAdvice *)ptr, "bmd230:SendAdvice");
	case SOAP_TYPE_bmd230__SendAdviceResponse:
		return soap_out_bmd230__SendAdviceResponse(soap, tag, id, (const struct bmd230__SendAdviceResponse *)ptr, "bmd230:SendAdviceResponse");
	case SOAP_TYPE_bmd230__verifyInvoiceWithDetailsById:
		return soap_out_bmd230__verifyInvoiceWithDetailsById(soap, tag, id, (const struct bmd230__verifyInvoiceWithDetailsById *)ptr, "bmd230:verifyInvoiceWithDetailsById");
	case SOAP_TYPE_bmd230__verifyInvoiceWithDetailsByIdResponse:
		return soap_out_bmd230__verifyInvoiceWithDetailsByIdResponse(soap, tag, id, (const struct bmd230__verifyInvoiceWithDetailsByIdResponse *)ptr, "bmd230:verifyInvoiceWithDetailsByIdResponse");
	case SOAP_TYPE_bmd230__verifyInvoiceById:
		return soap_out_bmd230__verifyInvoiceById(soap, tag, id, (const struct bmd230__verifyInvoiceById *)ptr, "bmd230:verifyInvoiceById");
	case SOAP_TYPE_bmd230__verifyInvoiceByIdResponse:
		return soap_out_bmd230__verifyInvoiceByIdResponse(soap, tag, id, (const struct bmd230__verifyInvoiceByIdResponse *)ptr, "bmd230:verifyInvoiceByIdResponse");
	case SOAP_TYPE_bmd230__getHTMLImageById:
		return soap_out_bmd230__getHTMLImageById(soap, tag, id, (const struct bmd230__getHTMLImageById *)ptr, "bmd230:getHTMLImageById");
	case SOAP_TYPE_bmd230__getHTMLImageByIdResponse:
		return soap_out_bmd230__getHTMLImageByIdResponse(soap, tag, id, (const struct bmd230__getHTMLImageByIdResponse *)ptr, "bmd230:getHTMLImageByIdResponse");
	case SOAP_TYPE_bmd230__getInvoicePackById:
		return soap_out_bmd230__getInvoicePackById(soap, tag, id, (const struct bmd230__getInvoicePackById *)ptr, "bmd230:getInvoicePackById");
	case SOAP_TYPE_bmd230__getInvoicePackByIdResponse:
		return soap_out_bmd230__getInvoicePackByIdResponse(soap, tag, id, (const struct bmd230__getInvoicePackByIdResponse *)ptr, "bmd230:getInvoicePackByIdResponse");
	case SOAP_TYPE_bmd230__bmdGetActionsHistoryById:
		return soap_out_bmd230__bmdGetActionsHistoryById(soap, tag, id, (const struct bmd230__bmdGetActionsHistoryById *)ptr, "bmd230:bmdGetActionsHistoryById");
	case SOAP_TYPE_bmd230__bmdGetActionsHistoryByIdResponse:
		return soap_out_bmd230__bmdGetActionsHistoryByIdResponse(soap, tag, id, (const struct bmd230__bmdGetActionsHistoryByIdResponse *)ptr, "bmd230:bmdGetActionsHistoryByIdResponse");
	case SOAP_TYPE_bmd230__bmdGetVersionsHistory:
		return soap_out_bmd230__bmdGetVersionsHistory(soap, tag, id, (const struct bmd230__bmdGetVersionsHistory *)ptr, "bmd230:bmdGetVersionsHistory");
	case SOAP_TYPE_bmd230__bmdGetVersionsHistoryResponse:
		return soap_out_bmd230__bmdGetVersionsHistoryResponse(soap, tag, id, (const struct bmd230__bmdGetVersionsHistoryResponse *)ptr, "bmd230:bmdGetVersionsHistoryResponse");
	case SOAP_TYPE_bmd230__bmdGetAccessObjects:
		return soap_out_bmd230__bmdGetAccessObjects(soap, tag, id, (const struct bmd230__bmdGetAccessObjects *)ptr, "bmd230:bmdGetAccessObjects");
	case SOAP_TYPE_bmd230__bmdGetAccessObjectsResponse:
		return soap_out_bmd230__bmdGetAccessObjectsResponse(soap, tag, id, (const struct bmd230__bmdGetAccessObjectsResponse *)ptr, "bmd230:bmdGetAccessObjectsResponse");
	case SOAP_TYPE_bmd230__bmdGetArchPack:
		return soap_out_bmd230__bmdGetArchPack(soap, tag, id, (const struct bmd230__bmdGetArchPack *)ptr, "bmd230:bmdGetArchPack");
	case SOAP_TYPE_bmd230__bmdGetArchPackResponse:
		return soap_out_bmd230__bmdGetArchPackResponse(soap, tag, id, (const struct bmd230__bmdGetArchPackResponse *)ptr, "bmd230:bmdGetArchPackResponse");
	case SOAP_TYPE_bmd230__bmdGetTimeStamp:
		return soap_out_bmd230__bmdGetTimeStamp(soap, tag, id, (const struct bmd230__bmdGetTimeStamp *)ptr, "bmd230:bmdGetTimeStamp");
	case SOAP_TYPE_bmd230__bmdGetTimeStampResponse:
		return soap_out_bmd230__bmdGetTimeStampResponse(soap, tag, id, (const struct bmd230__bmdGetTimeStampResponse *)ptr, "bmd230:bmdGetTimeStampResponse");
	case SOAP_TYPE_bmd230__bmdGetFilePKIById:
		return soap_out_bmd230__bmdGetFilePKIById(soap, tag, id, (const struct bmd230__bmdGetFilePKIById *)ptr, "bmd230:bmdGetFilePKIById");
	case SOAP_TYPE_bmd230__bmdGetFilePKIByIdResponse:
		return soap_out_bmd230__bmdGetFilePKIByIdResponse(soap, tag, id, (const struct bmd230__bmdGetFilePKIByIdResponse *)ptr, "bmd230:bmdGetFilePKIByIdResponse");
	case SOAP_TYPE_bmd230__bmdGetFilePropByID:
		return soap_out_bmd230__bmdGetFilePropByID(soap, tag, id, (const struct bmd230__bmdGetFilePropByID *)ptr, "bmd230:bmdGetFilePropByID");
	case SOAP_TYPE_bmd230__bmdGetFilePropByIDResponse:
		return soap_out_bmd230__bmdGetFilePropByIDResponse(soap, tag, id, (const struct bmd230__bmdGetFilePropByIDResponse *)ptr, "bmd230:bmdGetFilePropByIDResponse");
	case SOAP_TYPE_bmd230__bmdGetFileByIdInZipPack:
		return soap_out_bmd230__bmdGetFileByIdInZipPack(soap, tag, id, (const struct bmd230__bmdGetFileByIdInZipPack *)ptr, "bmd230:bmdGetFileByIdInZipPack");
	case SOAP_TYPE_bmd230__bmdGetFileByIdInZipPackResponse:
		return soap_out_bmd230__bmdGetFileByIdInZipPackResponse(soap, tag, id, (const struct bmd230__bmdGetFileByIdInZipPackResponse *)ptr, "bmd230:bmdGetFileByIdInZipPackResponse");
	case SOAP_TYPE_bmd230__bmdGetFileByHash:
		return soap_out_bmd230__bmdGetFileByHash(soap, tag, id, (const struct bmd230__bmdGetFileByHash *)ptr, "bmd230:bmdGetFileByHash");
	case SOAP_TYPE_bmd230__bmdGetFileByHashResponse:
		return soap_out_bmd230__bmdGetFileByHashResponse(soap, tag, id, (const struct bmd230__bmdGetFileByHashResponse *)ptr, "bmd230:bmdGetFileByHashResponse");
	case SOAP_TYPE_bmd230__bmdGetArchiveFileVersion:
		return soap_out_bmd230__bmdGetArchiveFileVersion(soap, tag, id, (const struct bmd230__bmdGetArchiveFileVersion *)ptr, "bmd230:bmdGetArchiveFileVersion");
	case SOAP_TYPE_bmd230__bmdGetArchiveFileVersionResponse:
		return soap_out_bmd230__bmdGetArchiveFileVersionResponse(soap, tag, id, (const struct bmd230__bmdGetArchiveFileVersionResponse *)ptr, "bmd230:bmdGetArchiveFileVersionResponse");
	case SOAP_TYPE_bmd230__bmdGetFileById:
		return soap_out_bmd230__bmdGetFileById(soap, tag, id, (const struct bmd230__bmdGetFileById *)ptr, "bmd230:bmdGetFileById");
	case SOAP_TYPE_bmd230__bmdGetFileByIdResponse:
		return soap_out_bmd230__bmdGetFileByIdResponse(soap, tag, id, (const struct bmd230__bmdGetFileByIdResponse *)ptr, "bmd230:bmdGetFileByIdResponse");
	case SOAP_TYPE_bmd230__bmdGetSecurityList:
		return soap_out_bmd230__bmdGetSecurityList(soap, tag, id, (const struct bmd230__bmdGetSecurityList *)ptr, "bmd230:bmdGetSecurityList");
	case SOAP_TYPE_bmd230__bmdGetSecurityListResponse:
		return soap_out_bmd230__bmdGetSecurityListResponse(soap, tag, id, (const struct bmd230__bmdGetSecurityListResponse *)ptr, "bmd230:bmdGetSecurityListResponse");
	case SOAP_TYPE_bmd230__bmdRegisterNewSecurityCategory:
		return soap_out_bmd230__bmdRegisterNewSecurityCategory(soap, tag, id, (const struct bmd230__bmdRegisterNewSecurityCategory *)ptr, "bmd230:bmdRegisterNewSecurityCategory");
	case SOAP_TYPE_bmd230__bmdRegisterNewSecurityCategoryResponse:
		return soap_out_bmd230__bmdRegisterNewSecurityCategoryResponse(soap, tag, id, (const struct bmd230__bmdRegisterNewSecurityCategoryResponse *)ptr, "bmd230:bmdRegisterNewSecurityCategoryResponse");
	case SOAP_TYPE_bmd230__bmdDeleteClass:
		return soap_out_bmd230__bmdDeleteClass(soap, tag, id, (const struct bmd230__bmdDeleteClass *)ptr, "bmd230:bmdDeleteClass");
	case SOAP_TYPE_bmd230__bmdDeleteClassResponse:
		return soap_out_bmd230__bmdDeleteClassResponse(soap, tag, id, (const struct bmd230__bmdDeleteClassResponse *)ptr, "bmd230:bmdDeleteClassResponse");
	case SOAP_TYPE_bmd230__bmdGetClassList:
		return soap_out_bmd230__bmdGetClassList(soap, tag, id, (const struct bmd230__bmdGetClassList *)ptr, "bmd230:bmdGetClassList");
	case SOAP_TYPE_bmd230__bmdGetClassListResponse:
		return soap_out_bmd230__bmdGetClassListResponse(soap, tag, id, (const struct bmd230__bmdGetClassListResponse *)ptr, "bmd230:bmdGetClassListResponse");
	case SOAP_TYPE_bmd230__bmdUpdateClass:
		return soap_out_bmd230__bmdUpdateClass(soap, tag, id, (const struct bmd230__bmdUpdateClass *)ptr, "bmd230:bmdUpdateClass");
	case SOAP_TYPE_bmd230__bmdUpdateClassResponse:
		return soap_out_bmd230__bmdUpdateClassResponse(soap, tag, id, (const struct bmd230__bmdUpdateClassResponse *)ptr, "bmd230:bmdUpdateClassResponse");
	case SOAP_TYPE_bmd230__bmdRegisterNewClass:
		return soap_out_bmd230__bmdRegisterNewClass(soap, tag, id, (const struct bmd230__bmdRegisterNewClass *)ptr, "bmd230:bmdRegisterNewClass");
	case SOAP_TYPE_bmd230__bmdRegisterNewClassResponse:
		return soap_out_bmd230__bmdRegisterNewClassResponse(soap, tag, id, (const struct bmd230__bmdRegisterNewClassResponse *)ptr, "bmd230:bmdRegisterNewClassResponse");
	case SOAP_TYPE_bmd230__bmdDeleteGroup:
		return soap_out_bmd230__bmdDeleteGroup(soap, tag, id, (const struct bmd230__bmdDeleteGroup *)ptr, "bmd230:bmdDeleteGroup");
	case SOAP_TYPE_bmd230__bmdDeleteGroupResponse:
		return soap_out_bmd230__bmdDeleteGroupResponse(soap, tag, id, (const struct bmd230__bmdDeleteGroupResponse *)ptr, "bmd230:bmdDeleteGroupResponse");
	case SOAP_TYPE_bmd230__bmdGetGroupsList:
		return soap_out_bmd230__bmdGetGroupsList(soap, tag, id, (const struct bmd230__bmdGetGroupsList *)ptr, "bmd230:bmdGetGroupsList");
	case SOAP_TYPE_bmd230__bmdGetGroupsListResponse:
		return soap_out_bmd230__bmdGetGroupsListResponse(soap, tag, id, (const struct bmd230__bmdGetGroupsListResponse *)ptr, "bmd230:bmdGetGroupsListResponse");
	case SOAP_TYPE_bmd230__bmdUpdateGroup:
		return soap_out_bmd230__bmdUpdateGroup(soap, tag, id, (const struct bmd230__bmdUpdateGroup *)ptr, "bmd230:bmdUpdateGroup");
	case SOAP_TYPE_bmd230__bmdUpdateGroupResponse:
		return soap_out_bmd230__bmdUpdateGroupResponse(soap, tag, id, (const struct bmd230__bmdUpdateGroupResponse *)ptr, "bmd230:bmdUpdateGroupResponse");
	case SOAP_TYPE_bmd230__bmdRegisterNewGroup:
		return soap_out_bmd230__bmdRegisterNewGroup(soap, tag, id, (const struct bmd230__bmdRegisterNewGroup *)ptr, "bmd230:bmdRegisterNewGroup");
	case SOAP_TYPE_bmd230__bmdRegisterNewGroupResponse:
		return soap_out_bmd230__bmdRegisterNewGroupResponse(soap, tag, id, (const struct bmd230__bmdRegisterNewGroupResponse *)ptr, "bmd230:bmdRegisterNewGroupResponse");
	case SOAP_TYPE_bmd230__bmdDeleteRole:
		return soap_out_bmd230__bmdDeleteRole(soap, tag, id, (const struct bmd230__bmdDeleteRole *)ptr, "bmd230:bmdDeleteRole");
	case SOAP_TYPE_bmd230__bmdDeleteRoleResponse:
		return soap_out_bmd230__bmdDeleteRoleResponse(soap, tag, id, (const struct bmd230__bmdDeleteRoleResponse *)ptr, "bmd230:bmdDeleteRoleResponse");
	case SOAP_TYPE_bmd230__bmdGetRolesList:
		return soap_out_bmd230__bmdGetRolesList(soap, tag, id, (const struct bmd230__bmdGetRolesList *)ptr, "bmd230:bmdGetRolesList");
	case SOAP_TYPE_bmd230__bmdGetRolesListResponse:
		return soap_out_bmd230__bmdGetRolesListResponse(soap, tag, id, (const struct bmd230__bmdGetRolesListResponse *)ptr, "bmd230:bmdGetRolesListResponse");
	case SOAP_TYPE_bmd230__bmdUpdateRole:
		return soap_out_bmd230__bmdUpdateRole(soap, tag, id, (const struct bmd230__bmdUpdateRole *)ptr, "bmd230:bmdUpdateRole");
	case SOAP_TYPE_bmd230__bmdUpdateRoleResponse:
		return soap_out_bmd230__bmdUpdateRoleResponse(soap, tag, id, (const struct bmd230__bmdUpdateRoleResponse *)ptr, "bmd230:bmdUpdateRoleResponse");
	case SOAP_TYPE_bmd230__bmdRegisterNewRole:
		return soap_out_bmd230__bmdRegisterNewRole(soap, tag, id, (const struct bmd230__bmdRegisterNewRole *)ptr, "bmd230:bmdRegisterNewRole");
	case SOAP_TYPE_bmd230__bmdRegisterNewRoleResponse:
		return soap_out_bmd230__bmdRegisterNewRoleResponse(soap, tag, id, (const struct bmd230__bmdRegisterNewRoleResponse *)ptr, "bmd230:bmdRegisterNewRoleResponse");
	case SOAP_TYPE_bmd230__bmdDisableIdentity:
		return soap_out_bmd230__bmdDisableIdentity(soap, tag, id, (const struct bmd230__bmdDisableIdentity *)ptr, "bmd230:bmdDisableIdentity");
	case SOAP_TYPE_bmd230__bmdDisableIdentityResponse:
		return soap_out_bmd230__bmdDisableIdentityResponse(soap, tag, id, (const struct bmd230__bmdDisableIdentityResponse *)ptr, "bmd230:bmdDisableIdentityResponse");
	case SOAP_TYPE_bmd230__bmdDisableUser:
		return soap_out_bmd230__bmdDisableUser(soap, tag, id, (const struct bmd230__bmdDisableUser *)ptr, "bmd230:bmdDisableUser");
	case SOAP_TYPE_bmd230__bmdDisableUserResponse:
		return soap_out_bmd230__bmdDisableUserResponse(soap, tag, id, (const struct bmd230__bmdDisableUserResponse *)ptr, "bmd230:bmdDisableUserResponse");
	case SOAP_TYPE_bmd230__bmdDeleteUser:
		return soap_out_bmd230__bmdDeleteUser(soap, tag, id, (const struct bmd230__bmdDeleteUser *)ptr, "bmd230:bmdDeleteUser");
	case SOAP_TYPE_bmd230__bmdDeleteUserResponse:
		return soap_out_bmd230__bmdDeleteUserResponse(soap, tag, id, (const struct bmd230__bmdDeleteUserResponse *)ptr, "bmd230:bmdDeleteUserResponse");
	case SOAP_TYPE_bmd230__bmdGetUsersList:
		return soap_out_bmd230__bmdGetUsersList(soap, tag, id, (const struct bmd230__bmdGetUsersList *)ptr, "bmd230:bmdGetUsersList");
	case SOAP_TYPE_bmd230__bmdGetUsersListResponse:
		return soap_out_bmd230__bmdGetUsersListResponse(soap, tag, id, (const struct bmd230__bmdGetUsersListResponse *)ptr, "bmd230:bmdGetUsersListResponse");
	case SOAP_TYPE_bmd230__bmdUpdateUserRights:
		return soap_out_bmd230__bmdUpdateUserRights(soap, tag, id, (const struct bmd230__bmdUpdateUserRights *)ptr, "bmd230:bmdUpdateUserRights");
	case SOAP_TYPE_bmd230__bmdUpdateUserRightsResponse:
		return soap_out_bmd230__bmdUpdateUserRightsResponse(soap, tag, id, (const struct bmd230__bmdUpdateUserRightsResponse *)ptr, "bmd230:bmdUpdateUserRightsResponse");
	case SOAP_TYPE_bmd230__bmdAddCertificateToIdentity:
		return soap_out_bmd230__bmdAddCertificateToIdentity(soap, tag, id, (const struct bmd230__bmdAddCertificateToIdentity *)ptr, "bmd230:bmdAddCertificateToIdentity");
	case SOAP_TYPE_bmd230__bmdAddCertificateToIdentityResponse:
		return soap_out_bmd230__bmdAddCertificateToIdentityResponse(soap, tag, id, (const struct bmd230__bmdAddCertificateToIdentityResponse *)ptr, "bmd230:bmdAddCertificateToIdentityResponse");
	case SOAP_TYPE_bmd230__bmdRegisterNewUser:
		return soap_out_bmd230__bmdRegisterNewUser(soap, tag, id, (const struct bmd230__bmdRegisterNewUser *)ptr, "bmd230:bmdRegisterNewUser");
	case SOAP_TYPE_bmd230__bmdRegisterNewUserResponse:
		return soap_out_bmd230__bmdRegisterNewUserResponse(soap, tag, id, (const struct bmd230__bmdRegisterNewUserResponse *)ptr, "bmd230:bmdRegisterNewUserResponse");
	case SOAP_TYPE_bmd230__bmdSearchUnreceived:
		return soap_out_bmd230__bmdSearchUnreceived(soap, tag, id, (const struct bmd230__bmdSearchUnreceived *)ptr, "bmd230:bmdSearchUnreceived");
	case SOAP_TYPE_bmd230__bmdSearchUnreceivedResponse:
		return soap_out_bmd230__bmdSearchUnreceivedResponse(soap, tag, id, (const struct bmd230__bmdSearchUnreceivedResponse *)ptr, "bmd230:bmdSearchUnreceivedResponse");
	case SOAP_TYPE_bmd230__bmdHistory:
		return soap_out_bmd230__bmdHistory(soap, tag, id, (const struct bmd230__bmdHistory *)ptr, "bmd230:bmdHistory");
	case SOAP_TYPE_bmd230__bmdHistoryResponse:
		return soap_out_bmd230__bmdHistoryResponse(soap, tag, id, (const struct bmd230__bmdHistoryResponse *)ptr, "bmd230:bmdHistoryResponse");
	case SOAP_TYPE_bmd230__bmdAdvancedCountFiles:
		return soap_out_bmd230__bmdAdvancedCountFiles(soap, tag, id, (const struct bmd230__bmdAdvancedCountFiles *)ptr, "bmd230:bmdAdvancedCountFiles");
	case SOAP_TYPE_bmd230__bmdAdvancedCountFilesResponse:
		return soap_out_bmd230__bmdAdvancedCountFilesResponse(soap, tag, id, (const struct bmd230__bmdAdvancedCountFilesResponse *)ptr, "bmd230:bmdAdvancedCountFilesResponse");
	case SOAP_TYPE_bmd230__bmdAdvancedSearchFiles:
		return soap_out_bmd230__bmdAdvancedSearchFiles(soap, tag, id, (const struct bmd230__bmdAdvancedSearchFiles *)ptr, "bmd230:bmdAdvancedSearchFiles");
	case SOAP_TYPE_bmd230__bmdAdvancedSearchFilesResponse:
		return soap_out_bmd230__bmdAdvancedSearchFilesResponse(soap, tag, id, (const struct bmd230__bmdAdvancedSearchFilesResponse *)ptr, "bmd230:bmdAdvancedSearchFilesResponse");
	case SOAP_TYPE_bmd230__bmdSearchFilesCSV:
		return soap_out_bmd230__bmdSearchFilesCSV(soap, tag, id, (const struct bmd230__bmdSearchFilesCSV *)ptr, "bmd230:bmdSearchFilesCSV");
	case SOAP_TYPE_bmd230__bmdSearchFilesCSVResponse:
		return soap_out_bmd230__bmdSearchFilesCSVResponse(soap, tag, id, (const struct bmd230__bmdSearchFilesCSVResponse *)ptr, "bmd230:bmdSearchFilesCSVResponse");
	case SOAP_TYPE_bmd230__bmdSearchFiles:
		return soap_out_bmd230__bmdSearchFiles(soap, tag, id, (const struct bmd230__bmdSearchFiles *)ptr, "bmd230:bmdSearchFiles");
	case SOAP_TYPE_bmd230__bmdSearchFilesResponse:
		return soap_out_bmd230__bmdSearchFilesResponse(soap, tag, id, (const struct bmd230__bmdSearchFilesResponse *)ptr, "bmd230:bmdSearchFilesResponse");
	case SOAP_TYPE_bmd230__bmdLogin:
		return soap_out_bmd230__bmdLogin(soap, tag, id, (const struct bmd230__bmdLogin *)ptr, "bmd230:bmdLogin");
	case SOAP_TYPE_bmd230__bmdLoginResponse:
		return soap_out_bmd230__bmdLoginResponse(soap, tag, id, (const struct bmd230__bmdLoginResponse *)ptr, "bmd230:bmdLoginResponse");
	case SOAP_TYPE_bmd230__bmdAddSignature:
		return soap_out_bmd230__bmdAddSignature(soap, tag, id, (const struct bmd230__bmdAddSignature *)ptr, "bmd230:bmdAddSignature");
	case SOAP_TYPE_bmd230__bmdAddSignatureResponse:
		return soap_out_bmd230__bmdAddSignatureResponse(soap, tag, id, (const struct bmd230__bmdAddSignatureResponse *)ptr, "bmd230:bmdAddSignatureResponse");
	case SOAP_TYPE_bmd230__bmdUpdateDefaultMetadataValue:
		return soap_out_bmd230__bmdUpdateDefaultMetadataValue(soap, tag, id, (const struct bmd230__bmdUpdateDefaultMetadataValue *)ptr, "bmd230:bmdUpdateDefaultMetadataValue");
	case SOAP_TYPE_bmd230__bmdUpdateDefaultMetadataValueResponse:
		return soap_out_bmd230__bmdUpdateDefaultMetadataValueResponse(soap, tag, id, (const struct bmd230__bmdUpdateDefaultMetadataValueResponse *)ptr, "bmd230:bmdUpdateDefaultMetadataValueResponse");
	case SOAP_TYPE_bmd230__bmdUpdateSystemMetadata:
		return soap_out_bmd230__bmdUpdateSystemMetadata(soap, tag, id, (const struct bmd230__bmdUpdateSystemMetadata *)ptr, "bmd230:bmdUpdateSystemMetadata");
	case SOAP_TYPE_bmd230__bmdUpdateSystemMetadataResponse:
		return soap_out_bmd230__bmdUpdateSystemMetadataResponse(soap, tag, id, (const struct bmd230__bmdUpdateSystemMetadataResponse *)ptr, "bmd230:bmdUpdateSystemMetadataResponse");
	case SOAP_TYPE_bmd230__bmdUpdateMetadata:
		return soap_out_bmd230__bmdUpdateMetadata(soap, tag, id, (const struct bmd230__bmdUpdateMetadata *)ptr, "bmd230:bmdUpdateMetadata");
	case SOAP_TYPE_bmd230__bmdUpdateMetadataResponse:
		return soap_out_bmd230__bmdUpdateMetadataResponse(soap, tag, id, (const struct bmd230__bmdUpdateMetadataResponse *)ptr, "bmd230:bmdUpdateMetadataResponse");
	case SOAP_TYPE_bmd230__bmdDeleteDirByID:
		return soap_out_bmd230__bmdDeleteDirByID(soap, tag, id, (const struct bmd230__bmdDeleteDirByID *)ptr, "bmd230:bmdDeleteDirByID");
	case SOAP_TYPE_bmd230__bmdDeleteDirByIDResponse:
		return soap_out_bmd230__bmdDeleteDirByIDResponse(soap, tag, id, (const struct bmd230__bmdDeleteDirByIDResponse *)ptr, "bmd230:bmdDeleteDirByIDResponse");
	case SOAP_TYPE_bmd230__bmdDeleteFileByID:
		return soap_out_bmd230__bmdDeleteFileByID(soap, tag, id, (const struct bmd230__bmdDeleteFileByID *)ptr, "bmd230:bmdDeleteFileByID");
	case SOAP_TYPE_bmd230__bmdDeleteFileByIDResponse:
		return soap_out_bmd230__bmdDeleteFileByIDResponse(soap, tag, id, (const struct bmd230__bmdDeleteFileByIDResponse *)ptr, "bmd230:bmdDeleteFileByIDResponse");
	case SOAP_TYPE_bmd230__bmdUpdateFileVersion:
		return soap_out_bmd230__bmdUpdateFileVersion(soap, tag, id, (const struct bmd230__bmdUpdateFileVersion *)ptr, "bmd230:bmdUpdateFileVersion");
	case SOAP_TYPE_bmd230__bmdUpdateFileVersionResponse:
		return soap_out_bmd230__bmdUpdateFileVersionResponse(soap, tag, id, (const struct bmd230__bmdUpdateFileVersionResponse *)ptr, "bmd230:bmdUpdateFileVersionResponse");
	case SOAP_TYPE_bmd230__bmdInsertFileList:
		return soap_out_bmd230__bmdInsertFileList(soap, tag, id, (const struct bmd230__bmdInsertFileList *)ptr, "bmd230:bmdInsertFileList");
	case SOAP_TYPE_bmd230__bmdInsertFileListResponse:
		return soap_out_bmd230__bmdInsertFileListResponse(soap, tag, id, (const struct bmd230__bmdInsertFileListResponse *)ptr, "bmd230:bmdInsertFileListResponse");
	case SOAP_TYPE_bmd230__bmdInsertSignedFile:
		return soap_out_bmd230__bmdInsertSignedFile(soap, tag, id, (const struct bmd230__bmdInsertSignedFile *)ptr, "bmd230:bmdInsertSignedFile");
	case SOAP_TYPE_bmd230__bmdInsertSignedFileResponse:
		return soap_out_bmd230__bmdInsertSignedFileResponse(soap, tag, id, (const struct bmd230__bmdInsertSignedFileResponse *)ptr, "bmd230:bmdInsertSignedFileResponse");
	case SOAP_TYPE_bmd230__bmdInsertFile:
		return soap_out_bmd230__bmdInsertFile(soap, tag, id, (const struct bmd230__bmdInsertFile *)ptr, "bmd230:bmdInsertFile");
	case SOAP_TYPE_bmd230__bmdInsertFileResponse:
		return soap_out_bmd230__bmdInsertFileResponse(soap, tag, id, (const struct bmd230__bmdInsertFileResponse *)ptr, "bmd230:bmdInsertFileResponse");
	case SOAP_TYPE_bmd230__testConnection:
		return soap_out_bmd230__testConnection(soap, tag, id, (const struct bmd230__testConnection *)ptr, "bmd230:testConnection");
	case SOAP_TYPE_bmd230__testConnectionResponse:
		return soap_out_bmd230__testConnectionResponse(soap, tag, id, (const struct bmd230__testConnectionResponse *)ptr, "bmd230:testConnectionResponse");
	case SOAP_TYPE_bmd230__ActionsHistoryList:
		return soap_out_bmd230__ActionsHistoryList(soap, tag, id, (const struct bmd230__ActionsHistoryList *)ptr, "bmd230:ActionsHistoryList");
	case SOAP_TYPE_bmd230__ActionsHistoryElement:
		return soap_out_bmd230__ActionsHistoryElement(soap, tag, id, (const struct bmd230__ActionsHistoryElement *)ptr, "bmd230:ActionsHistoryElement");
	case SOAP_TYPE_bmd230__GetVersionsHistoryResultList:
		return soap_out_bmd230__GetVersionsHistoryResultList(soap, tag, id, (const struct bmd230__GetVersionsHistoryResultList *)ptr, "bmd230:GetVersionsHistoryResultList");
	case SOAP_TYPE_bmd230__GetVersionsHistoryResult:
		return soap_out_bmd230__GetVersionsHistoryResult(soap, tag, id, (const struct bmd230__GetVersionsHistoryResult *)ptr, "bmd230:GetVersionsHistoryResult");
	case SOAP_TYPE_bmd230__FileVersionInfoList:
		return soap_out_bmd230__FileVersionInfoList(soap, tag, id, (const struct bmd230__FileVersionInfoList *)ptr, "bmd230:FileVersionInfoList");
	case SOAP_TYPE_bmd230__FileVersionInfo:
		return soap_out_bmd230__FileVersionInfo(soap, tag, id, (const struct bmd230__FileVersionInfo *)ptr, "bmd230:FileVersionInfo");
	case SOAP_TYPE_bmd230__accessObjectList:
		return soap_out_bmd230__accessObjectList(soap, tag, id, (const struct bmd230__accessObjectList *)ptr, "bmd230:accessObjectList");
	case SOAP_TYPE_bmd230__accessObject:
		return soap_out_bmd230__accessObject(soap, tag, id, (const struct bmd230__accessObject *)ptr, "bmd230:accessObject");
	case SOAP_TYPE_bmd230__archPackOut:
		return soap_out_bmd230__archPackOut(soap, tag, id, (const struct bmd230__archPackOut *)ptr, "bmd230:archPackOut");
	case SOAP_TYPE_bmd230__deleteCascadeLinksList:
		return soap_out_bmd230__deleteCascadeLinksList(soap, tag, id, (const struct bmd230__deleteCascadeLinksList *)ptr, "bmd230:deleteCascadeLinksList");
	case SOAP_TYPE_bmd230__deleteCascadeLinksElement:
		return soap_out_bmd230__deleteCascadeLinksElement(soap, tag, id, (const struct bmd230__deleteCascadeLinksElement *)ptr, "bmd230:deleteCascadeLinksElement");
	case SOAP_TYPE_bmd230__manyCascadeLinksResult:
		return soap_out_bmd230__manyCascadeLinksResult(soap, tag, id, (const struct bmd230__manyCascadeLinksResult *)ptr, "bmd230:manyCascadeLinksResult");
	case SOAP_TYPE_bmd230__manyCascadeLinksElement:
		return soap_out_bmd230__manyCascadeLinksElement(soap, tag, id, (const struct bmd230__manyCascadeLinksElement *)ptr, "bmd230:manyCascadeLinksElement");
	case SOAP_TYPE_bmd230__cascadeLinksInfo:
		return soap_out_bmd230__cascadeLinksInfo(soap, tag, id, (const struct bmd230__cascadeLinksInfo *)ptr, "bmd230:cascadeLinksInfo");
	case SOAP_TYPE_bmd230__singleCascadeLinkInfo:
		return soap_out_bmd230__singleCascadeLinkInfo(soap, tag, id, (const struct bmd230__singleCascadeLinkInfo *)ptr, "bmd230:singleCascadeLinkInfo");
	case SOAP_TYPE_bmd230__linksInfo:
		return soap_out_bmd230__linksInfo(soap, tag, id, (const struct bmd230__linksInfo *)ptr, "bmd230:linksInfo");
	case SOAP_TYPE_bmd230__DateTime:
		return soap_out_bmd230__DateTime(soap, tag, id, (const struct bmd230__DateTime *)ptr, "bmd230:DateTime");
	case SOAP_TYPE_bmd230__singleLinkInfo:
		return soap_out_bmd230__singleLinkInfo(soap, tag, id, (const struct bmd230__singleLinkInfo *)ptr, "bmd230:singleLinkInfo");
	case SOAP_TYPE_bmd230__securityInfo:
		return soap_out_bmd230__securityInfo(soap, tag, id, (const struct bmd230__securityInfo *)ptr, "bmd230:securityInfo");
	case SOAP_TYPE_bmd230__secLevelInfo:
		return soap_out_bmd230__secLevelInfo(soap, tag, id, (const struct bmd230__secLevelInfo *)ptr, "bmd230:secLevelInfo");
	case SOAP_TYPE_bmd230__singleSecLevelInfo:
		return soap_out_bmd230__singleSecLevelInfo(soap, tag, id, (const struct bmd230__singleSecLevelInfo *)ptr, "bmd230:singleSecLevelInfo");
	case SOAP_TYPE_bmd230__secCategoryInfo:
		return soap_out_bmd230__secCategoryInfo(soap, tag, id, (const struct bmd230__secCategoryInfo *)ptr, "bmd230:secCategoryInfo");
	case SOAP_TYPE_bmd230__singleSecCategoryInfo:
		return soap_out_bmd230__singleSecCategoryInfo(soap, tag, id, (const struct bmd230__singleSecCategoryInfo *)ptr, "bmd230:singleSecCategoryInfo");
	case SOAP_TYPE_bmd230__classInfo:
		return soap_out_bmd230__classInfo(soap, tag, id, (const struct bmd230__classInfo *)ptr, "bmd230:classInfo");
	case SOAP_TYPE_bmd230__singleClassInfo:
		return soap_out_bmd230__singleClassInfo(soap, tag, id, (const struct bmd230__singleClassInfo *)ptr, "bmd230:singleClassInfo");
	case SOAP_TYPE_bmd230__groupInfo:
		return soap_out_bmd230__groupInfo(soap, tag, id, (const struct bmd230__groupInfo *)ptr, "bmd230:groupInfo");
	case SOAP_TYPE_bmd230__singleGroupInfo:
		return soap_out_bmd230__singleGroupInfo(soap, tag, id, (const struct bmd230__singleGroupInfo *)ptr, "bmd230:singleGroupInfo");
	case SOAP_TYPE_bmd230__userRoleInfo:
		return soap_out_bmd230__userRoleInfo(soap, tag, id, (const struct bmd230__userRoleInfo *)ptr, "bmd230:userRoleInfo");
	case SOAP_TYPE_bmd230__singleRoleInfo:
		return soap_out_bmd230__singleRoleInfo(soap, tag, id, (const struct bmd230__singleRoleInfo *)ptr, "bmd230:singleRoleInfo");
	case SOAP_TYPE_bmd230__loginResponse:
		return soap_out_bmd230__loginResponse(soap, tag, id, (const struct bmd230__loginResponse *)ptr, "bmd230:loginResponse");
	case SOAP_TYPE_bmd230__userRegistrationResult:
		return soap_out_bmd230__userRegistrationResult(soap, tag, id, (const struct bmd230__userRegistrationResult *)ptr, "bmd230:userRegistrationResult");
	case SOAP_TYPE_bmd230__userListInfo:
		return soap_out_bmd230__userListInfo(soap, tag, id, (const struct bmd230__userListInfo *)ptr, "bmd230:userListInfo");
	case SOAP_TYPE_bmd230__singleUserInfo:
		return soap_out_bmd230__singleUserInfo(soap, tag, id, (const struct bmd230__singleUserInfo *)ptr, "bmd230:singleUserInfo");
	case SOAP_TYPE_bmd230__userNewGroupInfo:
		return soap_out_bmd230__userNewGroupInfo(soap, tag, id, (const struct bmd230__userNewGroupInfo *)ptr, "bmd230:userNewGroupInfo");
	case SOAP_TYPE_bmd230__stringList:
		return soap_out_bmd230__stringList(soap, tag, id, (const struct bmd230__stringList *)ptr, "bmd230:stringList");
	case SOAP_TYPE_bmd230__mtdsSearchValues:
		return soap_out_bmd230__mtdsSearchValues(soap, tag, id, (const struct bmd230__mtdsSearchValues *)ptr, "bmd230:mtdsSearchValues");
	case SOAP_TYPE_bmd230__mtdSearchSingleValue:
		return soap_out_bmd230__mtdSearchSingleValue(soap, tag, id, (const struct bmd230__mtdSearchSingleValue *)ptr, "bmd230:mtdSearchSingleValue");
	case SOAP_TYPE_bmd230__bmdTimestamp:
		return soap_out_bmd230__bmdTimestamp(soap, tag, id, (const struct bmd230__bmdTimestamp *)ptr, "bmd230:bmdTimestamp");
	case SOAP_TYPE_bmd230__historyResults:
		return soap_out_bmd230__historyResults(soap, tag, id, (const struct bmd230__historyResults *)ptr, "bmd230:historyResults");
	case SOAP_TYPE_bmd230__historySingleResult:
		return soap_out_bmd230__historySingleResult(soap, tag, id, (const struct bmd230__historySingleResult *)ptr, "bmd230:historySingleResult");
	case SOAP_TYPE_bmd230__searchResults:
		return soap_out_bmd230__searchResults(soap, tag, id, (const struct bmd230__searchResults *)ptr, "bmd230:searchResults");
	case SOAP_TYPE_bmd230__searchSingleResult:
		return soap_out_bmd230__searchSingleResult(soap, tag, id, (const struct bmd230__searchSingleResult *)ptr, "bmd230:searchSingleResult");
	case SOAP_TYPE_bmd230__mtdsInfo:
		return soap_out_bmd230__mtdsInfo(soap, tag, id, (const struct bmd230__mtdsInfo *)ptr, "bmd230:mtdsInfo");
	case SOAP_TYPE_bmd230__mtdSingleInfo:
		return soap_out_bmd230__mtdSingleInfo(soap, tag, id, (const struct bmd230__mtdSingleInfo *)ptr, "bmd230:mtdSingleInfo");
	case SOAP_TYPE_bmd230__searchSortInfoList:
		return soap_out_bmd230__searchSortInfoList(soap, tag, id, (const struct bmd230__searchSortInfoList *)ptr, "bmd230:searchSortInfoList");
	case SOAP_TYPE_bmd230__searchSortInfo:
		return soap_out_bmd230__searchSortInfo(soap, tag, id, (const struct bmd230__searchSortInfo *)ptr, "bmd230:searchSortInfo");
	case SOAP_TYPE_bmd230__idList:
		return soap_out_bmd230__idList(soap, tag, id, (const struct bmd230__idList *)ptr, "bmd230:idList");
	case SOAP_TYPE_bmd230__fileComplexList:
		return soap_out_bmd230__fileComplexList(soap, tag, id, (const struct bmd230__fileComplexList *)ptr, "bmd230:fileComplexList");
	case SOAP_TYPE_bmd230__fileComplex:
		return soap_out_bmd230__fileComplex(soap, tag, id, (const struct bmd230__fileComplex *)ptr, "bmd230:fileComplex");
	case SOAP_TYPE_bmd230__mtdsValues:
		return soap_out_bmd230__mtdsValues(soap, tag, id, (const struct bmd230__mtdsValues *)ptr, "bmd230:mtdsValues");
	case SOAP_TYPE_bmd230__mtdSingleValue:
		return soap_out_bmd230__mtdSingleValue(soap, tag, id, (const struct bmd230__mtdSingleValue *)ptr, "bmd230:mtdSingleValue");
	case SOAP_TYPE_bmd230__fileInfoList:
		return soap_out_bmd230__fileInfoList(soap, tag, id, (const struct bmd230__fileInfoList *)ptr, "bmd230:fileInfoList");
	case SOAP_TYPE_bmd230__fileInfo:
		return soap_out_bmd230__fileInfo(soap, tag, id, (const struct bmd230__fileInfo *)ptr, "bmd230:fileInfo");
	case SOAP_TYPE_bmd230__PkiFileInfo:
		return soap_out_bmd230__PkiFileInfo(soap, tag, id, (const struct bmd230__PkiFileInfo *)ptr, "bmd230:PkiFileInfo");
	case SOAP_TYPE_bmd230__SignatureList:
		return soap_out_bmd230__SignatureList(soap, tag, id, (const struct bmd230__SignatureList *)ptr, "bmd230:SignatureList");
	case SOAP_TYPE_bmd230__DVCSList:
		return soap_out_bmd230__DVCSList(soap, tag, id, (const struct bmd230__DVCSList *)ptr, "bmd230:DVCSList");
	case SOAP_TYPE_bmd230__SignatureSingle:
		return soap_out_bmd230__SignatureSingle(soap, tag, id, (const struct bmd230__SignatureSingle *)ptr, "bmd230:SignatureSingle");
	case SOAP_TYPE_bmd230__TimestampList:
		return soap_out_bmd230__TimestampList(soap, tag, id, (const struct bmd230__TimestampList *)ptr, "bmd230:TimestampList");
	case SOAP_TYPE_bmd230__DVCSSingle:
		return soap_out_bmd230__DVCSSingle(soap, tag, id, (const struct bmd230__DVCSSingle *)ptr, "bmd230:DVCSSingle");
	case SOAP_TYPE_bmd230__TimestampSingle:
		return soap_out_bmd230__TimestampSingle(soap, tag, id, (const struct bmd230__TimestampSingle *)ptr, "bmd230:TimestampSingle");
	case SOAP_TYPE_bmd230__LongNumbersList:
		return soap_out_bmd230__LongNumbersList(soap, tag, id, (const struct bmd230__LongNumbersList *)ptr, "bmd230:LongNumbersList");
	case SOAP_TYPE_bmd230__myBinaryDataType:
		return soap_out_bmd230__myBinaryDataType(soap, tag, id, (const struct bmd230__myBinaryDataType *)ptr, "bmd230:myBinaryDataType");
	case SOAP_TYPE_xsd__base64Binary:
		return soap_out_xsd__base64Binary(soap, tag, id, (const struct xsd__base64Binary *)ptr, "xsd:base64Binary");
	case SOAP_TYPE__wsse__Security:
		return soap_out__wsse__Security(soap, "wsse:Security", id, (const struct _wsse__Security *)ptr, NULL);
	case SOAP_TYPE_ds__RSAKeyValueType:
		return soap_out_ds__RSAKeyValueType(soap, tag, id, (const struct ds__RSAKeyValueType *)ptr, "ds:RSAKeyValueType");
	case SOAP_TYPE_ds__DSAKeyValueType:
		return soap_out_ds__DSAKeyValueType(soap, tag, id, (const struct ds__DSAKeyValueType *)ptr, "ds:DSAKeyValueType");
	case SOAP_TYPE_ds__X509IssuerSerialType:
		return soap_out_ds__X509IssuerSerialType(soap, tag, id, (const struct ds__X509IssuerSerialType *)ptr, "ds:X509IssuerSerialType");
	case SOAP_TYPE_ds__X509DataType:
		return soap_out_ds__X509DataType(soap, tag, id, (const struct ds__X509DataType *)ptr, "ds:X509DataType");
	case SOAP_TYPE_ds__RetrievalMethodType:
		return soap_out_ds__RetrievalMethodType(soap, tag, id, (const struct ds__RetrievalMethodType *)ptr, "ds:RetrievalMethodType");
	case SOAP_TYPE_ds__KeyValueType:
		return soap_out_ds__KeyValueType(soap, tag, id, (const struct ds__KeyValueType *)ptr, "ds:KeyValueType");
	case SOAP_TYPE_ds__DigestMethodType:
		return soap_out_ds__DigestMethodType(soap, tag, id, (const struct ds__DigestMethodType *)ptr, "ds:DigestMethodType");
	case SOAP_TYPE_ds__TransformType:
		return soap_out_ds__TransformType(soap, tag, id, (const struct ds__TransformType *)ptr, "ds:TransformType");
	case SOAP_TYPE__c14n__InclusiveNamespaces:
		return soap_out__c14n__InclusiveNamespaces(soap, "c14n:InclusiveNamespaces", id, (const struct _c14n__InclusiveNamespaces *)ptr, NULL);
	case SOAP_TYPE_ds__TransformsType:
		return soap_out_ds__TransformsType(soap, tag, id, (const struct ds__TransformsType *)ptr, "ds:TransformsType");
	case SOAP_TYPE_ds__ReferenceType:
		return soap_out_ds__ReferenceType(soap, tag, id, (const struct ds__ReferenceType *)ptr, "ds:ReferenceType");
	case SOAP_TYPE_ds__SignatureMethodType:
		return soap_out_ds__SignatureMethodType(soap, tag, id, (const struct ds__SignatureMethodType *)ptr, "ds:SignatureMethodType");
	case SOAP_TYPE_ds__CanonicalizationMethodType:
		return soap_out_ds__CanonicalizationMethodType(soap, tag, id, (const struct ds__CanonicalizationMethodType *)ptr, "ds:CanonicalizationMethodType");
	case SOAP_TYPE_ds__KeyInfoType:
		return soap_out_ds__KeyInfoType(soap, tag, id, (const struct ds__KeyInfoType *)ptr, "ds:KeyInfoType");
	case SOAP_TYPE_ds__SignedInfoType:
		return soap_out_ds__SignedInfoType(soap, tag, id, (const struct ds__SignedInfoType *)ptr, "ds:SignedInfoType");
	case SOAP_TYPE_ds__SignatureType:
		return soap_out_ds__SignatureType(soap, tag, id, (const struct ds__SignatureType *)ptr, "ds:SignatureType");
	case SOAP_TYPE__wsse__SecurityTokenReference:
		return soap_out__wsse__SecurityTokenReference(soap, "wsse:SecurityTokenReference", id, (const struct _wsse__SecurityTokenReference *)ptr, NULL);
	case SOAP_TYPE__wsse__KeyIdentifier:
		return soap_out__wsse__KeyIdentifier(soap, "wsse:KeyIdentifier", id, (const struct _wsse__KeyIdentifier *)ptr, NULL);
	case SOAP_TYPE__wsse__Embedded:
		return soap_out__wsse__Embedded(soap, "wsse:Embedded", id, (const struct _wsse__Embedded *)ptr, NULL);
	case SOAP_TYPE__wsse__Reference:
		return soap_out__wsse__Reference(soap, "wsse:Reference", id, (const struct _wsse__Reference *)ptr, NULL);
	case SOAP_TYPE__wsse__BinarySecurityToken:
		return soap_out__wsse__BinarySecurityToken(soap, "wsse:BinarySecurityToken", id, (const struct _wsse__BinarySecurityToken *)ptr, NULL);
	case SOAP_TYPE__wsse__Password:
		return soap_out__wsse__Password(soap, "wsse:Password", id, (const struct _wsse__Password *)ptr, NULL);
	case SOAP_TYPE__wsse__UsernameToken:
		return soap_out__wsse__UsernameToken(soap, "wsse:UsernameToken", id, (const struct _wsse__UsernameToken *)ptr, NULL);
	case SOAP_TYPE__wsu__Timestamp:
		return soap_out__wsu__Timestamp(soap, "wsu:Timestamp", id, (const struct _wsu__Timestamp *)ptr, NULL);
	case SOAP_TYPE_PointerTobmd230__deleteCascadeLinksList:
		return soap_out_PointerTobmd230__deleteCascadeLinksList(soap, tag, id, (struct bmd230__deleteCascadeLinksList *const*)ptr, "bmd230:deleteCascadeLinksList");
	case SOAP_TYPE_PointerToPointerTobmd230__manyCascadeLinksResult:
		return soap_out_PointerToPointerTobmd230__manyCascadeLinksResult(soap, tag, id, (struct bmd230__manyCascadeLinksResult **const*)ptr, "bmd230:manyCascadeLinksResult");
	case SOAP_TYPE_PointerTobmd230__manyCascadeLinksResult:
		return soap_out_PointerTobmd230__manyCascadeLinksResult(soap, tag, id, (struct bmd230__manyCascadeLinksResult *const*)ptr, "bmd230:manyCascadeLinksResult");
	case SOAP_TYPE_PointerTobmd230__cascadeLinksInfo:
		return soap_out_PointerTobmd230__cascadeLinksInfo(soap, tag, id, (struct bmd230__cascadeLinksInfo *const*)ptr, "bmd230:cascadeLinksInfo");
	case SOAP_TYPE_PointerTobmd230__linksInfo:
		return soap_out_PointerTobmd230__linksInfo(soap, tag, id, (struct bmd230__linksInfo *const*)ptr, "bmd230:linksInfo");
	case SOAP_TYPE_PointerToPointerTobmd230__archPackOut:
		return soap_out_PointerToPointerTobmd230__archPackOut(soap, tag, id, (struct bmd230__archPackOut **const*)ptr, "bmd230:archPackOut");
	case SOAP_TYPE_PointerTobmd230__archPackOut:
		return soap_out_PointerTobmd230__archPackOut(soap, tag, id, (struct bmd230__archPackOut *const*)ptr, "bmd230:archPackOut");
	case SOAP_TYPE_PointerToPointerTobmd230__fileInfoList:
		return soap_out_PointerToPointerTobmd230__fileInfoList(soap, tag, id, (struct bmd230__fileInfoList **const*)ptr, "bmd230:fileInfoList");
	case SOAP_TYPE_PointerTobmd230__fileInfoList:
		return soap_out_PointerTobmd230__fileInfoList(soap, tag, id, (struct bmd230__fileInfoList *const*)ptr, "bmd230:fileInfoList");
	case SOAP_TYPE_PointerToPointerTobmd230__stringList:
		return soap_out_PointerToPointerTobmd230__stringList(soap, tag, id, (struct bmd230__stringList **const*)ptr, "bmd230:stringList");
	case SOAP_TYPE_PointerToPointerTobmd230__ActionsHistoryList:
		return soap_out_PointerToPointerTobmd230__ActionsHistoryList(soap, tag, id, (struct bmd230__ActionsHistoryList **const*)ptr, "bmd230:ActionsHistoryList");
	case SOAP_TYPE_PointerTobmd230__ActionsHistoryList:
		return soap_out_PointerTobmd230__ActionsHistoryList(soap, tag, id, (struct bmd230__ActionsHistoryList *const*)ptr, "bmd230:ActionsHistoryList");
	case SOAP_TYPE_PointerToPointerTobmd230__GetVersionsHistoryResultList:
		return soap_out_PointerToPointerTobmd230__GetVersionsHistoryResultList(soap, tag, id, (struct bmd230__GetVersionsHistoryResultList **const*)ptr, "bmd230:GetVersionsHistoryResultList");
	case SOAP_TYPE_PointerTobmd230__GetVersionsHistoryResultList:
		return soap_out_PointerTobmd230__GetVersionsHistoryResultList(soap, tag, id, (struct bmd230__GetVersionsHistoryResultList *const*)ptr, "bmd230:GetVersionsHistoryResultList");
	case SOAP_TYPE_PointerTobmd230__LongNumbersList:
		return soap_out_PointerTobmd230__LongNumbersList(soap, tag, id, (struct bmd230__LongNumbersList *const*)ptr, "bmd230:LongNumbersList");
	case SOAP_TYPE_PointerToPointerTobmd230__accessObjectList:
		return soap_out_PointerToPointerTobmd230__accessObjectList(soap, tag, id, (struct bmd230__accessObjectList **const*)ptr, "bmd230:accessObjectList");
	case SOAP_TYPE_PointerTobmd230__accessObjectList:
		return soap_out_PointerTobmd230__accessObjectList(soap, tag, id, (struct bmd230__accessObjectList *const*)ptr, "bmd230:accessObjectList");
	case SOAP_TYPE_PointerToPointerTobmd230__bmdTimestamp:
		return soap_out_PointerToPointerTobmd230__bmdTimestamp(soap, tag, id, (struct bmd230__bmdTimestamp **const*)ptr, "bmd230:bmdTimestamp");
	case SOAP_TYPE_PointerTobmd230__bmdTimestamp:
		return soap_out_PointerTobmd230__bmdTimestamp(soap, tag, id, (struct bmd230__bmdTimestamp *const*)ptr, "bmd230:bmdTimestamp");
	case SOAP_TYPE_PointerToPointerTobmd230__PkiFileInfo:
		return soap_out_PointerToPointerTobmd230__PkiFileInfo(soap, tag, id, (struct bmd230__PkiFileInfo **const*)ptr, "bmd230:PkiFileInfo");
	case SOAP_TYPE_PointerTobmd230__PkiFileInfo:
		return soap_out_PointerTobmd230__PkiFileInfo(soap, tag, id, (struct bmd230__PkiFileInfo *const*)ptr, "bmd230:PkiFileInfo");
	case SOAP_TYPE_PointerToPointerTobmd230__securityInfo:
		return soap_out_PointerToPointerTobmd230__securityInfo(soap, tag, id, (struct bmd230__securityInfo **const*)ptr, "bmd230:securityInfo");
	case SOAP_TYPE_PointerTobmd230__securityInfo:
		return soap_out_PointerTobmd230__securityInfo(soap, tag, id, (struct bmd230__securityInfo *const*)ptr, "bmd230:securityInfo");
	case SOAP_TYPE_PointerToPointerTobmd230__classInfo:
		return soap_out_PointerToPointerTobmd230__classInfo(soap, tag, id, (struct bmd230__classInfo **const*)ptr, "bmd230:classInfo");
	case SOAP_TYPE_PointerTobmd230__classInfo:
		return soap_out_PointerTobmd230__classInfo(soap, tag, id, (struct bmd230__classInfo *const*)ptr, "bmd230:classInfo");
	case SOAP_TYPE_PointerToPointerTobmd230__groupInfo:
		return soap_out_PointerToPointerTobmd230__groupInfo(soap, tag, id, (struct bmd230__groupInfo **const*)ptr, "bmd230:groupInfo");
	case SOAP_TYPE_PointerTobmd230__groupInfo:
		return soap_out_PointerTobmd230__groupInfo(soap, tag, id, (struct bmd230__groupInfo *const*)ptr, "bmd230:groupInfo");
	case SOAP_TYPE_PointerToPointerTobmd230__userRoleInfo:
		return soap_out_PointerToPointerTobmd230__userRoleInfo(soap, tag, id, (struct bmd230__userRoleInfo **const*)ptr, "bmd230:userRoleInfo");
	case SOAP_TYPE_PointerTobmd230__userRoleInfo:
		return soap_out_PointerTobmd230__userRoleInfo(soap, tag, id, (struct bmd230__userRoleInfo *const*)ptr, "bmd230:userRoleInfo");
	case SOAP_TYPE_PointerToPointerTobmd230__userListInfo:
		return soap_out_PointerToPointerTobmd230__userListInfo(soap, tag, id, (struct bmd230__userListInfo **const*)ptr, "bmd230:userListInfo");
	case SOAP_TYPE_PointerTobmd230__userListInfo:
		return soap_out_PointerTobmd230__userListInfo(soap, tag, id, (struct bmd230__userListInfo *const*)ptr, "bmd230:userListInfo");
	case SOAP_TYPE_PointerToPointerTobmd230__userRegistrationResult:
		return soap_out_PointerToPointerTobmd230__userRegistrationResult(soap, tag, id, (struct bmd230__userRegistrationResult **const*)ptr, "bmd230:userRegistrationResult");
	case SOAP_TYPE_PointerTobmd230__userRegistrationResult:
		return soap_out_PointerTobmd230__userRegistrationResult(soap, tag, id, (struct bmd230__userRegistrationResult *const*)ptr, "bmd230:userRegistrationResult");
	case SOAP_TYPE_PointerToPointerTobmd230__historyResults:
		return soap_out_PointerToPointerTobmd230__historyResults(soap, tag, id, (struct bmd230__historyResults **const*)ptr, "bmd230:historyResults");
	case SOAP_TYPE_PointerTobmd230__historyResults:
		return soap_out_PointerTobmd230__historyResults(soap, tag, id, (struct bmd230__historyResults *const*)ptr, "bmd230:historyResults");
	case SOAP_TYPE_PointerTobmd230__mtdsSearchValues:
		return soap_out_PointerTobmd230__mtdsSearchValues(soap, tag, id, (struct bmd230__mtdsSearchValues *const*)ptr, "bmd230:mtdsSearchValues");
	case SOAP_TYPE_PointerToPointerTobmd230__fileInfo:
		return soap_out_PointerToPointerTobmd230__fileInfo(soap, tag, id, (struct bmd230__fileInfo **const*)ptr, "bmd230:fileInfo");
	case SOAP_TYPE_PointerToPointerTobmd230__searchResults:
		return soap_out_PointerToPointerTobmd230__searchResults(soap, tag, id, (struct bmd230__searchResults **const*)ptr, "bmd230:searchResults");
	case SOAP_TYPE_PointerTobmd230__searchResults:
		return soap_out_PointerTobmd230__searchResults(soap, tag, id, (struct bmd230__searchResults *const*)ptr, "bmd230:searchResults");
	case SOAP_TYPE_PointerTobmd230__searchSortInfoList:
		return soap_out_PointerTobmd230__searchSortInfoList(soap, tag, id, (struct bmd230__searchSortInfoList *const*)ptr, "bmd230:searchSortInfoList");
	case SOAP_TYPE_PointerToPointerTobmd230__loginResponse:
		return soap_out_PointerToPointerTobmd230__loginResponse(soap, tag, id, (struct bmd230__loginResponse **const*)ptr, "bmd230:loginResponse");
	case SOAP_TYPE_PointerTobmd230__loginResponse:
		return soap_out_PointerTobmd230__loginResponse(soap, tag, id, (struct bmd230__loginResponse *const*)ptr, "bmd230:loginResponse");
	case SOAP_TYPE_PointerToPointerTobmd230__idList:
		return soap_out_PointerToPointerTobmd230__idList(soap, tag, id, (struct bmd230__idList **const*)ptr, "bmd230:idList");
	case SOAP_TYPE_PointerTobmd230__fileComplexList:
		return soap_out_PointerTobmd230__fileComplexList(soap, tag, id, (struct bmd230__fileComplexList *const*)ptr, "bmd230:fileComplexList");
	case SOAP_TYPE_PointerTostring:
		return soap_out_PointerTostring(soap, tag, id, (char **const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerTobmd230__ActionsHistoryElement:
		return soap_out_PointerTobmd230__ActionsHistoryElement(soap, tag, id, (struct bmd230__ActionsHistoryElement *const*)ptr, "bmd230:ActionsHistoryElement");
	case SOAP_TYPE_PointerTobmd230__GetVersionsHistoryResult:
		return soap_out_PointerTobmd230__GetVersionsHistoryResult(soap, tag, id, (struct bmd230__GetVersionsHistoryResult *const*)ptr, "bmd230:GetVersionsHistoryResult");
	case SOAP_TYPE_PointerTobmd230__FileVersionInfoList:
		return soap_out_PointerTobmd230__FileVersionInfoList(soap, tag, id, (struct bmd230__FileVersionInfoList *const*)ptr, "bmd230:FileVersionInfoList");
	case SOAP_TYPE_PointerTobmd230__FileVersionInfo:
		return soap_out_PointerTobmd230__FileVersionInfo(soap, tag, id, (struct bmd230__FileVersionInfo *const*)ptr, "bmd230:FileVersionInfo");
	case SOAP_TYPE_PointerTobmd230__accessObject:
		return soap_out_PointerTobmd230__accessObject(soap, tag, id, (struct bmd230__accessObject *const*)ptr, "bmd230:accessObject");
	case SOAP_TYPE_PointerTobmd230__deleteCascadeLinksElement:
		return soap_out_PointerTobmd230__deleteCascadeLinksElement(soap, tag, id, (struct bmd230__deleteCascadeLinksElement *const*)ptr, "bmd230:deleteCascadeLinksElement");
	case SOAP_TYPE_PointerTobmd230__manyCascadeLinksElement:
		return soap_out_PointerTobmd230__manyCascadeLinksElement(soap, tag, id, (struct bmd230__manyCascadeLinksElement *const*)ptr, "bmd230:manyCascadeLinksElement");
	case SOAP_TYPE_PointerTobmd230__idList:
		return soap_out_PointerTobmd230__idList(soap, tag, id, (struct bmd230__idList *const*)ptr, "bmd230:idList");
	case SOAP_TYPE_PointerTobmd230__singleCascadeLinkInfo:
		return soap_out_PointerTobmd230__singleCascadeLinkInfo(soap, tag, id, (struct bmd230__singleCascadeLinkInfo *const*)ptr, "bmd230:singleCascadeLinkInfo");
	case SOAP_TYPE_PointerTobmd230__singleLinkInfo:
		return soap_out_PointerTobmd230__singleLinkInfo(soap, tag, id, (struct bmd230__singleLinkInfo *const*)ptr, "bmd230:singleLinkInfo");
	case SOAP_TYPE_PointerTobmd230__DateTime:
		return soap_out_PointerTobmd230__DateTime(soap, tag, id, (struct bmd230__DateTime *const*)ptr, "bmd230:DateTime");
	case SOAP_TYPE_PointerTobmd230__secLevelInfo:
		return soap_out_PointerTobmd230__secLevelInfo(soap, tag, id, (struct bmd230__secLevelInfo *const*)ptr, "bmd230:secLevelInfo");
	case SOAP_TYPE_PointerTobmd230__secCategoryInfo:
		return soap_out_PointerTobmd230__secCategoryInfo(soap, tag, id, (struct bmd230__secCategoryInfo *const*)ptr, "bmd230:secCategoryInfo");
	case SOAP_TYPE_PointerTobmd230__singleSecLevelInfo:
		return soap_out_PointerTobmd230__singleSecLevelInfo(soap, tag, id, (struct bmd230__singleSecLevelInfo *const*)ptr, "bmd230:singleSecLevelInfo");
	case SOAP_TYPE_PointerTobmd230__singleSecCategoryInfo:
		return soap_out_PointerTobmd230__singleSecCategoryInfo(soap, tag, id, (struct bmd230__singleSecCategoryInfo *const*)ptr, "bmd230:singleSecCategoryInfo");
	case SOAP_TYPE_PointerTobmd230__singleClassInfo:
		return soap_out_PointerTobmd230__singleClassInfo(soap, tag, id, (struct bmd230__singleClassInfo *const*)ptr, "bmd230:singleClassInfo");
	case SOAP_TYPE_PointerTobmd230__singleGroupInfo:
		return soap_out_PointerTobmd230__singleGroupInfo(soap, tag, id, (struct bmd230__singleGroupInfo *const*)ptr, "bmd230:singleGroupInfo");
	case SOAP_TYPE_PointerTobmd230__singleRoleInfo:
		return soap_out_PointerTobmd230__singleRoleInfo(soap, tag, id, (struct bmd230__singleRoleInfo *const*)ptr, "bmd230:singleRoleInfo");
	case SOAP_TYPE_PointerTobmd230__mtdsInfo:
		return soap_out_PointerTobmd230__mtdsInfo(soap, tag, id, (struct bmd230__mtdsInfo *const*)ptr, "bmd230:mtdsInfo");
	case SOAP_TYPE_PointerTobmd230__singleUserInfo:
		return soap_out_PointerTobmd230__singleUserInfo(soap, tag, id, (struct bmd230__singleUserInfo *const*)ptr, "bmd230:singleUserInfo");
	case SOAP_TYPE_PointerTobmd230__userNewGroupInfo:
		return soap_out_PointerTobmd230__userNewGroupInfo(soap, tag, id, (struct bmd230__userNewGroupInfo *const*)ptr, "bmd230:userNewGroupInfo");
	case SOAP_TYPE_PointerTobmd230__stringList:
		return soap_out_PointerTobmd230__stringList(soap, tag, id, (struct bmd230__stringList *const*)ptr, "bmd230:stringList");
	case SOAP_TYPE_PointerToxsd__string:
		return soap_out_PointerToxsd__string(soap, tag, id, (char **const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerTobmd230__mtdSearchSingleValue:
		return soap_out_PointerTobmd230__mtdSearchSingleValue(soap, tag, id, (struct bmd230__mtdSearchSingleValue *const*)ptr, "bmd230:mtdSearchSingleValue");
	case SOAP_TYPE_PointerTobmd230__historySingleResult:
		return soap_out_PointerTobmd230__historySingleResult(soap, tag, id, (struct bmd230__historySingleResult *const*)ptr, "bmd230:historySingleResult");
	case SOAP_TYPE_PointerTobmd230__searchSingleResult:
		return soap_out_PointerTobmd230__searchSingleResult(soap, tag, id, (struct bmd230__searchSingleResult *const*)ptr, "bmd230:searchSingleResult");
	case SOAP_TYPE_PointerTobmd230__mtdSingleInfo:
		return soap_out_PointerTobmd230__mtdSingleInfo(soap, tag, id, (struct bmd230__mtdSingleInfo *const*)ptr, "bmd230:mtdSingleInfo");
	case SOAP_TYPE_PointerTobmd230__searchSortInfo:
		return soap_out_PointerTobmd230__searchSortInfo(soap, tag, id, (struct bmd230__searchSortInfo *const*)ptr, "bmd230:searchSortInfo");
	case SOAP_TYPE_PointerTobmd230__fileComplex:
		return soap_out_PointerTobmd230__fileComplex(soap, tag, id, (struct bmd230__fileComplex *const*)ptr, "bmd230:fileComplex");
	case SOAP_TYPE_PointerTobmd230__mtdsValues:
		return soap_out_PointerTobmd230__mtdsValues(soap, tag, id, (struct bmd230__mtdsValues *const*)ptr, "bmd230:mtdsValues");
	case SOAP_TYPE_PointerTobmd230__mtdSingleValue:
		return soap_out_PointerTobmd230__mtdSingleValue(soap, tag, id, (struct bmd230__mtdSingleValue *const*)ptr, "bmd230:mtdSingleValue");
	case SOAP_TYPE_PointerTobmd230__fileInfo:
		return soap_out_PointerTobmd230__fileInfo(soap, tag, id, (struct bmd230__fileInfo *const*)ptr, "bmd230:fileInfo");
	case SOAP_TYPE_PointerTobmd230__myBinaryDataType:
		return soap_out_PointerTobmd230__myBinaryDataType(soap, tag, id, (struct bmd230__myBinaryDataType *const*)ptr, "bmd230:myBinaryDataType");
	case SOAP_TYPE_PointerTobmd230__SignatureList:
		return soap_out_PointerTobmd230__SignatureList(soap, tag, id, (struct bmd230__SignatureList *const*)ptr, "bmd230:SignatureList");
	case SOAP_TYPE_PointerTobmd230__SignatureSingle:
		return soap_out_PointerTobmd230__SignatureSingle(soap, tag, id, (struct bmd230__SignatureSingle *const*)ptr, "bmd230:SignatureSingle");
	case SOAP_TYPE_PointerTobmd230__DVCSSingle:
		return soap_out_PointerTobmd230__DVCSSingle(soap, tag, id, (struct bmd230__DVCSSingle *const*)ptr, "bmd230:DVCSSingle");
	case SOAP_TYPE_PointerTobmd230__TimestampSingle:
		return soap_out_PointerTobmd230__TimestampSingle(soap, tag, id, (struct bmd230__TimestampSingle *const*)ptr, "bmd230:TimestampSingle");
	case SOAP_TYPE_PointerTobmd230__DVCSList:
		return soap_out_PointerTobmd230__DVCSList(soap, tag, id, (struct bmd230__DVCSList *const*)ptr, "bmd230:DVCSList");
	case SOAP_TYPE_PointerTobmd230__TimestampList:
		return soap_out_PointerTobmd230__TimestampList(soap, tag, id, (struct bmd230__TimestampList *const*)ptr, "bmd230:TimestampList");
	case SOAP_TYPE_PointerToxsd__base64Binary:
		return soap_out_PointerToxsd__base64Binary(soap, tag, id, (struct xsd__base64Binary *const*)ptr, "xsd:base64Binary");
	case SOAP_TYPE_PointerTolong:
		return soap_out_PointerTolong(soap, tag, id, (long *const*)ptr, "xsd:long");
	case SOAP_TYPE_PointerTounsignedByte:
		return soap_out_PointerTounsignedByte(soap, tag, id, (unsigned char *const*)ptr, "xsd:unsignedByte");
	case SOAP_TYPE_xsd__string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	case SOAP_TYPE_PointerTo_wsse__Security:
		return soap_out_PointerTo_wsse__Security(soap, tag, id, (struct _wsse__Security *const*)ptr, "wsse:Security");
	case SOAP_TYPE_PointerTods__SignatureType:
		return soap_out_PointerTods__SignatureType(soap, tag, id, (struct ds__SignatureType *const*)ptr, "ds:SignatureType");
	case SOAP_TYPE_PointerTo_wsse__BinarySecurityToken:
		return soap_out_PointerTo_wsse__BinarySecurityToken(soap, tag, id, (struct _wsse__BinarySecurityToken *const*)ptr, "wsse:BinarySecurityToken");
	case SOAP_TYPE_PointerTo_wsse__UsernameToken:
		return soap_out_PointerTo_wsse__UsernameToken(soap, tag, id, (struct _wsse__UsernameToken *const*)ptr, "wsse:UsernameToken");
	case SOAP_TYPE_PointerTo_wsu__Timestamp:
		return soap_out_PointerTo_wsu__Timestamp(soap, tag, id, (struct _wsu__Timestamp *const*)ptr, "wsu:Timestamp");
	case SOAP_TYPE_PointerTods__X509IssuerSerialType:
		return soap_out_PointerTods__X509IssuerSerialType(soap, tag, id, (struct ds__X509IssuerSerialType *const*)ptr, "ds:X509IssuerSerialType");
	case SOAP_TYPE_PointerTods__RSAKeyValueType:
		return soap_out_PointerTods__RSAKeyValueType(soap, tag, id, (struct ds__RSAKeyValueType *const*)ptr, "ds:RSAKeyValueType");
	case SOAP_TYPE_PointerTods__DSAKeyValueType:
		return soap_out_PointerTods__DSAKeyValueType(soap, tag, id, (struct ds__DSAKeyValueType *const*)ptr, "ds:DSAKeyValueType");
	case SOAP_TYPE_PointerTods__TransformType:
		return soap_out_PointerTods__TransformType(soap, tag, id, (struct ds__TransformType *const*)ptr, "ds:TransformType");
	case SOAP_TYPE_PointerTods__DigestMethodType:
		return soap_out_PointerTods__DigestMethodType(soap, tag, id, (struct ds__DigestMethodType *const*)ptr, "ds:DigestMethodType");
	case SOAP_TYPE_PointerTods__TransformsType:
		return soap_out_PointerTods__TransformsType(soap, tag, id, (struct ds__TransformsType *const*)ptr, "ds:TransformsType");
	case SOAP_TYPE_PointerToint:
		return soap_out_PointerToint(soap, tag, id, (int *const*)ptr, "xsd:int");
	case SOAP_TYPE_PointerToPointerTods__ReferenceType:
		return soap_out_PointerToPointerTods__ReferenceType(soap, tag, id, (struct ds__ReferenceType **const*)ptr, "ds:ReferenceType");
	case SOAP_TYPE_PointerTods__ReferenceType:
		return soap_out_PointerTods__ReferenceType(soap, tag, id, (struct ds__ReferenceType *const*)ptr, "ds:ReferenceType");
	case SOAP_TYPE_PointerTods__SignatureMethodType:
		return soap_out_PointerTods__SignatureMethodType(soap, tag, id, (struct ds__SignatureMethodType *const*)ptr, "ds:SignatureMethodType");
	case SOAP_TYPE_PointerTods__CanonicalizationMethodType:
		return soap_out_PointerTods__CanonicalizationMethodType(soap, tag, id, (struct ds__CanonicalizationMethodType *const*)ptr, "ds:CanonicalizationMethodType");
	case SOAP_TYPE_PointerTo_wsse__SecurityTokenReference:
		return soap_out_PointerTo_wsse__SecurityTokenReference(soap, tag, id, (struct _wsse__SecurityTokenReference *const*)ptr, "wsse:SecurityTokenReference");
	case SOAP_TYPE_PointerTods__X509DataType:
		return soap_out_PointerTods__X509DataType(soap, tag, id, (struct ds__X509DataType *const*)ptr, "ds:X509DataType");
	case SOAP_TYPE_PointerTods__RetrievalMethodType:
		return soap_out_PointerTods__RetrievalMethodType(soap, tag, id, (struct ds__RetrievalMethodType *const*)ptr, "ds:RetrievalMethodType");
	case SOAP_TYPE_PointerTods__KeyValueType:
		return soap_out_PointerTods__KeyValueType(soap, tag, id, (struct ds__KeyValueType *const*)ptr, "ds:KeyValueType");
	case SOAP_TYPE_PointerTo_c14n__InclusiveNamespaces:
		return soap_out_PointerTo_c14n__InclusiveNamespaces(soap, tag, id, (struct _c14n__InclusiveNamespaces *const*)ptr, "c14n:InclusiveNamespaces");
	case SOAP_TYPE_PointerTods__KeyInfoType:
		return soap_out_PointerTods__KeyInfoType(soap, tag, id, (struct ds__KeyInfoType *const*)ptr, "ds:KeyInfoType");
	case SOAP_TYPE_PointerTods__SignedInfoType:
		return soap_out_PointerTods__SignedInfoType(soap, tag, id, (struct ds__SignedInfoType *const*)ptr, "ds:SignedInfoType");
	case SOAP_TYPE_PointerTo_wsse__Embedded:
		return soap_out_PointerTo_wsse__Embedded(soap, tag, id, (struct _wsse__Embedded *const*)ptr, "wsse:Embedded");
	case SOAP_TYPE_PointerTo_wsse__KeyIdentifier:
		return soap_out_PointerTo_wsse__KeyIdentifier(soap, tag, id, (struct _wsse__KeyIdentifier *const*)ptr, "wsse:KeyIdentifier");
	case SOAP_TYPE_PointerTo_wsse__Reference:
		return soap_out_PointerTo_wsse__Reference(soap, tag, id, (struct _wsse__Reference *const*)ptr, "wsse:Reference");
	case SOAP_TYPE_PointerTo_wsse__Password:
		return soap_out_PointerTo_wsse__Password(soap, tag, id, (struct _wsse__Password *const*)ptr, "wsse:Password");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_bmd230__bmdDeleteReplacedLobs:
		soap_serialize_bmd230__bmdDeleteReplacedLobs(soap, (const struct bmd230__bmdDeleteReplacedLobs *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdDeleteReplacedLobsResponse:
		soap_serialize_bmd230__bmdDeleteReplacedLobsResponse(soap, (const struct bmd230__bmdDeleteReplacedLobsResponse *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdConservateTimestamps:
		soap_serialize_bmd230__bmdConservateTimestamps(soap, (const struct bmd230__bmdConservateTimestamps *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdConservateTimestampsResponse:
		soap_serialize_bmd230__bmdConservateTimestampsResponse(soap, (const struct bmd230__bmdConservateTimestampsResponse *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdDeleteCascadeLinks:
		soap_serialize_bmd230__bmdDeleteCascadeLinks(soap, (const struct bmd230__bmdDeleteCascadeLinks *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdDeleteCascadeLinksResponse:
		soap_serialize_bmd230__bmdDeleteCascadeLinksResponse(soap, (const struct bmd230__bmdDeleteCascadeLinksResponse *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdCreateManyCascadeLinks:
		soap_serialize_bmd230__bmdCreateManyCascadeLinks(soap, (const struct bmd230__bmdCreateManyCascadeLinks *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdCreateManyCascadeLinksResponse:
		soap_serialize_bmd230__bmdCreateManyCascadeLinksResponse(soap, (const struct bmd230__bmdCreateManyCascadeLinksResponse *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdCreateCascadeLinks:
		soap_serialize_bmd230__bmdCreateCascadeLinks(soap, (const struct bmd230__bmdCreateCascadeLinks *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdCreateCascadeLinksResponse:
		soap_serialize_bmd230__bmdCreateCascadeLinksResponse(soap, (const struct bmd230__bmdCreateCascadeLinksResponse *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdCreateLinks:
		soap_serialize_bmd230__bmdCreateLinks(soap, (const struct bmd230__bmdCreateLinks *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdCreateLinksResponse:
		soap_serialize_bmd230__bmdCreateLinksResponse(soap, (const struct bmd230__bmdCreateLinksResponse *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdCreateLink:
		soap_serialize_bmd230__bmdCreateLink(soap, (const struct bmd230__bmdCreateLink *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdCreateLinkResponse:
		soap_serialize_bmd230__bmdCreateLinkResponse(soap, (const struct bmd230__bmdCreateLinkResponse *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdGetDirectoryDetails:
		soap_serialize_bmd230__bmdGetDirectoryDetails(soap, (const struct bmd230__bmdGetDirectoryDetails *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdGetDirectoryDetailsResponse:
		soap_serialize_bmd230__bmdGetDirectoryDetailsResponse(soap, (const struct bmd230__bmdGetDirectoryDetailsResponse *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdCreateDirectory:
		soap_serialize_bmd230__bmdCreateDirectory(soap, (const struct bmd230__bmdCreateDirectory *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdCreateDirectoryResponse:
		soap_serialize_bmd230__bmdCreateDirectoryResponse(soap, (const struct bmd230__bmdCreateDirectoryResponse *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdStopTransaction:
		soap_serialize_bmd230__bmdStopTransaction(soap, (const struct bmd230__bmdStopTransaction *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdStopTransactionResponse:
		soap_serialize_bmd230__bmdStopTransactionResponse(soap, (const struct bmd230__bmdStopTransactionResponse *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdStartTransaction:
		soap_serialize_bmd230__bmdStartTransaction(soap, (const struct bmd230__bmdStartTransaction *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdStartTransactionResponse:
		soap_serialize_bmd230__bmdStartTransactionResponse(soap, (const struct bmd230__bmdStartTransactionResponse *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdGetArchPackInChunk:
		soap_serialize_bmd230__bmdGetArchPackInChunk(soap, (const struct bmd230__bmdGetArchPackInChunk *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdGetArchPackInChunkResponse:
		soap_serialize_bmd230__bmdGetArchPackInChunkResponse(soap, (const struct bmd230__bmdGetArchPackInChunkResponse *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdGetFileChunkIter:
		soap_serialize_bmd230__bmdGetFileChunkIter(soap, (const struct bmd230__bmdGetFileChunkIter *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdGetFileChunkIterResponse:
		soap_serialize_bmd230__bmdGetFileChunkIterResponse(soap, (const struct bmd230__bmdGetFileChunkIterResponse *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdGetFileChunkStart:
		soap_serialize_bmd230__bmdGetFileChunkStart(soap, (const struct bmd230__bmdGetFileChunkStart *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdGetFileChunkStartResponse:
		soap_serialize_bmd230__bmdGetFileChunkStartResponse(soap, (const struct bmd230__bmdGetFileChunkStartResponse *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdInsertFileChunkIter:
		soap_serialize_bmd230__bmdInsertFileChunkIter(soap, (const struct bmd230__bmdInsertFileChunkIter *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdInsertFileChunkIterResponse:
		soap_serialize_bmd230__bmdInsertFileChunkIterResponse(soap, (const struct bmd230__bmdInsertFileChunkIterResponse *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdInsertFileChunkStart:
		soap_serialize_bmd230__bmdInsertFileChunkStart(soap, (const struct bmd230__bmdInsertFileChunkStart *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdInsertFileChunkStartResponse:
		soap_serialize_bmd230__bmdInsertFileChunkStartResponse(soap, (const struct bmd230__bmdInsertFileChunkStartResponse *)ptr);
		break;
	case SOAP_TYPE_bmd230__getFile:
		soap_serialize_bmd230__getFile(soap, (const struct bmd230__getFile *)ptr);
		break;
	case SOAP_TYPE_bmd230__getFileResponse:
		soap_serialize_bmd230__getFileResponse(soap, (const struct bmd230__getFileResponse *)ptr);
		break;
	case SOAP_TYPE_bmd230__countInvoice:
		soap_serialize_bmd230__countInvoice(soap, (const struct bmd230__countInvoice *)ptr);
		break;
	case SOAP_TYPE_bmd230__countInvoiceResponse:
		soap_serialize_bmd230__countInvoiceResponse(soap, (const struct bmd230__countInvoiceResponse *)ptr);
		break;
	case SOAP_TYPE_bmd230__verifyInvoiceWithDetails:
		soap_serialize_bmd230__verifyInvoiceWithDetails(soap, (const struct bmd230__verifyInvoiceWithDetails *)ptr);
		break;
	case SOAP_TYPE_bmd230__verifyInvoiceWithDetailsResponse:
		soap_serialize_bmd230__verifyInvoiceWithDetailsResponse(soap, (const struct bmd230__verifyInvoiceWithDetailsResponse *)ptr);
		break;
	case SOAP_TYPE_bmd230__verifyInvoiceSimplified:
		soap_serialize_bmd230__verifyInvoiceSimplified(soap, (const struct bmd230__verifyInvoiceSimplified *)ptr);
		break;
	case SOAP_TYPE_bmd230__verifyInvoiceSimplifiedResponse:
		soap_serialize_bmd230__verifyInvoiceSimplifiedResponse(soap, (const struct bmd230__verifyInvoiceSimplifiedResponse *)ptr);
		break;
	case SOAP_TYPE_bmd230__verifyInvoice:
		soap_serialize_bmd230__verifyInvoice(soap, (const struct bmd230__verifyInvoice *)ptr);
		break;
	case SOAP_TYPE_bmd230__verifyInvoiceResponse:
		soap_serialize_bmd230__verifyInvoiceResponse(soap, (const struct bmd230__verifyInvoiceResponse *)ptr);
		break;
	case SOAP_TYPE_bmd230__getHTMLImage:
		soap_serialize_bmd230__getHTMLImage(soap, (const struct bmd230__getHTMLImage *)ptr);
		break;
	case SOAP_TYPE_bmd230__getHTMLImageResponse:
		soap_serialize_bmd230__getHTMLImageResponse(soap, (const struct bmd230__getHTMLImageResponse *)ptr);
		break;
	case SOAP_TYPE_bmd230__getInvoicePack:
		soap_serialize_bmd230__getInvoicePack(soap, (const struct bmd230__getInvoicePack *)ptr);
		break;
	case SOAP_TYPE_bmd230__getInvoicePackResponse:
		soap_serialize_bmd230__getInvoicePackResponse(soap, (const struct bmd230__getInvoicePackResponse *)ptr);
		break;
	case SOAP_TYPE_bmd230__SendAdviceWithParameters:
		soap_serialize_bmd230__SendAdviceWithParameters(soap, (const struct bmd230__SendAdviceWithParameters *)ptr);
		break;
	case SOAP_TYPE_bmd230__SendAdviceWithParametersResponse:
		soap_serialize_bmd230__SendAdviceWithParametersResponse(soap, (const struct bmd230__SendAdviceWithParametersResponse *)ptr);
		break;
	case SOAP_TYPE_bmd230__SendAdvice:
		soap_serialize_bmd230__SendAdvice(soap, (const struct bmd230__SendAdvice *)ptr);
		break;
	case SOAP_TYPE_bmd230__SendAdviceResponse:
		soap_serialize_bmd230__SendAdviceResponse(soap, (const struct bmd230__SendAdviceResponse *)ptr);
		break;
	case SOAP_TYPE_bmd230__verifyInvoiceWithDetailsById:
		soap_serialize_bmd230__verifyInvoiceWithDetailsById(soap, (const struct bmd230__verifyInvoiceWithDetailsById *)ptr);
		break;
	case SOAP_TYPE_bmd230__verifyInvoiceWithDetailsByIdResponse:
		soap_serialize_bmd230__verifyInvoiceWithDetailsByIdResponse(soap, (const struct bmd230__verifyInvoiceWithDetailsByIdResponse *)ptr);
		break;
	case SOAP_TYPE_bmd230__verifyInvoiceById:
		soap_serialize_bmd230__verifyInvoiceById(soap, (const struct bmd230__verifyInvoiceById *)ptr);
		break;
	case SOAP_TYPE_bmd230__verifyInvoiceByIdResponse:
		soap_serialize_bmd230__verifyInvoiceByIdResponse(soap, (const struct bmd230__verifyInvoiceByIdResponse *)ptr);
		break;
	case SOAP_TYPE_bmd230__getHTMLImageById:
		soap_serialize_bmd230__getHTMLImageById(soap, (const struct bmd230__getHTMLImageById *)ptr);
		break;
	case SOAP_TYPE_bmd230__getHTMLImageByIdResponse:
		soap_serialize_bmd230__getHTMLImageByIdResponse(soap, (const struct bmd230__getHTMLImageByIdResponse *)ptr);
		break;
	case SOAP_TYPE_bmd230__getInvoicePackById:
		soap_serialize_bmd230__getInvoicePackById(soap, (const struct bmd230__getInvoicePackById *)ptr);
		break;
	case SOAP_TYPE_bmd230__getInvoicePackByIdResponse:
		soap_serialize_bmd230__getInvoicePackByIdResponse(soap, (const struct bmd230__getInvoicePackByIdResponse *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdGetActionsHistoryById:
		soap_serialize_bmd230__bmdGetActionsHistoryById(soap, (const struct bmd230__bmdGetActionsHistoryById *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdGetActionsHistoryByIdResponse:
		soap_serialize_bmd230__bmdGetActionsHistoryByIdResponse(soap, (const struct bmd230__bmdGetActionsHistoryByIdResponse *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdGetVersionsHistory:
		soap_serialize_bmd230__bmdGetVersionsHistory(soap, (const struct bmd230__bmdGetVersionsHistory *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdGetVersionsHistoryResponse:
		soap_serialize_bmd230__bmdGetVersionsHistoryResponse(soap, (const struct bmd230__bmdGetVersionsHistoryResponse *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdGetAccessObjects:
		soap_serialize_bmd230__bmdGetAccessObjects(soap, (const struct bmd230__bmdGetAccessObjects *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdGetAccessObjectsResponse:
		soap_serialize_bmd230__bmdGetAccessObjectsResponse(soap, (const struct bmd230__bmdGetAccessObjectsResponse *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdGetArchPack:
		soap_serialize_bmd230__bmdGetArchPack(soap, (const struct bmd230__bmdGetArchPack *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdGetArchPackResponse:
		soap_serialize_bmd230__bmdGetArchPackResponse(soap, (const struct bmd230__bmdGetArchPackResponse *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdGetTimeStamp:
		soap_serialize_bmd230__bmdGetTimeStamp(soap, (const struct bmd230__bmdGetTimeStamp *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdGetTimeStampResponse:
		soap_serialize_bmd230__bmdGetTimeStampResponse(soap, (const struct bmd230__bmdGetTimeStampResponse *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdGetFilePKIById:
		soap_serialize_bmd230__bmdGetFilePKIById(soap, (const struct bmd230__bmdGetFilePKIById *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdGetFilePKIByIdResponse:
		soap_serialize_bmd230__bmdGetFilePKIByIdResponse(soap, (const struct bmd230__bmdGetFilePKIByIdResponse *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdGetFilePropByID:
		soap_serialize_bmd230__bmdGetFilePropByID(soap, (const struct bmd230__bmdGetFilePropByID *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdGetFilePropByIDResponse:
		soap_serialize_bmd230__bmdGetFilePropByIDResponse(soap, (const struct bmd230__bmdGetFilePropByIDResponse *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdGetFileByIdInZipPack:
		soap_serialize_bmd230__bmdGetFileByIdInZipPack(soap, (const struct bmd230__bmdGetFileByIdInZipPack *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdGetFileByIdInZipPackResponse:
		soap_serialize_bmd230__bmdGetFileByIdInZipPackResponse(soap, (const struct bmd230__bmdGetFileByIdInZipPackResponse *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdGetFileByHash:
		soap_serialize_bmd230__bmdGetFileByHash(soap, (const struct bmd230__bmdGetFileByHash *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdGetFileByHashResponse:
		soap_serialize_bmd230__bmdGetFileByHashResponse(soap, (const struct bmd230__bmdGetFileByHashResponse *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdGetArchiveFileVersion:
		soap_serialize_bmd230__bmdGetArchiveFileVersion(soap, (const struct bmd230__bmdGetArchiveFileVersion *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdGetArchiveFileVersionResponse:
		soap_serialize_bmd230__bmdGetArchiveFileVersionResponse(soap, (const struct bmd230__bmdGetArchiveFileVersionResponse *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdGetFileById:
		soap_serialize_bmd230__bmdGetFileById(soap, (const struct bmd230__bmdGetFileById *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdGetFileByIdResponse:
		soap_serialize_bmd230__bmdGetFileByIdResponse(soap, (const struct bmd230__bmdGetFileByIdResponse *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdGetSecurityList:
		soap_serialize_bmd230__bmdGetSecurityList(soap, (const struct bmd230__bmdGetSecurityList *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdGetSecurityListResponse:
		soap_serialize_bmd230__bmdGetSecurityListResponse(soap, (const struct bmd230__bmdGetSecurityListResponse *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdRegisterNewSecurityCategory:
		soap_serialize_bmd230__bmdRegisterNewSecurityCategory(soap, (const struct bmd230__bmdRegisterNewSecurityCategory *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdRegisterNewSecurityCategoryResponse:
		soap_serialize_bmd230__bmdRegisterNewSecurityCategoryResponse(soap, (const struct bmd230__bmdRegisterNewSecurityCategoryResponse *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdDeleteClass:
		soap_serialize_bmd230__bmdDeleteClass(soap, (const struct bmd230__bmdDeleteClass *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdDeleteClassResponse:
		soap_serialize_bmd230__bmdDeleteClassResponse(soap, (const struct bmd230__bmdDeleteClassResponse *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdGetClassList:
		soap_serialize_bmd230__bmdGetClassList(soap, (const struct bmd230__bmdGetClassList *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdGetClassListResponse:
		soap_serialize_bmd230__bmdGetClassListResponse(soap, (const struct bmd230__bmdGetClassListResponse *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdUpdateClass:
		soap_serialize_bmd230__bmdUpdateClass(soap, (const struct bmd230__bmdUpdateClass *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdUpdateClassResponse:
		soap_serialize_bmd230__bmdUpdateClassResponse(soap, (const struct bmd230__bmdUpdateClassResponse *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdRegisterNewClass:
		soap_serialize_bmd230__bmdRegisterNewClass(soap, (const struct bmd230__bmdRegisterNewClass *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdRegisterNewClassResponse:
		soap_serialize_bmd230__bmdRegisterNewClassResponse(soap, (const struct bmd230__bmdRegisterNewClassResponse *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdDeleteGroup:
		soap_serialize_bmd230__bmdDeleteGroup(soap, (const struct bmd230__bmdDeleteGroup *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdDeleteGroupResponse:
		soap_serialize_bmd230__bmdDeleteGroupResponse(soap, (const struct bmd230__bmdDeleteGroupResponse *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdGetGroupsList:
		soap_serialize_bmd230__bmdGetGroupsList(soap, (const struct bmd230__bmdGetGroupsList *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdGetGroupsListResponse:
		soap_serialize_bmd230__bmdGetGroupsListResponse(soap, (const struct bmd230__bmdGetGroupsListResponse *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdUpdateGroup:
		soap_serialize_bmd230__bmdUpdateGroup(soap, (const struct bmd230__bmdUpdateGroup *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdUpdateGroupResponse:
		soap_serialize_bmd230__bmdUpdateGroupResponse(soap, (const struct bmd230__bmdUpdateGroupResponse *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdRegisterNewGroup:
		soap_serialize_bmd230__bmdRegisterNewGroup(soap, (const struct bmd230__bmdRegisterNewGroup *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdRegisterNewGroupResponse:
		soap_serialize_bmd230__bmdRegisterNewGroupResponse(soap, (const struct bmd230__bmdRegisterNewGroupResponse *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdDeleteRole:
		soap_serialize_bmd230__bmdDeleteRole(soap, (const struct bmd230__bmdDeleteRole *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdDeleteRoleResponse:
		soap_serialize_bmd230__bmdDeleteRoleResponse(soap, (const struct bmd230__bmdDeleteRoleResponse *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdGetRolesList:
		soap_serialize_bmd230__bmdGetRolesList(soap, (const struct bmd230__bmdGetRolesList *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdGetRolesListResponse:
		soap_serialize_bmd230__bmdGetRolesListResponse(soap, (const struct bmd230__bmdGetRolesListResponse *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdUpdateRole:
		soap_serialize_bmd230__bmdUpdateRole(soap, (const struct bmd230__bmdUpdateRole *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdUpdateRoleResponse:
		soap_serialize_bmd230__bmdUpdateRoleResponse(soap, (const struct bmd230__bmdUpdateRoleResponse *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdRegisterNewRole:
		soap_serialize_bmd230__bmdRegisterNewRole(soap, (const struct bmd230__bmdRegisterNewRole *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdRegisterNewRoleResponse:
		soap_serialize_bmd230__bmdRegisterNewRoleResponse(soap, (const struct bmd230__bmdRegisterNewRoleResponse *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdDisableIdentity:
		soap_serialize_bmd230__bmdDisableIdentity(soap, (const struct bmd230__bmdDisableIdentity *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdDisableIdentityResponse:
		soap_serialize_bmd230__bmdDisableIdentityResponse(soap, (const struct bmd230__bmdDisableIdentityResponse *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdDisableUser:
		soap_serialize_bmd230__bmdDisableUser(soap, (const struct bmd230__bmdDisableUser *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdDisableUserResponse:
		soap_serialize_bmd230__bmdDisableUserResponse(soap, (const struct bmd230__bmdDisableUserResponse *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdDeleteUser:
		soap_serialize_bmd230__bmdDeleteUser(soap, (const struct bmd230__bmdDeleteUser *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdDeleteUserResponse:
		soap_serialize_bmd230__bmdDeleteUserResponse(soap, (const struct bmd230__bmdDeleteUserResponse *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdGetUsersList:
		soap_serialize_bmd230__bmdGetUsersList(soap, (const struct bmd230__bmdGetUsersList *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdGetUsersListResponse:
		soap_serialize_bmd230__bmdGetUsersListResponse(soap, (const struct bmd230__bmdGetUsersListResponse *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdUpdateUserRights:
		soap_serialize_bmd230__bmdUpdateUserRights(soap, (const struct bmd230__bmdUpdateUserRights *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdUpdateUserRightsResponse:
		soap_serialize_bmd230__bmdUpdateUserRightsResponse(soap, (const struct bmd230__bmdUpdateUserRightsResponse *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdAddCertificateToIdentity:
		soap_serialize_bmd230__bmdAddCertificateToIdentity(soap, (const struct bmd230__bmdAddCertificateToIdentity *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdAddCertificateToIdentityResponse:
		soap_serialize_bmd230__bmdAddCertificateToIdentityResponse(soap, (const struct bmd230__bmdAddCertificateToIdentityResponse *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdRegisterNewUser:
		soap_serialize_bmd230__bmdRegisterNewUser(soap, (const struct bmd230__bmdRegisterNewUser *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdRegisterNewUserResponse:
		soap_serialize_bmd230__bmdRegisterNewUserResponse(soap, (const struct bmd230__bmdRegisterNewUserResponse *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdSearchUnreceived:
		soap_serialize_bmd230__bmdSearchUnreceived(soap, (const struct bmd230__bmdSearchUnreceived *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdSearchUnreceivedResponse:
		soap_serialize_bmd230__bmdSearchUnreceivedResponse(soap, (const struct bmd230__bmdSearchUnreceivedResponse *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdHistory:
		soap_serialize_bmd230__bmdHistory(soap, (const struct bmd230__bmdHistory *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdHistoryResponse:
		soap_serialize_bmd230__bmdHistoryResponse(soap, (const struct bmd230__bmdHistoryResponse *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdAdvancedCountFiles:
		soap_serialize_bmd230__bmdAdvancedCountFiles(soap, (const struct bmd230__bmdAdvancedCountFiles *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdAdvancedCountFilesResponse:
		soap_serialize_bmd230__bmdAdvancedCountFilesResponse(soap, (const struct bmd230__bmdAdvancedCountFilesResponse *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdAdvancedSearchFiles:
		soap_serialize_bmd230__bmdAdvancedSearchFiles(soap, (const struct bmd230__bmdAdvancedSearchFiles *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdAdvancedSearchFilesResponse:
		soap_serialize_bmd230__bmdAdvancedSearchFilesResponse(soap, (const struct bmd230__bmdAdvancedSearchFilesResponse *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdSearchFilesCSV:
		soap_serialize_bmd230__bmdSearchFilesCSV(soap, (const struct bmd230__bmdSearchFilesCSV *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdSearchFilesCSVResponse:
		soap_serialize_bmd230__bmdSearchFilesCSVResponse(soap, (const struct bmd230__bmdSearchFilesCSVResponse *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdSearchFiles:
		soap_serialize_bmd230__bmdSearchFiles(soap, (const struct bmd230__bmdSearchFiles *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdSearchFilesResponse:
		soap_serialize_bmd230__bmdSearchFilesResponse(soap, (const struct bmd230__bmdSearchFilesResponse *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdLogin:
		soap_serialize_bmd230__bmdLogin(soap, (const struct bmd230__bmdLogin *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdLoginResponse:
		soap_serialize_bmd230__bmdLoginResponse(soap, (const struct bmd230__bmdLoginResponse *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdAddSignature:
		soap_serialize_bmd230__bmdAddSignature(soap, (const struct bmd230__bmdAddSignature *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdAddSignatureResponse:
		soap_serialize_bmd230__bmdAddSignatureResponse(soap, (const struct bmd230__bmdAddSignatureResponse *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdUpdateDefaultMetadataValue:
		soap_serialize_bmd230__bmdUpdateDefaultMetadataValue(soap, (const struct bmd230__bmdUpdateDefaultMetadataValue *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdUpdateDefaultMetadataValueResponse:
		soap_serialize_bmd230__bmdUpdateDefaultMetadataValueResponse(soap, (const struct bmd230__bmdUpdateDefaultMetadataValueResponse *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdUpdateSystemMetadata:
		soap_serialize_bmd230__bmdUpdateSystemMetadata(soap, (const struct bmd230__bmdUpdateSystemMetadata *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdUpdateSystemMetadataResponse:
		soap_serialize_bmd230__bmdUpdateSystemMetadataResponse(soap, (const struct bmd230__bmdUpdateSystemMetadataResponse *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdUpdateMetadata:
		soap_serialize_bmd230__bmdUpdateMetadata(soap, (const struct bmd230__bmdUpdateMetadata *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdUpdateMetadataResponse:
		soap_serialize_bmd230__bmdUpdateMetadataResponse(soap, (const struct bmd230__bmdUpdateMetadataResponse *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdDeleteDirByID:
		soap_serialize_bmd230__bmdDeleteDirByID(soap, (const struct bmd230__bmdDeleteDirByID *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdDeleteDirByIDResponse:
		soap_serialize_bmd230__bmdDeleteDirByIDResponse(soap, (const struct bmd230__bmdDeleteDirByIDResponse *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdDeleteFileByID:
		soap_serialize_bmd230__bmdDeleteFileByID(soap, (const struct bmd230__bmdDeleteFileByID *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdDeleteFileByIDResponse:
		soap_serialize_bmd230__bmdDeleteFileByIDResponse(soap, (const struct bmd230__bmdDeleteFileByIDResponse *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdUpdateFileVersion:
		soap_serialize_bmd230__bmdUpdateFileVersion(soap, (const struct bmd230__bmdUpdateFileVersion *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdUpdateFileVersionResponse:
		soap_serialize_bmd230__bmdUpdateFileVersionResponse(soap, (const struct bmd230__bmdUpdateFileVersionResponse *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdInsertFileList:
		soap_serialize_bmd230__bmdInsertFileList(soap, (const struct bmd230__bmdInsertFileList *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdInsertFileListResponse:
		soap_serialize_bmd230__bmdInsertFileListResponse(soap, (const struct bmd230__bmdInsertFileListResponse *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdInsertSignedFile:
		soap_serialize_bmd230__bmdInsertSignedFile(soap, (const struct bmd230__bmdInsertSignedFile *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdInsertSignedFileResponse:
		soap_serialize_bmd230__bmdInsertSignedFileResponse(soap, (const struct bmd230__bmdInsertSignedFileResponse *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdInsertFile:
		soap_serialize_bmd230__bmdInsertFile(soap, (const struct bmd230__bmdInsertFile *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdInsertFileResponse:
		soap_serialize_bmd230__bmdInsertFileResponse(soap, (const struct bmd230__bmdInsertFileResponse *)ptr);
		break;
	case SOAP_TYPE_bmd230__testConnection:
		soap_serialize_bmd230__testConnection(soap, (const struct bmd230__testConnection *)ptr);
		break;
	case SOAP_TYPE_bmd230__testConnectionResponse:
		soap_serialize_bmd230__testConnectionResponse(soap, (const struct bmd230__testConnectionResponse *)ptr);
		break;
	case SOAP_TYPE_bmd230__ActionsHistoryList:
		soap_serialize_bmd230__ActionsHistoryList(soap, (const struct bmd230__ActionsHistoryList *)ptr);
		break;
	case SOAP_TYPE_bmd230__ActionsHistoryElement:
		soap_serialize_bmd230__ActionsHistoryElement(soap, (const struct bmd230__ActionsHistoryElement *)ptr);
		break;
	case SOAP_TYPE_bmd230__GetVersionsHistoryResultList:
		soap_serialize_bmd230__GetVersionsHistoryResultList(soap, (const struct bmd230__GetVersionsHistoryResultList *)ptr);
		break;
	case SOAP_TYPE_bmd230__GetVersionsHistoryResult:
		soap_serialize_bmd230__GetVersionsHistoryResult(soap, (const struct bmd230__GetVersionsHistoryResult *)ptr);
		break;
	case SOAP_TYPE_bmd230__FileVersionInfoList:
		soap_serialize_bmd230__FileVersionInfoList(soap, (const struct bmd230__FileVersionInfoList *)ptr);
		break;
	case SOAP_TYPE_bmd230__FileVersionInfo:
		soap_serialize_bmd230__FileVersionInfo(soap, (const struct bmd230__FileVersionInfo *)ptr);
		break;
	case SOAP_TYPE_bmd230__accessObjectList:
		soap_serialize_bmd230__accessObjectList(soap, (const struct bmd230__accessObjectList *)ptr);
		break;
	case SOAP_TYPE_bmd230__accessObject:
		soap_serialize_bmd230__accessObject(soap, (const struct bmd230__accessObject *)ptr);
		break;
	case SOAP_TYPE_bmd230__archPackOut:
		soap_serialize_bmd230__archPackOut(soap, (const struct bmd230__archPackOut *)ptr);
		break;
	case SOAP_TYPE_bmd230__deleteCascadeLinksList:
		soap_serialize_bmd230__deleteCascadeLinksList(soap, (const struct bmd230__deleteCascadeLinksList *)ptr);
		break;
	case SOAP_TYPE_bmd230__deleteCascadeLinksElement:
		soap_serialize_bmd230__deleteCascadeLinksElement(soap, (const struct bmd230__deleteCascadeLinksElement *)ptr);
		break;
	case SOAP_TYPE_bmd230__manyCascadeLinksResult:
		soap_serialize_bmd230__manyCascadeLinksResult(soap, (const struct bmd230__manyCascadeLinksResult *)ptr);
		break;
	case SOAP_TYPE_bmd230__manyCascadeLinksElement:
		soap_serialize_bmd230__manyCascadeLinksElement(soap, (const struct bmd230__manyCascadeLinksElement *)ptr);
		break;
	case SOAP_TYPE_bmd230__cascadeLinksInfo:
		soap_serialize_bmd230__cascadeLinksInfo(soap, (const struct bmd230__cascadeLinksInfo *)ptr);
		break;
	case SOAP_TYPE_bmd230__singleCascadeLinkInfo:
		soap_serialize_bmd230__singleCascadeLinkInfo(soap, (const struct bmd230__singleCascadeLinkInfo *)ptr);
		break;
	case SOAP_TYPE_bmd230__linksInfo:
		soap_serialize_bmd230__linksInfo(soap, (const struct bmd230__linksInfo *)ptr);
		break;
	case SOAP_TYPE_bmd230__DateTime:
		soap_serialize_bmd230__DateTime(soap, (const struct bmd230__DateTime *)ptr);
		break;
	case SOAP_TYPE_bmd230__singleLinkInfo:
		soap_serialize_bmd230__singleLinkInfo(soap, (const struct bmd230__singleLinkInfo *)ptr);
		break;
	case SOAP_TYPE_bmd230__securityInfo:
		soap_serialize_bmd230__securityInfo(soap, (const struct bmd230__securityInfo *)ptr);
		break;
	case SOAP_TYPE_bmd230__secLevelInfo:
		soap_serialize_bmd230__secLevelInfo(soap, (const struct bmd230__secLevelInfo *)ptr);
		break;
	case SOAP_TYPE_bmd230__singleSecLevelInfo:
		soap_serialize_bmd230__singleSecLevelInfo(soap, (const struct bmd230__singleSecLevelInfo *)ptr);
		break;
	case SOAP_TYPE_bmd230__secCategoryInfo:
		soap_serialize_bmd230__secCategoryInfo(soap, (const struct bmd230__secCategoryInfo *)ptr);
		break;
	case SOAP_TYPE_bmd230__singleSecCategoryInfo:
		soap_serialize_bmd230__singleSecCategoryInfo(soap, (const struct bmd230__singleSecCategoryInfo *)ptr);
		break;
	case SOAP_TYPE_bmd230__classInfo:
		soap_serialize_bmd230__classInfo(soap, (const struct bmd230__classInfo *)ptr);
		break;
	case SOAP_TYPE_bmd230__singleClassInfo:
		soap_serialize_bmd230__singleClassInfo(soap, (const struct bmd230__singleClassInfo *)ptr);
		break;
	case SOAP_TYPE_bmd230__groupInfo:
		soap_serialize_bmd230__groupInfo(soap, (const struct bmd230__groupInfo *)ptr);
		break;
	case SOAP_TYPE_bmd230__singleGroupInfo:
		soap_serialize_bmd230__singleGroupInfo(soap, (const struct bmd230__singleGroupInfo *)ptr);
		break;
	case SOAP_TYPE_bmd230__userRoleInfo:
		soap_serialize_bmd230__userRoleInfo(soap, (const struct bmd230__userRoleInfo *)ptr);
		break;
	case SOAP_TYPE_bmd230__singleRoleInfo:
		soap_serialize_bmd230__singleRoleInfo(soap, (const struct bmd230__singleRoleInfo *)ptr);
		break;
	case SOAP_TYPE_bmd230__loginResponse:
		soap_serialize_bmd230__loginResponse(soap, (const struct bmd230__loginResponse *)ptr);
		break;
	case SOAP_TYPE_bmd230__userRegistrationResult:
		soap_serialize_bmd230__userRegistrationResult(soap, (const struct bmd230__userRegistrationResult *)ptr);
		break;
	case SOAP_TYPE_bmd230__userListInfo:
		soap_serialize_bmd230__userListInfo(soap, (const struct bmd230__userListInfo *)ptr);
		break;
	case SOAP_TYPE_bmd230__singleUserInfo:
		soap_serialize_bmd230__singleUserInfo(soap, (const struct bmd230__singleUserInfo *)ptr);
		break;
	case SOAP_TYPE_bmd230__userNewGroupInfo:
		soap_serialize_bmd230__userNewGroupInfo(soap, (const struct bmd230__userNewGroupInfo *)ptr);
		break;
	case SOAP_TYPE_bmd230__stringList:
		soap_serialize_bmd230__stringList(soap, (const struct bmd230__stringList *)ptr);
		break;
	case SOAP_TYPE_bmd230__mtdsSearchValues:
		soap_serialize_bmd230__mtdsSearchValues(soap, (const struct bmd230__mtdsSearchValues *)ptr);
		break;
	case SOAP_TYPE_bmd230__mtdSearchSingleValue:
		soap_serialize_bmd230__mtdSearchSingleValue(soap, (const struct bmd230__mtdSearchSingleValue *)ptr);
		break;
	case SOAP_TYPE_bmd230__bmdTimestamp:
		soap_serialize_bmd230__bmdTimestamp(soap, (const struct bmd230__bmdTimestamp *)ptr);
		break;
	case SOAP_TYPE_bmd230__historyResults:
		soap_serialize_bmd230__historyResults(soap, (const struct bmd230__historyResults *)ptr);
		break;
	case SOAP_TYPE_bmd230__historySingleResult:
		soap_serialize_bmd230__historySingleResult(soap, (const struct bmd230__historySingleResult *)ptr);
		break;
	case SOAP_TYPE_bmd230__searchResults:
		soap_serialize_bmd230__searchResults(soap, (const struct bmd230__searchResults *)ptr);
		break;
	case SOAP_TYPE_bmd230__searchSingleResult:
		soap_serialize_bmd230__searchSingleResult(soap, (const struct bmd230__searchSingleResult *)ptr);
		break;
	case SOAP_TYPE_bmd230__mtdsInfo:
		soap_serialize_bmd230__mtdsInfo(soap, (const struct bmd230__mtdsInfo *)ptr);
		break;
	case SOAP_TYPE_bmd230__mtdSingleInfo:
		soap_serialize_bmd230__mtdSingleInfo(soap, (const struct bmd230__mtdSingleInfo *)ptr);
		break;
	case SOAP_TYPE_bmd230__searchSortInfoList:
		soap_serialize_bmd230__searchSortInfoList(soap, (const struct bmd230__searchSortInfoList *)ptr);
		break;
	case SOAP_TYPE_bmd230__searchSortInfo:
		soap_serialize_bmd230__searchSortInfo(soap, (const struct bmd230__searchSortInfo *)ptr);
		break;
	case SOAP_TYPE_bmd230__idList:
		soap_serialize_bmd230__idList(soap, (const struct bmd230__idList *)ptr);
		break;
	case SOAP_TYPE_bmd230__fileComplexList:
		soap_serialize_bmd230__fileComplexList(soap, (const struct bmd230__fileComplexList *)ptr);
		break;
	case SOAP_TYPE_bmd230__fileComplex:
		soap_serialize_bmd230__fileComplex(soap, (const struct bmd230__fileComplex *)ptr);
		break;
	case SOAP_TYPE_bmd230__mtdsValues:
		soap_serialize_bmd230__mtdsValues(soap, (const struct bmd230__mtdsValues *)ptr);
		break;
	case SOAP_TYPE_bmd230__mtdSingleValue:
		soap_serialize_bmd230__mtdSingleValue(soap, (const struct bmd230__mtdSingleValue *)ptr);
		break;
	case SOAP_TYPE_bmd230__fileInfoList:
		soap_serialize_bmd230__fileInfoList(soap, (const struct bmd230__fileInfoList *)ptr);
		break;
	case SOAP_TYPE_bmd230__fileInfo:
		soap_serialize_bmd230__fileInfo(soap, (const struct bmd230__fileInfo *)ptr);
		break;
	case SOAP_TYPE_bmd230__PkiFileInfo:
		soap_serialize_bmd230__PkiFileInfo(soap, (const struct bmd230__PkiFileInfo *)ptr);
		break;
	case SOAP_TYPE_bmd230__SignatureList:
		soap_serialize_bmd230__SignatureList(soap, (const struct bmd230__SignatureList *)ptr);
		break;
	case SOAP_TYPE_bmd230__DVCSList:
		soap_serialize_bmd230__DVCSList(soap, (const struct bmd230__DVCSList *)ptr);
		break;
	case SOAP_TYPE_bmd230__SignatureSingle:
		soap_serialize_bmd230__SignatureSingle(soap, (const struct bmd230__SignatureSingle *)ptr);
		break;
	case SOAP_TYPE_bmd230__TimestampList:
		soap_serialize_bmd230__TimestampList(soap, (const struct bmd230__TimestampList *)ptr);
		break;
	case SOAP_TYPE_bmd230__DVCSSingle:
		soap_serialize_bmd230__DVCSSingle(soap, (const struct bmd230__DVCSSingle *)ptr);
		break;
	case SOAP_TYPE_bmd230__TimestampSingle:
		soap_serialize_bmd230__TimestampSingle(soap, (const struct bmd230__TimestampSingle *)ptr);
		break;
	case SOAP_TYPE_bmd230__LongNumbersList:
		soap_serialize_bmd230__LongNumbersList(soap, (const struct bmd230__LongNumbersList *)ptr);
		break;
	case SOAP_TYPE_bmd230__myBinaryDataType:
		soap_serialize_bmd230__myBinaryDataType(soap, (const struct bmd230__myBinaryDataType *)ptr);
		break;
	case SOAP_TYPE_xsd__base64Binary:
		soap_serialize_xsd__base64Binary(soap, (const struct xsd__base64Binary *)ptr);
		break;
	case SOAP_TYPE__wsse__Security:
		soap_serialize__wsse__Security(soap, (const struct _wsse__Security *)ptr);
		break;
	case SOAP_TYPE_ds__RSAKeyValueType:
		soap_serialize_ds__RSAKeyValueType(soap, (const struct ds__RSAKeyValueType *)ptr);
		break;
	case SOAP_TYPE_ds__DSAKeyValueType:
		soap_serialize_ds__DSAKeyValueType(soap, (const struct ds__DSAKeyValueType *)ptr);
		break;
	case SOAP_TYPE_ds__X509IssuerSerialType:
		soap_serialize_ds__X509IssuerSerialType(soap, (const struct ds__X509IssuerSerialType *)ptr);
		break;
	case SOAP_TYPE_ds__X509DataType:
		soap_serialize_ds__X509DataType(soap, (const struct ds__X509DataType *)ptr);
		break;
	case SOAP_TYPE_ds__RetrievalMethodType:
		soap_serialize_ds__RetrievalMethodType(soap, (const struct ds__RetrievalMethodType *)ptr);
		break;
	case SOAP_TYPE_ds__KeyValueType:
		soap_serialize_ds__KeyValueType(soap, (const struct ds__KeyValueType *)ptr);
		break;
	case SOAP_TYPE_ds__DigestMethodType:
		soap_serialize_ds__DigestMethodType(soap, (const struct ds__DigestMethodType *)ptr);
		break;
	case SOAP_TYPE_ds__TransformType:
		soap_serialize_ds__TransformType(soap, (const struct ds__TransformType *)ptr);
		break;
	case SOAP_TYPE__c14n__InclusiveNamespaces:
		soap_serialize__c14n__InclusiveNamespaces(soap, (const struct _c14n__InclusiveNamespaces *)ptr);
		break;
	case SOAP_TYPE_ds__TransformsType:
		soap_serialize_ds__TransformsType(soap, (const struct ds__TransformsType *)ptr);
		break;
	case SOAP_TYPE_ds__ReferenceType:
		soap_serialize_ds__ReferenceType(soap, (const struct ds__ReferenceType *)ptr);
		break;
	case SOAP_TYPE_ds__SignatureMethodType:
		soap_serialize_ds__SignatureMethodType(soap, (const struct ds__SignatureMethodType *)ptr);
		break;
	case SOAP_TYPE_ds__CanonicalizationMethodType:
		soap_serialize_ds__CanonicalizationMethodType(soap, (const struct ds__CanonicalizationMethodType *)ptr);
		break;
	case SOAP_TYPE_ds__KeyInfoType:
		soap_serialize_ds__KeyInfoType(soap, (const struct ds__KeyInfoType *)ptr);
		break;
	case SOAP_TYPE_ds__SignedInfoType:
		soap_serialize_ds__SignedInfoType(soap, (const struct ds__SignedInfoType *)ptr);
		break;
	case SOAP_TYPE_ds__SignatureType:
		soap_serialize_ds__SignatureType(soap, (const struct ds__SignatureType *)ptr);
		break;
	case SOAP_TYPE__wsse__SecurityTokenReference:
		soap_serialize__wsse__SecurityTokenReference(soap, (const struct _wsse__SecurityTokenReference *)ptr);
		break;
	case SOAP_TYPE__wsse__KeyIdentifier:
		soap_serialize__wsse__KeyIdentifier(soap, (const struct _wsse__KeyIdentifier *)ptr);
		break;
	case SOAP_TYPE__wsse__Embedded:
		soap_serialize__wsse__Embedded(soap, (const struct _wsse__Embedded *)ptr);
		break;
	case SOAP_TYPE__wsse__Reference:
		soap_serialize__wsse__Reference(soap, (const struct _wsse__Reference *)ptr);
		break;
	case SOAP_TYPE__wsse__BinarySecurityToken:
		soap_serialize__wsse__BinarySecurityToken(soap, (const struct _wsse__BinarySecurityToken *)ptr);
		break;
	case SOAP_TYPE__wsse__Password:
		soap_serialize__wsse__Password(soap, (const struct _wsse__Password *)ptr);
		break;
	case SOAP_TYPE__wsse__UsernameToken:
		soap_serialize__wsse__UsernameToken(soap, (const struct _wsse__UsernameToken *)ptr);
		break;
	case SOAP_TYPE__wsu__Timestamp:
		soap_serialize__wsu__Timestamp(soap, (const struct _wsu__Timestamp *)ptr);
		break;
	case SOAP_TYPE_PointerTobmd230__deleteCascadeLinksList:
		soap_serialize_PointerTobmd230__deleteCascadeLinksList(soap, (struct bmd230__deleteCascadeLinksList *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTobmd230__manyCascadeLinksResult:
		soap_serialize_PointerToPointerTobmd230__manyCascadeLinksResult(soap, (struct bmd230__manyCascadeLinksResult **const*)ptr);
		break;
	case SOAP_TYPE_PointerTobmd230__manyCascadeLinksResult:
		soap_serialize_PointerTobmd230__manyCascadeLinksResult(soap, (struct bmd230__manyCascadeLinksResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobmd230__cascadeLinksInfo:
		soap_serialize_PointerTobmd230__cascadeLinksInfo(soap, (struct bmd230__cascadeLinksInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobmd230__linksInfo:
		soap_serialize_PointerTobmd230__linksInfo(soap, (struct bmd230__linksInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTobmd230__archPackOut:
		soap_serialize_PointerToPointerTobmd230__archPackOut(soap, (struct bmd230__archPackOut **const*)ptr);
		break;
	case SOAP_TYPE_PointerTobmd230__archPackOut:
		soap_serialize_PointerTobmd230__archPackOut(soap, (struct bmd230__archPackOut *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTobmd230__fileInfoList:
		soap_serialize_PointerToPointerTobmd230__fileInfoList(soap, (struct bmd230__fileInfoList **const*)ptr);
		break;
	case SOAP_TYPE_PointerTobmd230__fileInfoList:
		soap_serialize_PointerTobmd230__fileInfoList(soap, (struct bmd230__fileInfoList *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTobmd230__stringList:
		soap_serialize_PointerToPointerTobmd230__stringList(soap, (struct bmd230__stringList **const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTobmd230__ActionsHistoryList:
		soap_serialize_PointerToPointerTobmd230__ActionsHistoryList(soap, (struct bmd230__ActionsHistoryList **const*)ptr);
		break;
	case SOAP_TYPE_PointerTobmd230__ActionsHistoryList:
		soap_serialize_PointerTobmd230__ActionsHistoryList(soap, (struct bmd230__ActionsHistoryList *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTobmd230__GetVersionsHistoryResultList:
		soap_serialize_PointerToPointerTobmd230__GetVersionsHistoryResultList(soap, (struct bmd230__GetVersionsHistoryResultList **const*)ptr);
		break;
	case SOAP_TYPE_PointerTobmd230__GetVersionsHistoryResultList:
		soap_serialize_PointerTobmd230__GetVersionsHistoryResultList(soap, (struct bmd230__GetVersionsHistoryResultList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobmd230__LongNumbersList:
		soap_serialize_PointerTobmd230__LongNumbersList(soap, (struct bmd230__LongNumbersList *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTobmd230__accessObjectList:
		soap_serialize_PointerToPointerTobmd230__accessObjectList(soap, (struct bmd230__accessObjectList **const*)ptr);
		break;
	case SOAP_TYPE_PointerTobmd230__accessObjectList:
		soap_serialize_PointerTobmd230__accessObjectList(soap, (struct bmd230__accessObjectList *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTobmd230__bmdTimestamp:
		soap_serialize_PointerToPointerTobmd230__bmdTimestamp(soap, (struct bmd230__bmdTimestamp **const*)ptr);
		break;
	case SOAP_TYPE_PointerTobmd230__bmdTimestamp:
		soap_serialize_PointerTobmd230__bmdTimestamp(soap, (struct bmd230__bmdTimestamp *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTobmd230__PkiFileInfo:
		soap_serialize_PointerToPointerTobmd230__PkiFileInfo(soap, (struct bmd230__PkiFileInfo **const*)ptr);
		break;
	case SOAP_TYPE_PointerTobmd230__PkiFileInfo:
		soap_serialize_PointerTobmd230__PkiFileInfo(soap, (struct bmd230__PkiFileInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTobmd230__securityInfo:
		soap_serialize_PointerToPointerTobmd230__securityInfo(soap, (struct bmd230__securityInfo **const*)ptr);
		break;
	case SOAP_TYPE_PointerTobmd230__securityInfo:
		soap_serialize_PointerTobmd230__securityInfo(soap, (struct bmd230__securityInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTobmd230__classInfo:
		soap_serialize_PointerToPointerTobmd230__classInfo(soap, (struct bmd230__classInfo **const*)ptr);
		break;
	case SOAP_TYPE_PointerTobmd230__classInfo:
		soap_serialize_PointerTobmd230__classInfo(soap, (struct bmd230__classInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTobmd230__groupInfo:
		soap_serialize_PointerToPointerTobmd230__groupInfo(soap, (struct bmd230__groupInfo **const*)ptr);
		break;
	case SOAP_TYPE_PointerTobmd230__groupInfo:
		soap_serialize_PointerTobmd230__groupInfo(soap, (struct bmd230__groupInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTobmd230__userRoleInfo:
		soap_serialize_PointerToPointerTobmd230__userRoleInfo(soap, (struct bmd230__userRoleInfo **const*)ptr);
		break;
	case SOAP_TYPE_PointerTobmd230__userRoleInfo:
		soap_serialize_PointerTobmd230__userRoleInfo(soap, (struct bmd230__userRoleInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTobmd230__userListInfo:
		soap_serialize_PointerToPointerTobmd230__userListInfo(soap, (struct bmd230__userListInfo **const*)ptr);
		break;
	case SOAP_TYPE_PointerTobmd230__userListInfo:
		soap_serialize_PointerTobmd230__userListInfo(soap, (struct bmd230__userListInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTobmd230__userRegistrationResult:
		soap_serialize_PointerToPointerTobmd230__userRegistrationResult(soap, (struct bmd230__userRegistrationResult **const*)ptr);
		break;
	case SOAP_TYPE_PointerTobmd230__userRegistrationResult:
		soap_serialize_PointerTobmd230__userRegistrationResult(soap, (struct bmd230__userRegistrationResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTobmd230__historyResults:
		soap_serialize_PointerToPointerTobmd230__historyResults(soap, (struct bmd230__historyResults **const*)ptr);
		break;
	case SOAP_TYPE_PointerTobmd230__historyResults:
		soap_serialize_PointerTobmd230__historyResults(soap, (struct bmd230__historyResults *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobmd230__mtdsSearchValues:
		soap_serialize_PointerTobmd230__mtdsSearchValues(soap, (struct bmd230__mtdsSearchValues *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTobmd230__fileInfo:
		soap_serialize_PointerToPointerTobmd230__fileInfo(soap, (struct bmd230__fileInfo **const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTobmd230__searchResults:
		soap_serialize_PointerToPointerTobmd230__searchResults(soap, (struct bmd230__searchResults **const*)ptr);
		break;
	case SOAP_TYPE_PointerTobmd230__searchResults:
		soap_serialize_PointerTobmd230__searchResults(soap, (struct bmd230__searchResults *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobmd230__searchSortInfoList:
		soap_serialize_PointerTobmd230__searchSortInfoList(soap, (struct bmd230__searchSortInfoList *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTobmd230__loginResponse:
		soap_serialize_PointerToPointerTobmd230__loginResponse(soap, (struct bmd230__loginResponse **const*)ptr);
		break;
	case SOAP_TYPE_PointerTobmd230__loginResponse:
		soap_serialize_PointerTobmd230__loginResponse(soap, (struct bmd230__loginResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTobmd230__idList:
		soap_serialize_PointerToPointerTobmd230__idList(soap, (struct bmd230__idList **const*)ptr);
		break;
	case SOAP_TYPE_PointerTobmd230__fileComplexList:
		soap_serialize_PointerTobmd230__fileComplexList(soap, (struct bmd230__fileComplexList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostring:
		soap_serialize_PointerTostring(soap, (char **const*)ptr);
		break;
	case SOAP_TYPE_PointerTobmd230__ActionsHistoryElement:
		soap_serialize_PointerTobmd230__ActionsHistoryElement(soap, (struct bmd230__ActionsHistoryElement *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobmd230__GetVersionsHistoryResult:
		soap_serialize_PointerTobmd230__GetVersionsHistoryResult(soap, (struct bmd230__GetVersionsHistoryResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobmd230__FileVersionInfoList:
		soap_serialize_PointerTobmd230__FileVersionInfoList(soap, (struct bmd230__FileVersionInfoList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobmd230__FileVersionInfo:
		soap_serialize_PointerTobmd230__FileVersionInfo(soap, (struct bmd230__FileVersionInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobmd230__accessObject:
		soap_serialize_PointerTobmd230__accessObject(soap, (struct bmd230__accessObject *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobmd230__deleteCascadeLinksElement:
		soap_serialize_PointerTobmd230__deleteCascadeLinksElement(soap, (struct bmd230__deleteCascadeLinksElement *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobmd230__manyCascadeLinksElement:
		soap_serialize_PointerTobmd230__manyCascadeLinksElement(soap, (struct bmd230__manyCascadeLinksElement *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobmd230__idList:
		soap_serialize_PointerTobmd230__idList(soap, (struct bmd230__idList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobmd230__singleCascadeLinkInfo:
		soap_serialize_PointerTobmd230__singleCascadeLinkInfo(soap, (struct bmd230__singleCascadeLinkInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobmd230__singleLinkInfo:
		soap_serialize_PointerTobmd230__singleLinkInfo(soap, (struct bmd230__singleLinkInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobmd230__DateTime:
		soap_serialize_PointerTobmd230__DateTime(soap, (struct bmd230__DateTime *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobmd230__secLevelInfo:
		soap_serialize_PointerTobmd230__secLevelInfo(soap, (struct bmd230__secLevelInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobmd230__secCategoryInfo:
		soap_serialize_PointerTobmd230__secCategoryInfo(soap, (struct bmd230__secCategoryInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobmd230__singleSecLevelInfo:
		soap_serialize_PointerTobmd230__singleSecLevelInfo(soap, (struct bmd230__singleSecLevelInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobmd230__singleSecCategoryInfo:
		soap_serialize_PointerTobmd230__singleSecCategoryInfo(soap, (struct bmd230__singleSecCategoryInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobmd230__singleClassInfo:
		soap_serialize_PointerTobmd230__singleClassInfo(soap, (struct bmd230__singleClassInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobmd230__singleGroupInfo:
		soap_serialize_PointerTobmd230__singleGroupInfo(soap, (struct bmd230__singleGroupInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobmd230__singleRoleInfo:
		soap_serialize_PointerTobmd230__singleRoleInfo(soap, (struct bmd230__singleRoleInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobmd230__mtdsInfo:
		soap_serialize_PointerTobmd230__mtdsInfo(soap, (struct bmd230__mtdsInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobmd230__singleUserInfo:
		soap_serialize_PointerTobmd230__singleUserInfo(soap, (struct bmd230__singleUserInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobmd230__userNewGroupInfo:
		soap_serialize_PointerTobmd230__userNewGroupInfo(soap, (struct bmd230__userNewGroupInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobmd230__stringList:
		soap_serialize_PointerTobmd230__stringList(soap, (struct bmd230__stringList *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__string:
		soap_serialize_PointerToxsd__string(soap, (char **const*)ptr);
		break;
	case SOAP_TYPE_PointerTobmd230__mtdSearchSingleValue:
		soap_serialize_PointerTobmd230__mtdSearchSingleValue(soap, (struct bmd230__mtdSearchSingleValue *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobmd230__historySingleResult:
		soap_serialize_PointerTobmd230__historySingleResult(soap, (struct bmd230__historySingleResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobmd230__searchSingleResult:
		soap_serialize_PointerTobmd230__searchSingleResult(soap, (struct bmd230__searchSingleResult *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobmd230__mtdSingleInfo:
		soap_serialize_PointerTobmd230__mtdSingleInfo(soap, (struct bmd230__mtdSingleInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobmd230__searchSortInfo:
		soap_serialize_PointerTobmd230__searchSortInfo(soap, (struct bmd230__searchSortInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobmd230__fileComplex:
		soap_serialize_PointerTobmd230__fileComplex(soap, (struct bmd230__fileComplex *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobmd230__mtdsValues:
		soap_serialize_PointerTobmd230__mtdsValues(soap, (struct bmd230__mtdsValues *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobmd230__mtdSingleValue:
		soap_serialize_PointerTobmd230__mtdSingleValue(soap, (struct bmd230__mtdSingleValue *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobmd230__fileInfo:
		soap_serialize_PointerTobmd230__fileInfo(soap, (struct bmd230__fileInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobmd230__myBinaryDataType:
		soap_serialize_PointerTobmd230__myBinaryDataType(soap, (struct bmd230__myBinaryDataType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobmd230__SignatureList:
		soap_serialize_PointerTobmd230__SignatureList(soap, (struct bmd230__SignatureList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobmd230__SignatureSingle:
		soap_serialize_PointerTobmd230__SignatureSingle(soap, (struct bmd230__SignatureSingle *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobmd230__DVCSSingle:
		soap_serialize_PointerTobmd230__DVCSSingle(soap, (struct bmd230__DVCSSingle *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobmd230__TimestampSingle:
		soap_serialize_PointerTobmd230__TimestampSingle(soap, (struct bmd230__TimestampSingle *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobmd230__DVCSList:
		soap_serialize_PointerTobmd230__DVCSList(soap, (struct bmd230__DVCSList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobmd230__TimestampList:
		soap_serialize_PointerTobmd230__TimestampList(soap, (struct bmd230__TimestampList *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__base64Binary:
		soap_serialize_PointerToxsd__base64Binary(soap, (struct xsd__base64Binary *const*)ptr);
		break;
	case SOAP_TYPE_PointerTolong:
		soap_serialize_PointerTolong(soap, (long *const*)ptr);
		break;
	case SOAP_TYPE_PointerTounsignedByte:
		soap_serialize_PointerTounsignedByte(soap, (unsigned char *const*)ptr);
		break;
	case SOAP_TYPE_xsd__string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_PointerTo_wsse__Security:
		soap_serialize_PointerTo_wsse__Security(soap, (struct _wsse__Security *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__SignatureType:
		soap_serialize_PointerTods__SignatureType(soap, (struct ds__SignatureType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsse__BinarySecurityToken:
		soap_serialize_PointerTo_wsse__BinarySecurityToken(soap, (struct _wsse__BinarySecurityToken *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsse__UsernameToken:
		soap_serialize_PointerTo_wsse__UsernameToken(soap, (struct _wsse__UsernameToken *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsu__Timestamp:
		soap_serialize_PointerTo_wsu__Timestamp(soap, (struct _wsu__Timestamp *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__X509IssuerSerialType:
		soap_serialize_PointerTods__X509IssuerSerialType(soap, (struct ds__X509IssuerSerialType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__RSAKeyValueType:
		soap_serialize_PointerTods__RSAKeyValueType(soap, (struct ds__RSAKeyValueType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__DSAKeyValueType:
		soap_serialize_PointerTods__DSAKeyValueType(soap, (struct ds__DSAKeyValueType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__TransformType:
		soap_serialize_PointerTods__TransformType(soap, (struct ds__TransformType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__DigestMethodType:
		soap_serialize_PointerTods__DigestMethodType(soap, (struct ds__DigestMethodType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__TransformsType:
		soap_serialize_PointerTods__TransformsType(soap, (struct ds__TransformsType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToint:
		soap_serialize_PointerToint(soap, (int *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTods__ReferenceType:
		soap_serialize_PointerToPointerTods__ReferenceType(soap, (struct ds__ReferenceType **const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__ReferenceType:
		soap_serialize_PointerTods__ReferenceType(soap, (struct ds__ReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__SignatureMethodType:
		soap_serialize_PointerTods__SignatureMethodType(soap, (struct ds__SignatureMethodType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__CanonicalizationMethodType:
		soap_serialize_PointerTods__CanonicalizationMethodType(soap, (struct ds__CanonicalizationMethodType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsse__SecurityTokenReference:
		soap_serialize_PointerTo_wsse__SecurityTokenReference(soap, (struct _wsse__SecurityTokenReference *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__X509DataType:
		soap_serialize_PointerTods__X509DataType(soap, (struct ds__X509DataType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__RetrievalMethodType:
		soap_serialize_PointerTods__RetrievalMethodType(soap, (struct ds__RetrievalMethodType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__KeyValueType:
		soap_serialize_PointerTods__KeyValueType(soap, (struct ds__KeyValueType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_c14n__InclusiveNamespaces:
		soap_serialize_PointerTo_c14n__InclusiveNamespaces(soap, (struct _c14n__InclusiveNamespaces *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__KeyInfoType:
		soap_serialize_PointerTods__KeyInfoType(soap, (struct ds__KeyInfoType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTods__SignedInfoType:
		soap_serialize_PointerTods__SignedInfoType(soap, (struct ds__SignedInfoType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsse__Embedded:
		soap_serialize_PointerTo_wsse__Embedded(soap, (struct _wsse__Embedded *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsse__KeyIdentifier:
		soap_serialize_PointerTo_wsse__KeyIdentifier(soap, (struct _wsse__KeyIdentifier *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsse__Reference:
		soap_serialize_PointerTo_wsse__Reference(soap, (struct _wsse__Reference *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsse__Password:
		soap_serialize_PointerTo_wsse__Password(soap, (struct _wsse__Password *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_xsd__int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_xsd__int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_xsd__int);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__int);
	if (soap_out_xsd__int(soap, tag?tag:"xsd:int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_xsd__int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_long(struct soap *soap, long *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_long
	*a = SOAP_DEFAULT_long;
#else
	*a = (long)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_long(struct soap *soap, const char *tag, int id, const long *a, const char *type)
{
	return soap_outlong(soap, tag, id, a, type, SOAP_TYPE_long);
}

SOAP_FMAC3 long * SOAP_FMAC4 soap_in_long(struct soap *soap, const char *tag, long *a, const char *type)
{	long *p;
	p = soap_inlong(soap, tag, a, type, SOAP_TYPE_long);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_long(struct soap *soap, const long *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_long);
	if (soap_out_long(soap, tag?tag:"long", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 long * SOAP_FMAC4 soap_get_long(struct soap *soap, long *p, const char *tag, const char *type)
{
	if ((p = soap_in_long(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedByte(struct soap *soap, unsigned char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedByte
	*a = SOAP_DEFAULT_unsignedByte;
#else
	*a = (unsigned char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedByte(struct soap *soap, const char *tag, int id, const unsigned char *a, const char *type)
{
	return soap_outunsignedByte(soap, tag, id, a, type, SOAP_TYPE_unsignedByte);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_in_unsignedByte(struct soap *soap, const char *tag, unsigned char *a, const char *type)
{	unsigned char *p;
	p = soap_inunsignedByte(soap, tag, a, type, SOAP_TYPE_unsignedByte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedByte(struct soap *soap, const unsigned char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedByte);
	if (soap_out_unsignedByte(soap, tag?tag:"unsignedByte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_get_unsignedByte(struct soap *soap, unsigned char *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedByte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedInt(struct soap *soap, unsigned int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedInt
	*a = SOAP_DEFAULT_unsignedInt;
#else
	*a = (unsigned int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedInt(struct soap *soap, const char *tag, int id, const unsigned int *a, const char *type)
{
	return soap_outunsignedInt(soap, tag, id, a, type, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_in_unsignedInt(struct soap *soap, const char *tag, unsigned int *a, const char *type)
{	unsigned int *p;
	p = soap_inunsignedInt(soap, tag, a, type, SOAP_TYPE_unsignedInt);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedInt(struct soap *soap, const unsigned int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedInt);
	if (soap_out_unsignedInt(soap, tag?tag:"unsignedInt", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_get_unsignedInt(struct soap *soap, unsigned int *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedInt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_groupAuthorizationType_e(struct soap *soap, enum groupAuthorizationType_e *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_groupAuthorizationType_e
	*a = SOAP_DEFAULT_groupAuthorizationType_e;
#else
	*a = (enum groupAuthorizationType_e)0;
#endif
}

static const struct soap_code_map soap_codes_groupAuthorizationType_e[] =
{	{ (long)WITH_DEPENDENT_GROUPS, "WITH-DEPENDENT-GROUPS" },
	{ (long)ONLY_LOGIN_GROUP, "ONLY-LOGIN-GROUP" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_groupAuthorizationType_e2s(struct soap *soap, enum groupAuthorizationType_e n)
{	const char *s = soap_code_str(soap_codes_groupAuthorizationType_e, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_groupAuthorizationType_e(struct soap *soap, const char *tag, int id, const enum groupAuthorizationType_e *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_groupAuthorizationType_e), type) || soap_send(soap, soap_groupAuthorizationType_e2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2groupAuthorizationType_e(struct soap *soap, const char *s, enum groupAuthorizationType_e *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_groupAuthorizationType_e, s);
	if (map)
		*a = (enum groupAuthorizationType_e)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum groupAuthorizationType_e)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum groupAuthorizationType_e * SOAP_FMAC4 soap_in_groupAuthorizationType_e(struct soap *soap, const char *tag, enum groupAuthorizationType_e *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum groupAuthorizationType_e *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_groupAuthorizationType_e, sizeof(enum groupAuthorizationType_e), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2groupAuthorizationType_e(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum groupAuthorizationType_e *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_groupAuthorizationType_e, 0, sizeof(enum groupAuthorizationType_e), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_groupAuthorizationType_e(struct soap *soap, const enum groupAuthorizationType_e *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_groupAuthorizationType_e);
	if (soap_out_groupAuthorizationType_e(soap, tag?tag:"groupAuthorizationType-e", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum groupAuthorizationType_e * SOAP_FMAC4 soap_get_groupAuthorizationType_e(struct soap *soap, enum groupAuthorizationType_e *p, const char *tag, const char *type)
{
	if ((p = soap_in_groupAuthorizationType_e(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_chunkCntr_t(struct soap *soap, enum chunkCntr_t *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_chunkCntr_t
	*a = SOAP_DEFAULT_chunkCntr_t;
#else
	*a = (enum chunkCntr_t)0;
#endif
}

static const struct soap_code_map soap_codes_chunkCntr_t[] =
{	{ (long)start, "start" },
	{ (long)iter, "iter" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_chunkCntr_t2s(struct soap *soap, enum chunkCntr_t n)
{	const char *s = soap_code_str(soap_codes_chunkCntr_t, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_chunkCntr_t(struct soap *soap, const char *tag, int id, const enum chunkCntr_t *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_chunkCntr_t), type) || soap_send(soap, soap_chunkCntr_t2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2chunkCntr_t(struct soap *soap, const char *s, enum chunkCntr_t *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_chunkCntr_t, s);
	if (map)
		*a = (enum chunkCntr_t)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum chunkCntr_t)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum chunkCntr_t * SOAP_FMAC4 soap_in_chunkCntr_t(struct soap *soap, const char *tag, enum chunkCntr_t *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum chunkCntr_t *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_chunkCntr_t, sizeof(enum chunkCntr_t), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2chunkCntr_t(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum chunkCntr_t *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_chunkCntr_t, 0, sizeof(enum chunkCntr_t), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_chunkCntr_t(struct soap *soap, const enum chunkCntr_t *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_chunkCntr_t);
	if (soap_out_chunkCntr_t(soap, tag?tag:"chunkCntr-t", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum chunkCntr_t * SOAP_FMAC4 soap_get_chunkCntr_t(struct soap *soap, enum chunkCntr_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_chunkCntr_t(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_trans_t(struct soap *soap, enum trans_t *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_trans_t
	*a = SOAP_DEFAULT_trans_t;
#else
	*a = (enum trans_t)0;
#endif
}

static const struct soap_code_map soap_codes_trans_t[] =
{	{ (long)nostream, "nostream" },
	{ (long)stream, "stream" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_trans_t2s(struct soap *soap, enum trans_t n)
{	const char *s = soap_code_str(soap_codes_trans_t, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_trans_t(struct soap *soap, const char *tag, int id, const enum trans_t *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_trans_t), type) || soap_send(soap, soap_trans_t2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2trans_t(struct soap *soap, const char *s, enum trans_t *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_trans_t, s);
	if (map)
		*a = (enum trans_t)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum trans_t)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum trans_t * SOAP_FMAC4 soap_in_trans_t(struct soap *soap, const char *tag, enum trans_t *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum trans_t *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_trans_t, sizeof(enum trans_t), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2trans_t(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum trans_t *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_trans_t, 0, sizeof(enum trans_t), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_trans_t(struct soap *soap, const enum trans_t *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_trans_t);
	if (soap_out_trans_t(soap, tag?tag:"trans-t", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum trans_t * SOAP_FMAC4 soap_get_trans_t(struct soap *soap, enum trans_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_trans_t(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_visibilityType_t(struct soap *soap, enum visibilityType_t *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_visibilityType_t
	*a = SOAP_DEFAULT_visibilityType_t;
#else
	*a = (enum visibilityType_t)0;
#endif
}

static const struct soap_code_map soap_codes_visibilityType_t[] =
{	{ (long)VISIBLE, "VISIBLE" },
	{ (long)INVISIBLE, "INVISIBLE" },
	{ (long)ALL, "ALL" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_visibilityType_t2s(struct soap *soap, enum visibilityType_t n)
{	const char *s = soap_code_str(soap_codes_visibilityType_t, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_visibilityType_t(struct soap *soap, const char *tag, int id, const enum visibilityType_t *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_visibilityType_t), type) || soap_send(soap, soap_visibilityType_t2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2visibilityType_t(struct soap *soap, const char *s, enum visibilityType_t *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_visibilityType_t, s);
	if (map)
		*a = (enum visibilityType_t)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 4)))
			return soap->error = SOAP_TYPE;
		*a = (enum visibilityType_t)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum visibilityType_t * SOAP_FMAC4 soap_in_visibilityType_t(struct soap *soap, const char *tag, enum visibilityType_t *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum visibilityType_t *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_visibilityType_t, sizeof(enum visibilityType_t), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2visibilityType_t(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum visibilityType_t *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_visibilityType_t, 0, sizeof(enum visibilityType_t), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_visibilityType_t(struct soap *soap, const enum visibilityType_t *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_visibilityType_t);
	if (soap_out_visibilityType_t(soap, tag?tag:"visibilityType-t", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum visibilityType_t * SOAP_FMAC4 soap_get_visibilityType_t(struct soap *soap, enum visibilityType_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_visibilityType_t(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_grantingType_e(struct soap *soap, enum grantingType_e *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_grantingType_e
	*a = SOAP_DEFAULT_grantingType_e;
#else
	*a = (enum grantingType_e)0;
#endif
}

static const struct soap_code_map soap_codes_grantingType_e[] =
{	{ (long)GRANTING_FORBIDDEN, "GRANTING-FORBIDDEN" },
	{ (long)GRANTING_ALLOWED, "GRANTING-ALLOWED" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_grantingType_e2s(struct soap *soap, enum grantingType_e n)
{	const char *s = soap_code_str(soap_codes_grantingType_e, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_grantingType_e(struct soap *soap, const char *tag, int id, const enum grantingType_e *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_grantingType_e), type) || soap_send(soap, soap_grantingType_e2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2grantingType_e(struct soap *soap, const char *s, enum grantingType_e *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_grantingType_e, s);
	if (map)
		*a = (enum grantingType_e)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum grantingType_e)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum grantingType_e * SOAP_FMAC4 soap_in_grantingType_e(struct soap *soap, const char *tag, enum grantingType_e *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum grantingType_e *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_grantingType_e, sizeof(enum grantingType_e), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2grantingType_e(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum grantingType_e *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_grantingType_e, 0, sizeof(enum grantingType_e), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_grantingType_e(struct soap *soap, const enum grantingType_e *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_grantingType_e);
	if (soap_out_grantingType_e(soap, tag?tag:"grantingType-e", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum grantingType_e * SOAP_FMAC4 soap_get_grantingType_e(struct soap *soap, enum grantingType_e *p, const char *tag, const char *type)
{
	if ((p = soap_in_grantingType_e(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsse__FaultcodeEnum(struct soap *soap, enum wsse__FaultcodeEnum *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_wsse__FaultcodeEnum
	*a = SOAP_DEFAULT_wsse__FaultcodeEnum;
#else
	*a = (enum wsse__FaultcodeEnum)0;
#endif
}

static const struct soap_code_map soap_codes_wsse__FaultcodeEnum[] =
{	{ (long)wsse__UnsupportedSecurityToken, "wsse:UnsupportedSecurityToken" },
	{ (long)wsse__UnsupportedAlgorithm, "wsse:UnsupportedAlgorithm" },
	{ (long)wsse__InvalidSecurity, "wsse:InvalidSecurity" },
	{ (long)wsse__InvalidSecurityToken, "wsse:InvalidSecurityToken" },
	{ (long)wsse__FailedAuthentication, "wsse:FailedAuthentication" },
	{ (long)wsse__FailedCheck, "wsse:FailedCheck" },
	{ (long)wsse__SecurityTokenUnavailable, "wsse:SecurityTokenUnavailable" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wsse__FaultcodeEnum2s(struct soap *soap, enum wsse__FaultcodeEnum n)
{	const char *s = soap_code_str(soap_codes_wsse__FaultcodeEnum, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsse__FaultcodeEnum(struct soap *soap, const char *tag, int id, const enum wsse__FaultcodeEnum *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsse__FaultcodeEnum), type) || soap_send(soap, soap_wsse__FaultcodeEnum2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wsse__FaultcodeEnum(struct soap *soap, const char *s, enum wsse__FaultcodeEnum *a)
{
	const struct soap_code_map *map;
	char *t;
	if (!s)
		return soap->error;
	soap_s2QName(soap, s, &t, -1, -1);
	map = soap_code(soap_codes_wsse__FaultcodeEnum, t);
	if (map)
		*a = (enum wsse__FaultcodeEnum)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 6)))
			return soap->error = SOAP_TYPE;
		*a = (enum wsse__FaultcodeEnum)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wsse__FaultcodeEnum * SOAP_FMAC4 soap_in_wsse__FaultcodeEnum(struct soap *soap, const char *tag, enum wsse__FaultcodeEnum *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wsse__FaultcodeEnum *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsse__FaultcodeEnum, sizeof(enum wsse__FaultcodeEnum), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2wsse__FaultcodeEnum(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum wsse__FaultcodeEnum *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsse__FaultcodeEnum, 0, sizeof(enum wsse__FaultcodeEnum), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsse__FaultcodeEnum(struct soap *soap, const enum wsse__FaultcodeEnum *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsse__FaultcodeEnum);
	if (soap_out_wsse__FaultcodeEnum(soap, tag?tag:"wsse:FaultcodeEnum", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum wsse__FaultcodeEnum * SOAP_FMAC4 soap_get_wsse__FaultcodeEnum(struct soap *soap, enum wsse__FaultcodeEnum *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsse__FaultcodeEnum(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsu__tTimestampFault(struct soap *soap, enum wsu__tTimestampFault *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_wsu__tTimestampFault
	*a = SOAP_DEFAULT_wsu__tTimestampFault;
#else
	*a = (enum wsu__tTimestampFault)0;
#endif
}

static const struct soap_code_map soap_codes_wsu__tTimestampFault[] =
{	{ (long)wsu__MessageExpired, "wsu:MessageExpired" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wsu__tTimestampFault2s(struct soap *soap, enum wsu__tTimestampFault n)
{	const char *s = soap_code_str(soap_codes_wsu__tTimestampFault, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsu__tTimestampFault(struct soap *soap, const char *tag, int id, const enum wsu__tTimestampFault *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsu__tTimestampFault), type) || soap_send(soap, soap_wsu__tTimestampFault2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wsu__tTimestampFault(struct soap *soap, const char *s, enum wsu__tTimestampFault *a)
{
	const struct soap_code_map *map;
	char *t;
	if (!s)
		return soap->error;
	soap_s2QName(soap, s, &t, -1, -1);
	map = soap_code(soap_codes_wsu__tTimestampFault, t);
	if (map)
		*a = (enum wsu__tTimestampFault)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 0)))
			return soap->error = SOAP_TYPE;
		*a = (enum wsu__tTimestampFault)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wsu__tTimestampFault * SOAP_FMAC4 soap_in_wsu__tTimestampFault(struct soap *soap, const char *tag, enum wsu__tTimestampFault *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wsu__tTimestampFault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsu__tTimestampFault, sizeof(enum wsu__tTimestampFault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2wsu__tTimestampFault(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum wsu__tTimestampFault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsu__tTimestampFault, 0, sizeof(enum wsu__tTimestampFault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsu__tTimestampFault(struct soap *soap, const enum wsu__tTimestampFault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsu__tTimestampFault);
	if (soap_out_wsu__tTimestampFault(soap, tag?tag:"wsu:tTimestampFault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum wsu__tTimestampFault * SOAP_FMAC4 soap_get_wsu__tTimestampFault(struct soap *soap, enum wsu__tTimestampFault *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsu__tTimestampFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__type = 0;
	a->fault = NULL;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag_fault = 1;
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdDeleteReplacedLobs(struct soap *soap, struct bmd230__bmdDeleteReplacedLobs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cert = NULL;
	soap_default_string(soap, &a->userRoleId);
	soap_default_string(soap, &a->userGroupId);
	soap_default_string(soap, &a->userClassId);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdDeleteReplacedLobs(struct soap *soap, const struct bmd230__bmdDeleteReplacedLobs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__base64Binary(soap, &a->cert);
	soap_serialize_string(soap, &a->userRoleId);
	soap_serialize_string(soap, &a->userGroupId);
	soap_serialize_string(soap, &a->userClassId);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdDeleteReplacedLobs(struct soap *soap, const char *tag, int id, const struct bmd230__bmdDeleteReplacedLobs *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdDeleteReplacedLobs), type))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "cert", -1, &a->cert, ""))
		return soap->error;
	if (soap_out_string(soap, "userRoleId", -1, &a->userRoleId, ""))
		return soap->error;
	if (soap_out_string(soap, "userGroupId", -1, &a->userGroupId, ""))
		return soap->error;
	if (soap_out_string(soap, "userClassId", -1, &a->userClassId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdDeleteReplacedLobs * SOAP_FMAC4 soap_in_bmd230__bmdDeleteReplacedLobs(struct soap *soap, const char *tag, struct bmd230__bmdDeleteReplacedLobs *a, const char *type)
{
	size_t soap_flag_cert = 1;
	size_t soap_flag_userRoleId = 1;
	size_t soap_flag_userGroupId = 1;
	size_t soap_flag_userClassId = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdDeleteReplacedLobs *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdDeleteReplacedLobs, sizeof(struct bmd230__bmdDeleteReplacedLobs), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdDeleteReplacedLobs(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cert && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "cert", &a->cert, "xsd:base64Binary"))
				{	soap_flag_cert--;
					continue;
				}
			if (soap_flag_userRoleId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userRoleId", &a->userRoleId, "xsd:string"))
				{	soap_flag_userRoleId--;
					continue;
				}
			if (soap_flag_userGroupId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userGroupId", &a->userGroupId, "xsd:string"))
				{	soap_flag_userGroupId--;
					continue;
				}
			if (soap_flag_userClassId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userClassId", &a->userClassId, "xsd:string"))
				{	soap_flag_userClassId--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdDeleteReplacedLobs *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdDeleteReplacedLobs, 0, sizeof(struct bmd230__bmdDeleteReplacedLobs), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdDeleteReplacedLobs(struct soap *soap, const struct bmd230__bmdDeleteReplacedLobs *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdDeleteReplacedLobs);
	if (soap_out_bmd230__bmdDeleteReplacedLobs(soap, tag?tag:"bmd230:bmdDeleteReplacedLobs", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdDeleteReplacedLobs * SOAP_FMAC4 soap_get_bmd230__bmdDeleteReplacedLobs(struct soap *soap, struct bmd230__bmdDeleteReplacedLobs *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdDeleteReplacedLobs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdDeleteReplacedLobsResponse(struct soap *soap, struct bmd230__bmdDeleteReplacedLobsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->deletedLobsCount = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdDeleteReplacedLobsResponse(struct soap *soap, const struct bmd230__bmdDeleteReplacedLobsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTolong(soap, &a->deletedLobsCount);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdDeleteReplacedLobsResponse(struct soap *soap, const char *tag, int id, const struct bmd230__bmdDeleteReplacedLobsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdDeleteReplacedLobsResponse), type))
		return soap->error;
	if (soap_out_PointerTolong(soap, "deletedLobsCount", -1, &a->deletedLobsCount, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdDeleteReplacedLobsResponse * SOAP_FMAC4 soap_in_bmd230__bmdDeleteReplacedLobsResponse(struct soap *soap, const char *tag, struct bmd230__bmdDeleteReplacedLobsResponse *a, const char *type)
{
	size_t soap_flag_deletedLobsCount = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdDeleteReplacedLobsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdDeleteReplacedLobsResponse, sizeof(struct bmd230__bmdDeleteReplacedLobsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdDeleteReplacedLobsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_deletedLobsCount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTolong(soap, "deletedLobsCount", &a->deletedLobsCount, "xsd:long"))
				{	soap_flag_deletedLobsCount--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdDeleteReplacedLobsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdDeleteReplacedLobsResponse, 0, sizeof(struct bmd230__bmdDeleteReplacedLobsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdDeleteReplacedLobsResponse(struct soap *soap, const struct bmd230__bmdDeleteReplacedLobsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdDeleteReplacedLobsResponse);
	if (soap_out_bmd230__bmdDeleteReplacedLobsResponse(soap, tag?tag:"bmd230:bmdDeleteReplacedLobsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdDeleteReplacedLobsResponse * SOAP_FMAC4 soap_get_bmd230__bmdDeleteReplacedLobsResponse(struct soap *soap, struct bmd230__bmdDeleteReplacedLobsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdDeleteReplacedLobsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdConservateTimestamps(struct soap *soap, struct bmd230__bmdConservateTimestamps *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cert = NULL;
	soap_default_string(soap, &a->roleName);
	soap_default_string(soap, &a->groupName);
	soap_default_string(soap, &a->userClassId);
	a->mtds = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdConservateTimestamps(struct soap *soap, const struct bmd230__bmdConservateTimestamps *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__base64Binary(soap, &a->cert);
	soap_serialize_string(soap, &a->roleName);
	soap_serialize_string(soap, &a->groupName);
	soap_serialize_string(soap, &a->userClassId);
	soap_serialize_PointerTobmd230__mtdsSearchValues(soap, &a->mtds);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdConservateTimestamps(struct soap *soap, const char *tag, int id, const struct bmd230__bmdConservateTimestamps *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdConservateTimestamps), type))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "cert", -1, &a->cert, ""))
		return soap->error;
	if (soap_out_string(soap, "roleName", -1, &a->roleName, ""))
		return soap->error;
	if (soap_out_string(soap, "groupName", -1, &a->groupName, ""))
		return soap->error;
	if (soap_out_string(soap, "userClassId", -1, &a->userClassId, ""))
		return soap->error;
	if (soap_out_PointerTobmd230__mtdsSearchValues(soap, "mtds", -1, &a->mtds, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdConservateTimestamps * SOAP_FMAC4 soap_in_bmd230__bmdConservateTimestamps(struct soap *soap, const char *tag, struct bmd230__bmdConservateTimestamps *a, const char *type)
{
	size_t soap_flag_cert = 1;
	size_t soap_flag_roleName = 1;
	size_t soap_flag_groupName = 1;
	size_t soap_flag_userClassId = 1;
	size_t soap_flag_mtds = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdConservateTimestamps *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdConservateTimestamps, sizeof(struct bmd230__bmdConservateTimestamps), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdConservateTimestamps(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cert && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "cert", &a->cert, "xsd:base64Binary"))
				{	soap_flag_cert--;
					continue;
				}
			if (soap_flag_roleName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "roleName", &a->roleName, "xsd:string"))
				{	soap_flag_roleName--;
					continue;
				}
			if (soap_flag_groupName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "groupName", &a->groupName, "xsd:string"))
				{	soap_flag_groupName--;
					continue;
				}
			if (soap_flag_userClassId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userClassId", &a->userClassId, "xsd:string"))
				{	soap_flag_userClassId--;
					continue;
				}
			if (soap_flag_mtds && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobmd230__mtdsSearchValues(soap, "mtds", &a->mtds, "bmd230:mtdsSearchValues"))
				{	soap_flag_mtds--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdConservateTimestamps *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdConservateTimestamps, 0, sizeof(struct bmd230__bmdConservateTimestamps), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdConservateTimestamps(struct soap *soap, const struct bmd230__bmdConservateTimestamps *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdConservateTimestamps);
	if (soap_out_bmd230__bmdConservateTimestamps(soap, tag?tag:"bmd230:bmdConservateTimestamps", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdConservateTimestamps * SOAP_FMAC4 soap_get_bmd230__bmdConservateTimestamps(struct soap *soap, struct bmd230__bmdConservateTimestamps *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdConservateTimestamps(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdConservateTimestampsResponse(struct soap *soap, struct bmd230__bmdConservateTimestampsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdConservateTimestampsResponse(struct soap *soap, const struct bmd230__bmdConservateTimestampsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdConservateTimestampsResponse(struct soap *soap, const char *tag, int id, const struct bmd230__bmdConservateTimestampsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdConservateTimestampsResponse), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdConservateTimestampsResponse * SOAP_FMAC4 soap_in_bmd230__bmdConservateTimestampsResponse(struct soap *soap, const char *tag, struct bmd230__bmdConservateTimestampsResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdConservateTimestampsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdConservateTimestampsResponse, sizeof(struct bmd230__bmdConservateTimestampsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdConservateTimestampsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdConservateTimestampsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdConservateTimestampsResponse, 0, sizeof(struct bmd230__bmdConservateTimestampsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdConservateTimestampsResponse(struct soap *soap, const struct bmd230__bmdConservateTimestampsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdConservateTimestampsResponse);
	if (soap_out_bmd230__bmdConservateTimestampsResponse(soap, tag?tag:"bmd230:bmdConservateTimestampsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdConservateTimestampsResponse * SOAP_FMAC4 soap_get_bmd230__bmdConservateTimestampsResponse(struct soap *soap, struct bmd230__bmdConservateTimestampsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdConservateTimestampsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdDeleteCascadeLinks(struct soap *soap, struct bmd230__bmdDeleteCascadeLinks *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cert = NULL;
	soap_default_string(soap, &a->userRoleId);
	soap_default_string(soap, &a->userGroupId);
	soap_default_string(soap, &a->userClassId);
	a->filesList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdDeleteCascadeLinks(struct soap *soap, const struct bmd230__bmdDeleteCascadeLinks *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__base64Binary(soap, &a->cert);
	soap_serialize_string(soap, &a->userRoleId);
	soap_serialize_string(soap, &a->userGroupId);
	soap_serialize_string(soap, &a->userClassId);
	soap_serialize_PointerTobmd230__deleteCascadeLinksList(soap, &a->filesList);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdDeleteCascadeLinks(struct soap *soap, const char *tag, int id, const struct bmd230__bmdDeleteCascadeLinks *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdDeleteCascadeLinks), type))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "cert", -1, &a->cert, ""))
		return soap->error;
	if (soap_out_string(soap, "userRoleId", -1, &a->userRoleId, ""))
		return soap->error;
	if (soap_out_string(soap, "userGroupId", -1, &a->userGroupId, ""))
		return soap->error;
	if (soap_out_string(soap, "userClassId", -1, &a->userClassId, ""))
		return soap->error;
	if (soap_out_PointerTobmd230__deleteCascadeLinksList(soap, "filesList", -1, &a->filesList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdDeleteCascadeLinks * SOAP_FMAC4 soap_in_bmd230__bmdDeleteCascadeLinks(struct soap *soap, const char *tag, struct bmd230__bmdDeleteCascadeLinks *a, const char *type)
{
	size_t soap_flag_cert = 1;
	size_t soap_flag_userRoleId = 1;
	size_t soap_flag_userGroupId = 1;
	size_t soap_flag_userClassId = 1;
	size_t soap_flag_filesList = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdDeleteCascadeLinks *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdDeleteCascadeLinks, sizeof(struct bmd230__bmdDeleteCascadeLinks), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdDeleteCascadeLinks(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cert && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "cert", &a->cert, "xsd:base64Binary"))
				{	soap_flag_cert--;
					continue;
				}
			if (soap_flag_userRoleId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userRoleId", &a->userRoleId, "xsd:string"))
				{	soap_flag_userRoleId--;
					continue;
				}
			if (soap_flag_userGroupId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userGroupId", &a->userGroupId, "xsd:string"))
				{	soap_flag_userGroupId--;
					continue;
				}
			if (soap_flag_userClassId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userClassId", &a->userClassId, "xsd:string"))
				{	soap_flag_userClassId--;
					continue;
				}
			if (soap_flag_filesList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobmd230__deleteCascadeLinksList(soap, "filesList", &a->filesList, "bmd230:deleteCascadeLinksList"))
				{	soap_flag_filesList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdDeleteCascadeLinks *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdDeleteCascadeLinks, 0, sizeof(struct bmd230__bmdDeleteCascadeLinks), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdDeleteCascadeLinks(struct soap *soap, const struct bmd230__bmdDeleteCascadeLinks *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdDeleteCascadeLinks);
	if (soap_out_bmd230__bmdDeleteCascadeLinks(soap, tag?tag:"bmd230:bmdDeleteCascadeLinks", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdDeleteCascadeLinks * SOAP_FMAC4 soap_get_bmd230__bmdDeleteCascadeLinks(struct soap *soap, struct bmd230__bmdDeleteCascadeLinks *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdDeleteCascadeLinks(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdDeleteCascadeLinksResponse(struct soap *soap, struct bmd230__bmdDeleteCascadeLinksResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdDeleteCascadeLinksResponse(struct soap *soap, const struct bmd230__bmdDeleteCascadeLinksResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToPointerTobmd230__manyCascadeLinksResult(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdDeleteCascadeLinksResponse(struct soap *soap, const char *tag, int id, const struct bmd230__bmdDeleteCascadeLinksResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdDeleteCascadeLinksResponse), type))
		return soap->error;
	if (soap_out_PointerToPointerTobmd230__manyCascadeLinksResult(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdDeleteCascadeLinksResponse * SOAP_FMAC4 soap_in_bmd230__bmdDeleteCascadeLinksResponse(struct soap *soap, const char *tag, struct bmd230__bmdDeleteCascadeLinksResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdDeleteCascadeLinksResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdDeleteCascadeLinksResponse, sizeof(struct bmd230__bmdDeleteCascadeLinksResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdDeleteCascadeLinksResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToPointerTobmd230__manyCascadeLinksResult(soap, "result", &a->result, "bmd230:manyCascadeLinksResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdDeleteCascadeLinksResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdDeleteCascadeLinksResponse, 0, sizeof(struct bmd230__bmdDeleteCascadeLinksResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdDeleteCascadeLinksResponse(struct soap *soap, const struct bmd230__bmdDeleteCascadeLinksResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdDeleteCascadeLinksResponse);
	if (soap_out_bmd230__bmdDeleteCascadeLinksResponse(soap, tag?tag:"bmd230:bmdDeleteCascadeLinksResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdDeleteCascadeLinksResponse * SOAP_FMAC4 soap_get_bmd230__bmdDeleteCascadeLinksResponse(struct soap *soap, struct bmd230__bmdDeleteCascadeLinksResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdDeleteCascadeLinksResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdCreateManyCascadeLinks(struct soap *soap, struct bmd230__bmdCreateManyCascadeLinks *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cert = NULL;
	soap_default_string(soap, &a->userRoleId);
	soap_default_string(soap, &a->userGroupId);
	soap_default_string(soap, &a->userClassId);
	a->cascadeLinksInfo = NULL;
	soap_default_string(soap, &a->transactionId);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdCreateManyCascadeLinks(struct soap *soap, const struct bmd230__bmdCreateManyCascadeLinks *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__base64Binary(soap, &a->cert);
	soap_serialize_string(soap, &a->userRoleId);
	soap_serialize_string(soap, &a->userGroupId);
	soap_serialize_string(soap, &a->userClassId);
	soap_serialize_PointerTobmd230__cascadeLinksInfo(soap, &a->cascadeLinksInfo);
	soap_serialize_string(soap, &a->transactionId);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdCreateManyCascadeLinks(struct soap *soap, const char *tag, int id, const struct bmd230__bmdCreateManyCascadeLinks *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdCreateManyCascadeLinks), type))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "cert", -1, &a->cert, ""))
		return soap->error;
	if (soap_out_string(soap, "userRoleId", -1, &a->userRoleId, ""))
		return soap->error;
	if (soap_out_string(soap, "userGroupId", -1, &a->userGroupId, ""))
		return soap->error;
	if (soap_out_string(soap, "userClassId", -1, &a->userClassId, ""))
		return soap->error;
	if (soap_out_PointerTobmd230__cascadeLinksInfo(soap, "cascadeLinksInfo", -1, &a->cascadeLinksInfo, ""))
		return soap->error;
	if (soap_out_string(soap, "transactionId", -1, &a->transactionId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdCreateManyCascadeLinks * SOAP_FMAC4 soap_in_bmd230__bmdCreateManyCascadeLinks(struct soap *soap, const char *tag, struct bmd230__bmdCreateManyCascadeLinks *a, const char *type)
{
	size_t soap_flag_cert = 1;
	size_t soap_flag_userRoleId = 1;
	size_t soap_flag_userGroupId = 1;
	size_t soap_flag_userClassId = 1;
	size_t soap_flag_cascadeLinksInfo = 1;
	size_t soap_flag_transactionId = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdCreateManyCascadeLinks *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdCreateManyCascadeLinks, sizeof(struct bmd230__bmdCreateManyCascadeLinks), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdCreateManyCascadeLinks(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cert && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "cert", &a->cert, "xsd:base64Binary"))
				{	soap_flag_cert--;
					continue;
				}
			if (soap_flag_userRoleId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userRoleId", &a->userRoleId, "xsd:string"))
				{	soap_flag_userRoleId--;
					continue;
				}
			if (soap_flag_userGroupId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userGroupId", &a->userGroupId, "xsd:string"))
				{	soap_flag_userGroupId--;
					continue;
				}
			if (soap_flag_userClassId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userClassId", &a->userClassId, "xsd:string"))
				{	soap_flag_userClassId--;
					continue;
				}
			if (soap_flag_cascadeLinksInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobmd230__cascadeLinksInfo(soap, "cascadeLinksInfo", &a->cascadeLinksInfo, "bmd230:cascadeLinksInfo"))
				{	soap_flag_cascadeLinksInfo--;
					continue;
				}
			if (soap_flag_transactionId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "transactionId", &a->transactionId, "xsd:string"))
				{	soap_flag_transactionId--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdCreateManyCascadeLinks *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdCreateManyCascadeLinks, 0, sizeof(struct bmd230__bmdCreateManyCascadeLinks), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdCreateManyCascadeLinks(struct soap *soap, const struct bmd230__bmdCreateManyCascadeLinks *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdCreateManyCascadeLinks);
	if (soap_out_bmd230__bmdCreateManyCascadeLinks(soap, tag?tag:"bmd230:bmdCreateManyCascadeLinks", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdCreateManyCascadeLinks * SOAP_FMAC4 soap_get_bmd230__bmdCreateManyCascadeLinks(struct soap *soap, struct bmd230__bmdCreateManyCascadeLinks *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdCreateManyCascadeLinks(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdCreateManyCascadeLinksResponse(struct soap *soap, struct bmd230__bmdCreateManyCascadeLinksResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdCreateManyCascadeLinksResponse(struct soap *soap, const struct bmd230__bmdCreateManyCascadeLinksResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToPointerTobmd230__manyCascadeLinksResult(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdCreateManyCascadeLinksResponse(struct soap *soap, const char *tag, int id, const struct bmd230__bmdCreateManyCascadeLinksResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdCreateManyCascadeLinksResponse), type))
		return soap->error;
	if (soap_out_PointerToPointerTobmd230__manyCascadeLinksResult(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdCreateManyCascadeLinksResponse * SOAP_FMAC4 soap_in_bmd230__bmdCreateManyCascadeLinksResponse(struct soap *soap, const char *tag, struct bmd230__bmdCreateManyCascadeLinksResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdCreateManyCascadeLinksResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdCreateManyCascadeLinksResponse, sizeof(struct bmd230__bmdCreateManyCascadeLinksResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdCreateManyCascadeLinksResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToPointerTobmd230__manyCascadeLinksResult(soap, "result", &a->result, "bmd230:manyCascadeLinksResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdCreateManyCascadeLinksResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdCreateManyCascadeLinksResponse, 0, sizeof(struct bmd230__bmdCreateManyCascadeLinksResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdCreateManyCascadeLinksResponse(struct soap *soap, const struct bmd230__bmdCreateManyCascadeLinksResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdCreateManyCascadeLinksResponse);
	if (soap_out_bmd230__bmdCreateManyCascadeLinksResponse(soap, tag?tag:"bmd230:bmdCreateManyCascadeLinksResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdCreateManyCascadeLinksResponse * SOAP_FMAC4 soap_get_bmd230__bmdCreateManyCascadeLinksResponse(struct soap *soap, struct bmd230__bmdCreateManyCascadeLinksResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdCreateManyCascadeLinksResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdCreateCascadeLinks(struct soap *soap, struct bmd230__bmdCreateCascadeLinks *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cert = NULL;
	soap_default_string(soap, &a->userRoleId);
	soap_default_string(soap, &a->userGroupId);
	soap_default_string(soap, &a->userClassId);
	a->linkInfo = NULL;
	soap_default_string(soap, &a->transactionId);
	soap_default_long(soap, &a->correspondingFilesMaxLevel);
	soap_default_visibilityType_t(soap, &a->visible);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdCreateCascadeLinks(struct soap *soap, const struct bmd230__bmdCreateCascadeLinks *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__base64Binary(soap, &a->cert);
	soap_serialize_string(soap, &a->userRoleId);
	soap_serialize_string(soap, &a->userGroupId);
	soap_serialize_string(soap, &a->userClassId);
	soap_serialize_PointerTobmd230__singleLinkInfo(soap, &a->linkInfo);
	soap_serialize_string(soap, &a->transactionId);
	soap_embedded(soap, &a->correspondingFilesMaxLevel, SOAP_TYPE_long);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdCreateCascadeLinks(struct soap *soap, const char *tag, int id, const struct bmd230__bmdCreateCascadeLinks *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdCreateCascadeLinks), type))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "cert", -1, &a->cert, ""))
		return soap->error;
	if (soap_out_string(soap, "userRoleId", -1, &a->userRoleId, ""))
		return soap->error;
	if (soap_out_string(soap, "userGroupId", -1, &a->userGroupId, ""))
		return soap->error;
	if (soap_out_string(soap, "userClassId", -1, &a->userClassId, ""))
		return soap->error;
	if (soap_out_PointerTobmd230__singleLinkInfo(soap, "linkInfo", -1, &a->linkInfo, ""))
		return soap->error;
	if (soap_out_string(soap, "transactionId", -1, &a->transactionId, ""))
		return soap->error;
	if (soap_out_long(soap, "correspondingFilesMaxLevel", -1, &a->correspondingFilesMaxLevel, ""))
		return soap->error;
	if (soap_out_visibilityType_t(soap, "visible", -1, &a->visible, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdCreateCascadeLinks * SOAP_FMAC4 soap_in_bmd230__bmdCreateCascadeLinks(struct soap *soap, const char *tag, struct bmd230__bmdCreateCascadeLinks *a, const char *type)
{
	size_t soap_flag_cert = 1;
	size_t soap_flag_userRoleId = 1;
	size_t soap_flag_userGroupId = 1;
	size_t soap_flag_userClassId = 1;
	size_t soap_flag_linkInfo = 1;
	size_t soap_flag_transactionId = 1;
	size_t soap_flag_correspondingFilesMaxLevel = 1;
	size_t soap_flag_visible = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdCreateCascadeLinks *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdCreateCascadeLinks, sizeof(struct bmd230__bmdCreateCascadeLinks), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdCreateCascadeLinks(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cert && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "cert", &a->cert, "xsd:base64Binary"))
				{	soap_flag_cert--;
					continue;
				}
			if (soap_flag_userRoleId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userRoleId", &a->userRoleId, "xsd:string"))
				{	soap_flag_userRoleId--;
					continue;
				}
			if (soap_flag_userGroupId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userGroupId", &a->userGroupId, "xsd:string"))
				{	soap_flag_userGroupId--;
					continue;
				}
			if (soap_flag_userClassId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userClassId", &a->userClassId, "xsd:string"))
				{	soap_flag_userClassId--;
					continue;
				}
			if (soap_flag_linkInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobmd230__singleLinkInfo(soap, "linkInfo", &a->linkInfo, "bmd230:singleLinkInfo"))
				{	soap_flag_linkInfo--;
					continue;
				}
			if (soap_flag_transactionId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "transactionId", &a->transactionId, "xsd:string"))
				{	soap_flag_transactionId--;
					continue;
				}
			if (soap_flag_correspondingFilesMaxLevel && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_long(soap, "correspondingFilesMaxLevel", &a->correspondingFilesMaxLevel, "xsd:long"))
				{	soap_flag_correspondingFilesMaxLevel--;
					continue;
				}
			if (soap_flag_visible && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_visibilityType_t(soap, "visible", &a->visible, "visibilityType-t"))
				{	soap_flag_visible--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdCreateCascadeLinks *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdCreateCascadeLinks, 0, sizeof(struct bmd230__bmdCreateCascadeLinks), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_correspondingFilesMaxLevel > 0 || soap_flag_visible > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdCreateCascadeLinks(struct soap *soap, const struct bmd230__bmdCreateCascadeLinks *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdCreateCascadeLinks);
	if (soap_out_bmd230__bmdCreateCascadeLinks(soap, tag?tag:"bmd230:bmdCreateCascadeLinks", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdCreateCascadeLinks * SOAP_FMAC4 soap_get_bmd230__bmdCreateCascadeLinks(struct soap *soap, struct bmd230__bmdCreateCascadeLinks *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdCreateCascadeLinks(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdCreateCascadeLinksResponse(struct soap *soap, struct bmd230__bmdCreateCascadeLinksResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->createdIds = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdCreateCascadeLinksResponse(struct soap *soap, const struct bmd230__bmdCreateCascadeLinksResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToPointerTobmd230__idList(soap, &a->createdIds);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdCreateCascadeLinksResponse(struct soap *soap, const char *tag, int id, const struct bmd230__bmdCreateCascadeLinksResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdCreateCascadeLinksResponse), type))
		return soap->error;
	if (soap_out_PointerToPointerTobmd230__idList(soap, "createdIds", -1, &a->createdIds, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdCreateCascadeLinksResponse * SOAP_FMAC4 soap_in_bmd230__bmdCreateCascadeLinksResponse(struct soap *soap, const char *tag, struct bmd230__bmdCreateCascadeLinksResponse *a, const char *type)
{
	size_t soap_flag_createdIds = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdCreateCascadeLinksResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdCreateCascadeLinksResponse, sizeof(struct bmd230__bmdCreateCascadeLinksResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdCreateCascadeLinksResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_createdIds && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToPointerTobmd230__idList(soap, "createdIds", &a->createdIds, "bmd230:idList"))
				{	soap_flag_createdIds--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdCreateCascadeLinksResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdCreateCascadeLinksResponse, 0, sizeof(struct bmd230__bmdCreateCascadeLinksResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdCreateCascadeLinksResponse(struct soap *soap, const struct bmd230__bmdCreateCascadeLinksResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdCreateCascadeLinksResponse);
	if (soap_out_bmd230__bmdCreateCascadeLinksResponse(soap, tag?tag:"bmd230:bmdCreateCascadeLinksResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdCreateCascadeLinksResponse * SOAP_FMAC4 soap_get_bmd230__bmdCreateCascadeLinksResponse(struct soap *soap, struct bmd230__bmdCreateCascadeLinksResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdCreateCascadeLinksResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdCreateLinks(struct soap *soap, struct bmd230__bmdCreateLinks *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cert = NULL;
	soap_default_string(soap, &a->userRoleId);
	soap_default_string(soap, &a->userGroupId);
	soap_default_string(soap, &a->userClassId);
	a->linksInfo = NULL;
	soap_default_string(soap, &a->transactionId);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdCreateLinks(struct soap *soap, const struct bmd230__bmdCreateLinks *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__base64Binary(soap, &a->cert);
	soap_serialize_string(soap, &a->userRoleId);
	soap_serialize_string(soap, &a->userGroupId);
	soap_serialize_string(soap, &a->userClassId);
	soap_serialize_PointerTobmd230__linksInfo(soap, &a->linksInfo);
	soap_serialize_string(soap, &a->transactionId);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdCreateLinks(struct soap *soap, const char *tag, int id, const struct bmd230__bmdCreateLinks *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdCreateLinks), type))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "cert", -1, &a->cert, ""))
		return soap->error;
	if (soap_out_string(soap, "userRoleId", -1, &a->userRoleId, ""))
		return soap->error;
	if (soap_out_string(soap, "userGroupId", -1, &a->userGroupId, ""))
		return soap->error;
	if (soap_out_string(soap, "userClassId", -1, &a->userClassId, ""))
		return soap->error;
	if (soap_out_PointerTobmd230__linksInfo(soap, "linksInfo", -1, &a->linksInfo, ""))
		return soap->error;
	if (soap_out_string(soap, "transactionId", -1, &a->transactionId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdCreateLinks * SOAP_FMAC4 soap_in_bmd230__bmdCreateLinks(struct soap *soap, const char *tag, struct bmd230__bmdCreateLinks *a, const char *type)
{
	size_t soap_flag_cert = 1;
	size_t soap_flag_userRoleId = 1;
	size_t soap_flag_userGroupId = 1;
	size_t soap_flag_userClassId = 1;
	size_t soap_flag_linksInfo = 1;
	size_t soap_flag_transactionId = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdCreateLinks *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdCreateLinks, sizeof(struct bmd230__bmdCreateLinks), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdCreateLinks(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cert && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "cert", &a->cert, "xsd:base64Binary"))
				{	soap_flag_cert--;
					continue;
				}
			if (soap_flag_userRoleId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userRoleId", &a->userRoleId, "xsd:string"))
				{	soap_flag_userRoleId--;
					continue;
				}
			if (soap_flag_userGroupId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userGroupId", &a->userGroupId, "xsd:string"))
				{	soap_flag_userGroupId--;
					continue;
				}
			if (soap_flag_userClassId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userClassId", &a->userClassId, "xsd:string"))
				{	soap_flag_userClassId--;
					continue;
				}
			if (soap_flag_linksInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobmd230__linksInfo(soap, "linksInfo", &a->linksInfo, "bmd230:linksInfo"))
				{	soap_flag_linksInfo--;
					continue;
				}
			if (soap_flag_transactionId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "transactionId", &a->transactionId, "xsd:string"))
				{	soap_flag_transactionId--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdCreateLinks *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdCreateLinks, 0, sizeof(struct bmd230__bmdCreateLinks), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdCreateLinks(struct soap *soap, const struct bmd230__bmdCreateLinks *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdCreateLinks);
	if (soap_out_bmd230__bmdCreateLinks(soap, tag?tag:"bmd230:bmdCreateLinks", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdCreateLinks * SOAP_FMAC4 soap_get_bmd230__bmdCreateLinks(struct soap *soap, struct bmd230__bmdCreateLinks *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdCreateLinks(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdCreateLinksResponse(struct soap *soap, struct bmd230__bmdCreateLinksResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ids = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdCreateLinksResponse(struct soap *soap, const struct bmd230__bmdCreateLinksResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToPointerTobmd230__idList(soap, &a->ids);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdCreateLinksResponse(struct soap *soap, const char *tag, int id, const struct bmd230__bmdCreateLinksResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdCreateLinksResponse), type))
		return soap->error;
	if (soap_out_PointerToPointerTobmd230__idList(soap, "ids", -1, &a->ids, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdCreateLinksResponse * SOAP_FMAC4 soap_in_bmd230__bmdCreateLinksResponse(struct soap *soap, const char *tag, struct bmd230__bmdCreateLinksResponse *a, const char *type)
{
	size_t soap_flag_ids = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdCreateLinksResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdCreateLinksResponse, sizeof(struct bmd230__bmdCreateLinksResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdCreateLinksResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ids && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToPointerTobmd230__idList(soap, "ids", &a->ids, "bmd230:idList"))
				{	soap_flag_ids--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdCreateLinksResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdCreateLinksResponse, 0, sizeof(struct bmd230__bmdCreateLinksResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdCreateLinksResponse(struct soap *soap, const struct bmd230__bmdCreateLinksResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdCreateLinksResponse);
	if (soap_out_bmd230__bmdCreateLinksResponse(soap, tag?tag:"bmd230:bmdCreateLinksResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdCreateLinksResponse * SOAP_FMAC4 soap_get_bmd230__bmdCreateLinksResponse(struct soap *soap, struct bmd230__bmdCreateLinksResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdCreateLinksResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdCreateLink(struct soap *soap, struct bmd230__bmdCreateLink *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cert = NULL;
	soap_default_string(soap, &a->userRoleId);
	soap_default_string(soap, &a->userGroupId);
	soap_default_string(soap, &a->userClassId);
	a->mtds = NULL;
	soap_default_string(soap, &a->description);
	soap_default_string(soap, &a->linkName);
	soap_default_string(soap, &a->transactionId);
	soap_default_grantingType_e(soap, &a->granting);
	a->expirationDate = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdCreateLink(struct soap *soap, const struct bmd230__bmdCreateLink *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__base64Binary(soap, &a->cert);
	soap_serialize_string(soap, &a->userRoleId);
	soap_serialize_string(soap, &a->userGroupId);
	soap_serialize_string(soap, &a->userClassId);
	soap_serialize_PointerTobmd230__mtdsValues(soap, &a->mtds);
	soap_serialize_string(soap, &a->description);
	soap_serialize_string(soap, &a->linkName);
	soap_serialize_string(soap, &a->transactionId);
	soap_serialize_PointerTobmd230__DateTime(soap, &a->expirationDate);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdCreateLink(struct soap *soap, const char *tag, int id, const struct bmd230__bmdCreateLink *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdCreateLink), type))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "cert", -1, &a->cert, ""))
		return soap->error;
	if (soap_out_string(soap, "userRoleId", -1, &a->userRoleId, ""))
		return soap->error;
	if (soap_out_string(soap, "userGroupId", -1, &a->userGroupId, ""))
		return soap->error;
	if (soap_out_string(soap, "userClassId", -1, &a->userClassId, ""))
		return soap->error;
	if (soap_out_PointerTobmd230__mtdsValues(soap, "mtds", -1, &a->mtds, ""))
		return soap->error;
	if (soap_out_string(soap, "description", -1, &a->description, ""))
		return soap->error;
	if (soap_out_string(soap, "linkName", -1, &a->linkName, ""))
		return soap->error;
	if (soap_out_string(soap, "transactionId", -1, &a->transactionId, ""))
		return soap->error;
	if (soap_out_grantingType_e(soap, "granting", -1, &a->granting, ""))
		return soap->error;
	if (soap_out_PointerTobmd230__DateTime(soap, "expirationDate", -1, &a->expirationDate, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdCreateLink * SOAP_FMAC4 soap_in_bmd230__bmdCreateLink(struct soap *soap, const char *tag, struct bmd230__bmdCreateLink *a, const char *type)
{
	size_t soap_flag_cert = 1;
	size_t soap_flag_userRoleId = 1;
	size_t soap_flag_userGroupId = 1;
	size_t soap_flag_userClassId = 1;
	size_t soap_flag_mtds = 1;
	size_t soap_flag_description = 1;
	size_t soap_flag_linkName = 1;
	size_t soap_flag_transactionId = 1;
	size_t soap_flag_granting = 1;
	size_t soap_flag_expirationDate = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdCreateLink *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdCreateLink, sizeof(struct bmd230__bmdCreateLink), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdCreateLink(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cert && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "cert", &a->cert, "xsd:base64Binary"))
				{	soap_flag_cert--;
					continue;
				}
			if (soap_flag_userRoleId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userRoleId", &a->userRoleId, "xsd:string"))
				{	soap_flag_userRoleId--;
					continue;
				}
			if (soap_flag_userGroupId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userGroupId", &a->userGroupId, "xsd:string"))
				{	soap_flag_userGroupId--;
					continue;
				}
			if (soap_flag_userClassId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userClassId", &a->userClassId, "xsd:string"))
				{	soap_flag_userClassId--;
					continue;
				}
			if (soap_flag_mtds && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobmd230__mtdsValues(soap, "mtds", &a->mtds, "bmd230:mtdsValues"))
				{	soap_flag_mtds--;
					continue;
				}
			if (soap_flag_description && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "description", &a->description, "xsd:string"))
				{	soap_flag_description--;
					continue;
				}
			if (soap_flag_linkName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "linkName", &a->linkName, "xsd:string"))
				{	soap_flag_linkName--;
					continue;
				}
			if (soap_flag_transactionId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "transactionId", &a->transactionId, "xsd:string"))
				{	soap_flag_transactionId--;
					continue;
				}
			if (soap_flag_granting && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_grantingType_e(soap, "granting", &a->granting, "grantingType-e"))
				{	soap_flag_granting--;
					continue;
				}
			if (soap_flag_expirationDate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobmd230__DateTime(soap, "expirationDate", &a->expirationDate, "bmd230:DateTime"))
				{	soap_flag_expirationDate--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdCreateLink *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdCreateLink, 0, sizeof(struct bmd230__bmdCreateLink), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_granting > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdCreateLink(struct soap *soap, const struct bmd230__bmdCreateLink *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdCreateLink);
	if (soap_out_bmd230__bmdCreateLink(soap, tag?tag:"bmd230:bmdCreateLink", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdCreateLink * SOAP_FMAC4 soap_get_bmd230__bmdCreateLink(struct soap *soap, struct bmd230__bmdCreateLink *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdCreateLink(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdCreateLinkResponse(struct soap *soap, struct bmd230__bmdCreateLinkResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->id = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdCreateLinkResponse(struct soap *soap, const struct bmd230__bmdCreateLinkResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTolong(soap, &a->id);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdCreateLinkResponse(struct soap *soap, const char *tag, int id, const struct bmd230__bmdCreateLinkResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdCreateLinkResponse), type))
		return soap->error;
	if (soap_out_PointerTolong(soap, "id", -1, &a->id, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdCreateLinkResponse * SOAP_FMAC4 soap_in_bmd230__bmdCreateLinkResponse(struct soap *soap, const char *tag, struct bmd230__bmdCreateLinkResponse *a, const char *type)
{
	size_t soap_flag_id = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdCreateLinkResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdCreateLinkResponse, sizeof(struct bmd230__bmdCreateLinkResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdCreateLinkResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTolong(soap, "id", &a->id, "xsd:long"))
				{	soap_flag_id--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdCreateLinkResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdCreateLinkResponse, 0, sizeof(struct bmd230__bmdCreateLinkResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdCreateLinkResponse(struct soap *soap, const struct bmd230__bmdCreateLinkResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdCreateLinkResponse);
	if (soap_out_bmd230__bmdCreateLinkResponse(soap, tag?tag:"bmd230:bmdCreateLinkResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdCreateLinkResponse * SOAP_FMAC4 soap_get_bmd230__bmdCreateLinkResponse(struct soap *soap, struct bmd230__bmdCreateLinkResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdCreateLinkResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdGetDirectoryDetails(struct soap *soap, struct bmd230__bmdGetDirectoryDetails *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cert = NULL;
	soap_default_string(soap, &a->userRoleId);
	soap_default_string(soap, &a->userGroupId);
	soap_default_string(soap, &a->userClassId);
	soap_default_long(soap, &a->id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdGetDirectoryDetails(struct soap *soap, const struct bmd230__bmdGetDirectoryDetails *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__base64Binary(soap, &a->cert);
	soap_serialize_string(soap, &a->userRoleId);
	soap_serialize_string(soap, &a->userGroupId);
	soap_serialize_string(soap, &a->userClassId);
	soap_embedded(soap, &a->id, SOAP_TYPE_long);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdGetDirectoryDetails(struct soap *soap, const char *tag, int id, const struct bmd230__bmdGetDirectoryDetails *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdGetDirectoryDetails), type))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "cert", -1, &a->cert, ""))
		return soap->error;
	if (soap_out_string(soap, "userRoleId", -1, &a->userRoleId, ""))
		return soap->error;
	if (soap_out_string(soap, "userGroupId", -1, &a->userGroupId, ""))
		return soap->error;
	if (soap_out_string(soap, "userClassId", -1, &a->userClassId, ""))
		return soap->error;
	if (soap_out_long(soap, "id", -1, &a->id, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdGetDirectoryDetails * SOAP_FMAC4 soap_in_bmd230__bmdGetDirectoryDetails(struct soap *soap, const char *tag, struct bmd230__bmdGetDirectoryDetails *a, const char *type)
{
	size_t soap_flag_cert = 1;
	size_t soap_flag_userRoleId = 1;
	size_t soap_flag_userGroupId = 1;
	size_t soap_flag_userClassId = 1;
	size_t soap_flag_id = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdGetDirectoryDetails *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdGetDirectoryDetails, sizeof(struct bmd230__bmdGetDirectoryDetails), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdGetDirectoryDetails(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cert && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "cert", &a->cert, "xsd:base64Binary"))
				{	soap_flag_cert--;
					continue;
				}
			if (soap_flag_userRoleId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userRoleId", &a->userRoleId, "xsd:string"))
				{	soap_flag_userRoleId--;
					continue;
				}
			if (soap_flag_userGroupId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userGroupId", &a->userGroupId, "xsd:string"))
				{	soap_flag_userGroupId--;
					continue;
				}
			if (soap_flag_userClassId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userClassId", &a->userClassId, "xsd:string"))
				{	soap_flag_userClassId--;
					continue;
				}
			if (soap_flag_id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_long(soap, "id", &a->id, "xsd:long"))
				{	soap_flag_id--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdGetDirectoryDetails *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdGetDirectoryDetails, 0, sizeof(struct bmd230__bmdGetDirectoryDetails), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdGetDirectoryDetails(struct soap *soap, const struct bmd230__bmdGetDirectoryDetails *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdGetDirectoryDetails);
	if (soap_out_bmd230__bmdGetDirectoryDetails(soap, tag?tag:"bmd230:bmdGetDirectoryDetails", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdGetDirectoryDetails * SOAP_FMAC4 soap_get_bmd230__bmdGetDirectoryDetails(struct soap *soap, struct bmd230__bmdGetDirectoryDetails *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdGetDirectoryDetails(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdGetDirectoryDetailsResponse(struct soap *soap, struct bmd230__bmdGetDirectoryDetailsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->output = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdGetDirectoryDetailsResponse(struct soap *soap, const struct bmd230__bmdGetDirectoryDetailsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToPointerTobmd230__fileInfo(soap, &a->output);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdGetDirectoryDetailsResponse(struct soap *soap, const char *tag, int id, const struct bmd230__bmdGetDirectoryDetailsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdGetDirectoryDetailsResponse), type))
		return soap->error;
	if (soap_out_PointerToPointerTobmd230__fileInfo(soap, "output", -1, &a->output, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdGetDirectoryDetailsResponse * SOAP_FMAC4 soap_in_bmd230__bmdGetDirectoryDetailsResponse(struct soap *soap, const char *tag, struct bmd230__bmdGetDirectoryDetailsResponse *a, const char *type)
{
	size_t soap_flag_output = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdGetDirectoryDetailsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdGetDirectoryDetailsResponse, sizeof(struct bmd230__bmdGetDirectoryDetailsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdGetDirectoryDetailsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_output && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToPointerTobmd230__fileInfo(soap, "output", &a->output, "bmd230:fileInfo"))
				{	soap_flag_output--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdGetDirectoryDetailsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdGetDirectoryDetailsResponse, 0, sizeof(struct bmd230__bmdGetDirectoryDetailsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdGetDirectoryDetailsResponse(struct soap *soap, const struct bmd230__bmdGetDirectoryDetailsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdGetDirectoryDetailsResponse);
	if (soap_out_bmd230__bmdGetDirectoryDetailsResponse(soap, tag?tag:"bmd230:bmdGetDirectoryDetailsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdGetDirectoryDetailsResponse * SOAP_FMAC4 soap_get_bmd230__bmdGetDirectoryDetailsResponse(struct soap *soap, struct bmd230__bmdGetDirectoryDetailsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdGetDirectoryDetailsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdCreateDirectory(struct soap *soap, struct bmd230__bmdCreateDirectory *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cert = NULL;
	soap_default_string(soap, &a->userRoleId);
	soap_default_string(soap, &a->userGroupId);
	soap_default_string(soap, &a->userClassId);
	a->mtds = NULL;
	soap_default_string(soap, &a->description);
	soap_default_string(soap, &a->dirName);
	soap_default_string(soap, &a->transactionId);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdCreateDirectory(struct soap *soap, const struct bmd230__bmdCreateDirectory *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__base64Binary(soap, &a->cert);
	soap_serialize_string(soap, &a->userRoleId);
	soap_serialize_string(soap, &a->userGroupId);
	soap_serialize_string(soap, &a->userClassId);
	soap_serialize_PointerTobmd230__mtdsValues(soap, &a->mtds);
	soap_serialize_string(soap, &a->description);
	soap_serialize_string(soap, &a->dirName);
	soap_serialize_string(soap, &a->transactionId);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdCreateDirectory(struct soap *soap, const char *tag, int id, const struct bmd230__bmdCreateDirectory *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdCreateDirectory), type))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "cert", -1, &a->cert, ""))
		return soap->error;
	if (soap_out_string(soap, "userRoleId", -1, &a->userRoleId, ""))
		return soap->error;
	if (soap_out_string(soap, "userGroupId", -1, &a->userGroupId, ""))
		return soap->error;
	if (soap_out_string(soap, "userClassId", -1, &a->userClassId, ""))
		return soap->error;
	if (soap_out_PointerTobmd230__mtdsValues(soap, "mtds", -1, &a->mtds, ""))
		return soap->error;
	if (soap_out_string(soap, "description", -1, &a->description, ""))
		return soap->error;
	if (soap_out_string(soap, "dirName", -1, &a->dirName, ""))
		return soap->error;
	if (soap_out_string(soap, "transactionId", -1, &a->transactionId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdCreateDirectory * SOAP_FMAC4 soap_in_bmd230__bmdCreateDirectory(struct soap *soap, const char *tag, struct bmd230__bmdCreateDirectory *a, const char *type)
{
	size_t soap_flag_cert = 1;
	size_t soap_flag_userRoleId = 1;
	size_t soap_flag_userGroupId = 1;
	size_t soap_flag_userClassId = 1;
	size_t soap_flag_mtds = 1;
	size_t soap_flag_description = 1;
	size_t soap_flag_dirName = 1;
	size_t soap_flag_transactionId = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdCreateDirectory *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdCreateDirectory, sizeof(struct bmd230__bmdCreateDirectory), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdCreateDirectory(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cert && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "cert", &a->cert, "xsd:base64Binary"))
				{	soap_flag_cert--;
					continue;
				}
			if (soap_flag_userRoleId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userRoleId", &a->userRoleId, "xsd:string"))
				{	soap_flag_userRoleId--;
					continue;
				}
			if (soap_flag_userGroupId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userGroupId", &a->userGroupId, "xsd:string"))
				{	soap_flag_userGroupId--;
					continue;
				}
			if (soap_flag_userClassId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userClassId", &a->userClassId, "xsd:string"))
				{	soap_flag_userClassId--;
					continue;
				}
			if (soap_flag_mtds && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobmd230__mtdsValues(soap, "mtds", &a->mtds, "bmd230:mtdsValues"))
				{	soap_flag_mtds--;
					continue;
				}
			if (soap_flag_description && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "description", &a->description, "xsd:string"))
				{	soap_flag_description--;
					continue;
				}
			if (soap_flag_dirName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "dirName", &a->dirName, "xsd:string"))
				{	soap_flag_dirName--;
					continue;
				}
			if (soap_flag_transactionId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "transactionId", &a->transactionId, "xsd:string"))
				{	soap_flag_transactionId--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdCreateDirectory *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdCreateDirectory, 0, sizeof(struct bmd230__bmdCreateDirectory), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdCreateDirectory(struct soap *soap, const struct bmd230__bmdCreateDirectory *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdCreateDirectory);
	if (soap_out_bmd230__bmdCreateDirectory(soap, tag?tag:"bmd230:bmdCreateDirectory", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdCreateDirectory * SOAP_FMAC4 soap_get_bmd230__bmdCreateDirectory(struct soap *soap, struct bmd230__bmdCreateDirectory *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdCreateDirectory(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdCreateDirectoryResponse(struct soap *soap, struct bmd230__bmdCreateDirectoryResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->id = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdCreateDirectoryResponse(struct soap *soap, const struct bmd230__bmdCreateDirectoryResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTolong(soap, &a->id);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdCreateDirectoryResponse(struct soap *soap, const char *tag, int id, const struct bmd230__bmdCreateDirectoryResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdCreateDirectoryResponse), type))
		return soap->error;
	if (soap_out_PointerTolong(soap, "id", -1, &a->id, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdCreateDirectoryResponse * SOAP_FMAC4 soap_in_bmd230__bmdCreateDirectoryResponse(struct soap *soap, const char *tag, struct bmd230__bmdCreateDirectoryResponse *a, const char *type)
{
	size_t soap_flag_id = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdCreateDirectoryResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdCreateDirectoryResponse, sizeof(struct bmd230__bmdCreateDirectoryResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdCreateDirectoryResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTolong(soap, "id", &a->id, "xsd:long"))
				{	soap_flag_id--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdCreateDirectoryResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdCreateDirectoryResponse, 0, sizeof(struct bmd230__bmdCreateDirectoryResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdCreateDirectoryResponse(struct soap *soap, const struct bmd230__bmdCreateDirectoryResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdCreateDirectoryResponse);
	if (soap_out_bmd230__bmdCreateDirectoryResponse(soap, tag?tag:"bmd230:bmdCreateDirectoryResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdCreateDirectoryResponse * SOAP_FMAC4 soap_get_bmd230__bmdCreateDirectoryResponse(struct soap *soap, struct bmd230__bmdCreateDirectoryResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdCreateDirectoryResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdStopTransaction(struct soap *soap, struct bmd230__bmdStopTransaction *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cert = NULL;
	soap_default_string(soap, &a->userRoleId);
	soap_default_string(soap, &a->userGroupId);
	soap_default_string(soap, &a->userClassId);
	soap_default_string(soap, &a->transactionId);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdStopTransaction(struct soap *soap, const struct bmd230__bmdStopTransaction *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__base64Binary(soap, &a->cert);
	soap_serialize_string(soap, &a->userRoleId);
	soap_serialize_string(soap, &a->userGroupId);
	soap_serialize_string(soap, &a->userClassId);
	soap_serialize_string(soap, &a->transactionId);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdStopTransaction(struct soap *soap, const char *tag, int id, const struct bmd230__bmdStopTransaction *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdStopTransaction), type))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "cert", -1, &a->cert, ""))
		return soap->error;
	if (soap_out_string(soap, "userRoleId", -1, &a->userRoleId, ""))
		return soap->error;
	if (soap_out_string(soap, "userGroupId", -1, &a->userGroupId, ""))
		return soap->error;
	if (soap_out_string(soap, "userClassId", -1, &a->userClassId, ""))
		return soap->error;
	if (soap_out_string(soap, "transactionId", -1, &a->transactionId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdStopTransaction * SOAP_FMAC4 soap_in_bmd230__bmdStopTransaction(struct soap *soap, const char *tag, struct bmd230__bmdStopTransaction *a, const char *type)
{
	size_t soap_flag_cert = 1;
	size_t soap_flag_userRoleId = 1;
	size_t soap_flag_userGroupId = 1;
	size_t soap_flag_userClassId = 1;
	size_t soap_flag_transactionId = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdStopTransaction *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdStopTransaction, sizeof(struct bmd230__bmdStopTransaction), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdStopTransaction(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cert && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "cert", &a->cert, "xsd:base64Binary"))
				{	soap_flag_cert--;
					continue;
				}
			if (soap_flag_userRoleId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userRoleId", &a->userRoleId, "xsd:string"))
				{	soap_flag_userRoleId--;
					continue;
				}
			if (soap_flag_userGroupId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userGroupId", &a->userGroupId, "xsd:string"))
				{	soap_flag_userGroupId--;
					continue;
				}
			if (soap_flag_userClassId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userClassId", &a->userClassId, "xsd:string"))
				{	soap_flag_userClassId--;
					continue;
				}
			if (soap_flag_transactionId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "transactionId", &a->transactionId, "xsd:string"))
				{	soap_flag_transactionId--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdStopTransaction *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdStopTransaction, 0, sizeof(struct bmd230__bmdStopTransaction), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdStopTransaction(struct soap *soap, const struct bmd230__bmdStopTransaction *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdStopTransaction);
	if (soap_out_bmd230__bmdStopTransaction(soap, tag?tag:"bmd230:bmdStopTransaction", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdStopTransaction * SOAP_FMAC4 soap_get_bmd230__bmdStopTransaction(struct soap *soap, struct bmd230__bmdStopTransaction *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdStopTransaction(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdStopTransactionResponse(struct soap *soap, struct bmd230__bmdStopTransactionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdStopTransactionResponse(struct soap *soap, const struct bmd230__bmdStopTransactionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdStopTransactionResponse(struct soap *soap, const char *tag, int id, const struct bmd230__bmdStopTransactionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdStopTransactionResponse), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdStopTransactionResponse * SOAP_FMAC4 soap_in_bmd230__bmdStopTransactionResponse(struct soap *soap, const char *tag, struct bmd230__bmdStopTransactionResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdStopTransactionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdStopTransactionResponse, sizeof(struct bmd230__bmdStopTransactionResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdStopTransactionResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdStopTransactionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdStopTransactionResponse, 0, sizeof(struct bmd230__bmdStopTransactionResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdStopTransactionResponse(struct soap *soap, const struct bmd230__bmdStopTransactionResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdStopTransactionResponse);
	if (soap_out_bmd230__bmdStopTransactionResponse(soap, tag?tag:"bmd230:bmdStopTransactionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdStopTransactionResponse * SOAP_FMAC4 soap_get_bmd230__bmdStopTransactionResponse(struct soap *soap, struct bmd230__bmdStopTransactionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdStopTransactionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdStartTransaction(struct soap *soap, struct bmd230__bmdStartTransaction *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cert = NULL;
	soap_default_string(soap, &a->userRoleId);
	soap_default_string(soap, &a->userGroupId);
	soap_default_string(soap, &a->userClassId);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdStartTransaction(struct soap *soap, const struct bmd230__bmdStartTransaction *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__base64Binary(soap, &a->cert);
	soap_serialize_string(soap, &a->userRoleId);
	soap_serialize_string(soap, &a->userGroupId);
	soap_serialize_string(soap, &a->userClassId);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdStartTransaction(struct soap *soap, const char *tag, int id, const struct bmd230__bmdStartTransaction *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdStartTransaction), type))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "cert", -1, &a->cert, ""))
		return soap->error;
	if (soap_out_string(soap, "userRoleId", -1, &a->userRoleId, ""))
		return soap->error;
	if (soap_out_string(soap, "userGroupId", -1, &a->userGroupId, ""))
		return soap->error;
	if (soap_out_string(soap, "userClassId", -1, &a->userClassId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdStartTransaction * SOAP_FMAC4 soap_in_bmd230__bmdStartTransaction(struct soap *soap, const char *tag, struct bmd230__bmdStartTransaction *a, const char *type)
{
	size_t soap_flag_cert = 1;
	size_t soap_flag_userRoleId = 1;
	size_t soap_flag_userGroupId = 1;
	size_t soap_flag_userClassId = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdStartTransaction *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdStartTransaction, sizeof(struct bmd230__bmdStartTransaction), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdStartTransaction(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cert && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "cert", &a->cert, "xsd:base64Binary"))
				{	soap_flag_cert--;
					continue;
				}
			if (soap_flag_userRoleId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userRoleId", &a->userRoleId, "xsd:string"))
				{	soap_flag_userRoleId--;
					continue;
				}
			if (soap_flag_userGroupId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userGroupId", &a->userGroupId, "xsd:string"))
				{	soap_flag_userGroupId--;
					continue;
				}
			if (soap_flag_userClassId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userClassId", &a->userClassId, "xsd:string"))
				{	soap_flag_userClassId--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdStartTransaction *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdStartTransaction, 0, sizeof(struct bmd230__bmdStartTransaction), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdStartTransaction(struct soap *soap, const struct bmd230__bmdStartTransaction *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdStartTransaction);
	if (soap_out_bmd230__bmdStartTransaction(soap, tag?tag:"bmd230:bmdStartTransaction", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdStartTransaction * SOAP_FMAC4 soap_get_bmd230__bmdStartTransaction(struct soap *soap, struct bmd230__bmdStartTransaction *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdStartTransaction(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdStartTransactionResponse(struct soap *soap, struct bmd230__bmdStartTransactionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->transactionId = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdStartTransactionResponse(struct soap *soap, const struct bmd230__bmdStartTransactionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->transactionId);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdStartTransactionResponse(struct soap *soap, const char *tag, int id, const struct bmd230__bmdStartTransactionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdStartTransactionResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "transactionId", -1, &a->transactionId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdStartTransactionResponse * SOAP_FMAC4 soap_in_bmd230__bmdStartTransactionResponse(struct soap *soap, const char *tag, struct bmd230__bmdStartTransactionResponse *a, const char *type)
{
	size_t soap_flag_transactionId = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdStartTransactionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdStartTransactionResponse, sizeof(struct bmd230__bmdStartTransactionResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdStartTransactionResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_transactionId && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, "transactionId", &a->transactionId, "xsd:string"))
				{	soap_flag_transactionId--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdStartTransactionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdStartTransactionResponse, 0, sizeof(struct bmd230__bmdStartTransactionResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdStartTransactionResponse(struct soap *soap, const struct bmd230__bmdStartTransactionResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdStartTransactionResponse);
	if (soap_out_bmd230__bmdStartTransactionResponse(soap, tag?tag:"bmd230:bmdStartTransactionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdStartTransactionResponse * SOAP_FMAC4 soap_get_bmd230__bmdStartTransactionResponse(struct soap *soap, struct bmd230__bmdStartTransactionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdStartTransactionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdGetArchPackInChunk(struct soap *soap, struct bmd230__bmdGetArchPackInChunk *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cert = NULL;
	soap_default_string(soap, &a->userRoleId);
	soap_default_string(soap, &a->userGroupId);
	soap_default_string(soap, &a->userClassId);
	soap_default_long(soap, &a->id);
	soap_default_chunkCntr_t(soap, &a->cntrFlag);
	a->input = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdGetArchPackInChunk(struct soap *soap, const struct bmd230__bmdGetArchPackInChunk *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__base64Binary(soap, &a->cert);
	soap_serialize_string(soap, &a->userRoleId);
	soap_serialize_string(soap, &a->userGroupId);
	soap_serialize_string(soap, &a->userClassId);
	soap_embedded(soap, &a->id, SOAP_TYPE_long);
	soap_serialize_PointerTobmd230__archPackOut(soap, &a->input);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdGetArchPackInChunk(struct soap *soap, const char *tag, int id, const struct bmd230__bmdGetArchPackInChunk *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdGetArchPackInChunk), type))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "cert", -1, &a->cert, ""))
		return soap->error;
	if (soap_out_string(soap, "userRoleId", -1, &a->userRoleId, ""))
		return soap->error;
	if (soap_out_string(soap, "userGroupId", -1, &a->userGroupId, ""))
		return soap->error;
	if (soap_out_string(soap, "userClassId", -1, &a->userClassId, ""))
		return soap->error;
	if (soap_out_long(soap, "id", -1, &a->id, ""))
		return soap->error;
	if (soap_out_chunkCntr_t(soap, "cntrFlag", -1, &a->cntrFlag, ""))
		return soap->error;
	if (soap_out_PointerTobmd230__archPackOut(soap, "input", -1, &a->input, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdGetArchPackInChunk * SOAP_FMAC4 soap_in_bmd230__bmdGetArchPackInChunk(struct soap *soap, const char *tag, struct bmd230__bmdGetArchPackInChunk *a, const char *type)
{
	size_t soap_flag_cert = 1;
	size_t soap_flag_userRoleId = 1;
	size_t soap_flag_userGroupId = 1;
	size_t soap_flag_userClassId = 1;
	size_t soap_flag_id = 1;
	size_t soap_flag_cntrFlag = 1;
	size_t soap_flag_input = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdGetArchPackInChunk *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdGetArchPackInChunk, sizeof(struct bmd230__bmdGetArchPackInChunk), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdGetArchPackInChunk(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cert && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "cert", &a->cert, "xsd:base64Binary"))
				{	soap_flag_cert--;
					continue;
				}
			if (soap_flag_userRoleId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userRoleId", &a->userRoleId, "xsd:string"))
				{	soap_flag_userRoleId--;
					continue;
				}
			if (soap_flag_userGroupId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userGroupId", &a->userGroupId, "xsd:string"))
				{	soap_flag_userGroupId--;
					continue;
				}
			if (soap_flag_userClassId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userClassId", &a->userClassId, "xsd:string"))
				{	soap_flag_userClassId--;
					continue;
				}
			if (soap_flag_id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_long(soap, "id", &a->id, "xsd:long"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_cntrFlag && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_chunkCntr_t(soap, "cntrFlag", &a->cntrFlag, "chunkCntr-t"))
				{	soap_flag_cntrFlag--;
					continue;
				}
			if (soap_flag_input && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobmd230__archPackOut(soap, "input", &a->input, "bmd230:archPackOut"))
				{	soap_flag_input--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdGetArchPackInChunk *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdGetArchPackInChunk, 0, sizeof(struct bmd230__bmdGetArchPackInChunk), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0 || soap_flag_cntrFlag > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdGetArchPackInChunk(struct soap *soap, const struct bmd230__bmdGetArchPackInChunk *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdGetArchPackInChunk);
	if (soap_out_bmd230__bmdGetArchPackInChunk(soap, tag?tag:"bmd230:bmdGetArchPackInChunk", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdGetArchPackInChunk * SOAP_FMAC4 soap_get_bmd230__bmdGetArchPackInChunk(struct soap *soap, struct bmd230__bmdGetArchPackInChunk *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdGetArchPackInChunk(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdGetArchPackInChunkResponse(struct soap *soap, struct bmd230__bmdGetArchPackInChunkResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->output = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdGetArchPackInChunkResponse(struct soap *soap, const struct bmd230__bmdGetArchPackInChunkResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToPointerTobmd230__archPackOut(soap, &a->output);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdGetArchPackInChunkResponse(struct soap *soap, const char *tag, int id, const struct bmd230__bmdGetArchPackInChunkResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdGetArchPackInChunkResponse), type))
		return soap->error;
	if (soap_out_PointerToPointerTobmd230__archPackOut(soap, "output", -1, &a->output, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdGetArchPackInChunkResponse * SOAP_FMAC4 soap_in_bmd230__bmdGetArchPackInChunkResponse(struct soap *soap, const char *tag, struct bmd230__bmdGetArchPackInChunkResponse *a, const char *type)
{
	size_t soap_flag_output = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdGetArchPackInChunkResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdGetArchPackInChunkResponse, sizeof(struct bmd230__bmdGetArchPackInChunkResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdGetArchPackInChunkResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_output && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToPointerTobmd230__archPackOut(soap, "output", &a->output, "bmd230:archPackOut"))
				{	soap_flag_output--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdGetArchPackInChunkResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdGetArchPackInChunkResponse, 0, sizeof(struct bmd230__bmdGetArchPackInChunkResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdGetArchPackInChunkResponse(struct soap *soap, const struct bmd230__bmdGetArchPackInChunkResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdGetArchPackInChunkResponse);
	if (soap_out_bmd230__bmdGetArchPackInChunkResponse(soap, tag?tag:"bmd230:bmdGetArchPackInChunkResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdGetArchPackInChunkResponse * SOAP_FMAC4 soap_get_bmd230__bmdGetArchPackInChunkResponse(struct soap *soap, struct bmd230__bmdGetArchPackInChunkResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdGetArchPackInChunkResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdGetFileChunkIter(struct soap *soap, struct bmd230__bmdGetFileChunkIter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cert = NULL;
	soap_default_string(soap, &a->userRoleId);
	soap_default_string(soap, &a->userGroupId);
	soap_default_string(soap, &a->userClassId);
	soap_default_string(soap, &a->tmpdir);
	soap_default_string(soap, &a->count);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdGetFileChunkIter(struct soap *soap, const struct bmd230__bmdGetFileChunkIter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__base64Binary(soap, &a->cert);
	soap_serialize_string(soap, &a->userRoleId);
	soap_serialize_string(soap, &a->userGroupId);
	soap_serialize_string(soap, &a->userClassId);
	soap_serialize_string(soap, &a->tmpdir);
	soap_serialize_string(soap, &a->count);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdGetFileChunkIter(struct soap *soap, const char *tag, int id, const struct bmd230__bmdGetFileChunkIter *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdGetFileChunkIter), type))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "cert", -1, &a->cert, ""))
		return soap->error;
	if (soap_out_string(soap, "userRoleId", -1, &a->userRoleId, ""))
		return soap->error;
	if (soap_out_string(soap, "userGroupId", -1, &a->userGroupId, ""))
		return soap->error;
	if (soap_out_string(soap, "userClassId", -1, &a->userClassId, ""))
		return soap->error;
	if (soap_out_string(soap, "tmpdir", -1, &a->tmpdir, ""))
		return soap->error;
	if (soap_out_string(soap, "count", -1, &a->count, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdGetFileChunkIter * SOAP_FMAC4 soap_in_bmd230__bmdGetFileChunkIter(struct soap *soap, const char *tag, struct bmd230__bmdGetFileChunkIter *a, const char *type)
{
	size_t soap_flag_cert = 1;
	size_t soap_flag_userRoleId = 1;
	size_t soap_flag_userGroupId = 1;
	size_t soap_flag_userClassId = 1;
	size_t soap_flag_tmpdir = 1;
	size_t soap_flag_count = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdGetFileChunkIter *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdGetFileChunkIter, sizeof(struct bmd230__bmdGetFileChunkIter), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdGetFileChunkIter(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cert && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "cert", &a->cert, "xsd:base64Binary"))
				{	soap_flag_cert--;
					continue;
				}
			if (soap_flag_userRoleId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userRoleId", &a->userRoleId, "xsd:string"))
				{	soap_flag_userRoleId--;
					continue;
				}
			if (soap_flag_userGroupId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userGroupId", &a->userGroupId, "xsd:string"))
				{	soap_flag_userGroupId--;
					continue;
				}
			if (soap_flag_userClassId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userClassId", &a->userClassId, "xsd:string"))
				{	soap_flag_userClassId--;
					continue;
				}
			if (soap_flag_tmpdir && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tmpdir", &a->tmpdir, "xsd:string"))
				{	soap_flag_tmpdir--;
					continue;
				}
			if (soap_flag_count && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "count", &a->count, "xsd:string"))
				{	soap_flag_count--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdGetFileChunkIter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdGetFileChunkIter, 0, sizeof(struct bmd230__bmdGetFileChunkIter), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdGetFileChunkIter(struct soap *soap, const struct bmd230__bmdGetFileChunkIter *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdGetFileChunkIter);
	if (soap_out_bmd230__bmdGetFileChunkIter(soap, tag?tag:"bmd230:bmdGetFileChunkIter", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdGetFileChunkIter * SOAP_FMAC4 soap_get_bmd230__bmdGetFileChunkIter(struct soap *soap, struct bmd230__bmdGetFileChunkIter *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdGetFileChunkIter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdGetFileChunkIterResponse(struct soap *soap, struct bmd230__bmdGetFileChunkIterResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->output = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdGetFileChunkIterResponse(struct soap *soap, const struct bmd230__bmdGetFileChunkIterResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToPointerTobmd230__fileInfo(soap, &a->output);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdGetFileChunkIterResponse(struct soap *soap, const char *tag, int id, const struct bmd230__bmdGetFileChunkIterResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdGetFileChunkIterResponse), type))
		return soap->error;
	if (soap_out_PointerToPointerTobmd230__fileInfo(soap, "output", -1, &a->output, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdGetFileChunkIterResponse * SOAP_FMAC4 soap_in_bmd230__bmdGetFileChunkIterResponse(struct soap *soap, const char *tag, struct bmd230__bmdGetFileChunkIterResponse *a, const char *type)
{
	size_t soap_flag_output = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdGetFileChunkIterResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdGetFileChunkIterResponse, sizeof(struct bmd230__bmdGetFileChunkIterResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdGetFileChunkIterResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_output && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToPointerTobmd230__fileInfo(soap, "output", &a->output, "bmd230:fileInfo"))
				{	soap_flag_output--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdGetFileChunkIterResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdGetFileChunkIterResponse, 0, sizeof(struct bmd230__bmdGetFileChunkIterResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdGetFileChunkIterResponse(struct soap *soap, const struct bmd230__bmdGetFileChunkIterResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdGetFileChunkIterResponse);
	if (soap_out_bmd230__bmdGetFileChunkIterResponse(soap, tag?tag:"bmd230:bmdGetFileChunkIterResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdGetFileChunkIterResponse * SOAP_FMAC4 soap_get_bmd230__bmdGetFileChunkIterResponse(struct soap *soap, struct bmd230__bmdGetFileChunkIterResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdGetFileChunkIterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdGetFileChunkStart(struct soap *soap, struct bmd230__bmdGetFileChunkStart *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cert = NULL;
	soap_default_string(soap, &a->userRoleId);
	soap_default_string(soap, &a->userGroupId);
	soap_default_string(soap, &a->userClassId);
	soap_default_long(soap, &a->id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdGetFileChunkStart(struct soap *soap, const struct bmd230__bmdGetFileChunkStart *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__base64Binary(soap, &a->cert);
	soap_serialize_string(soap, &a->userRoleId);
	soap_serialize_string(soap, &a->userGroupId);
	soap_serialize_string(soap, &a->userClassId);
	soap_embedded(soap, &a->id, SOAP_TYPE_long);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdGetFileChunkStart(struct soap *soap, const char *tag, int id, const struct bmd230__bmdGetFileChunkStart *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdGetFileChunkStart), type))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "cert", -1, &a->cert, ""))
		return soap->error;
	if (soap_out_string(soap, "userRoleId", -1, &a->userRoleId, ""))
		return soap->error;
	if (soap_out_string(soap, "userGroupId", -1, &a->userGroupId, ""))
		return soap->error;
	if (soap_out_string(soap, "userClassId", -1, &a->userClassId, ""))
		return soap->error;
	if (soap_out_long(soap, "id", -1, &a->id, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdGetFileChunkStart * SOAP_FMAC4 soap_in_bmd230__bmdGetFileChunkStart(struct soap *soap, const char *tag, struct bmd230__bmdGetFileChunkStart *a, const char *type)
{
	size_t soap_flag_cert = 1;
	size_t soap_flag_userRoleId = 1;
	size_t soap_flag_userGroupId = 1;
	size_t soap_flag_userClassId = 1;
	size_t soap_flag_id = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdGetFileChunkStart *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdGetFileChunkStart, sizeof(struct bmd230__bmdGetFileChunkStart), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdGetFileChunkStart(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cert && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "cert", &a->cert, "xsd:base64Binary"))
				{	soap_flag_cert--;
					continue;
				}
			if (soap_flag_userRoleId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userRoleId", &a->userRoleId, "xsd:string"))
				{	soap_flag_userRoleId--;
					continue;
				}
			if (soap_flag_userGroupId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userGroupId", &a->userGroupId, "xsd:string"))
				{	soap_flag_userGroupId--;
					continue;
				}
			if (soap_flag_userClassId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userClassId", &a->userClassId, "xsd:string"))
				{	soap_flag_userClassId--;
					continue;
				}
			if (soap_flag_id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_long(soap, "id", &a->id, "xsd:long"))
				{	soap_flag_id--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdGetFileChunkStart *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdGetFileChunkStart, 0, sizeof(struct bmd230__bmdGetFileChunkStart), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdGetFileChunkStart(struct soap *soap, const struct bmd230__bmdGetFileChunkStart *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdGetFileChunkStart);
	if (soap_out_bmd230__bmdGetFileChunkStart(soap, tag?tag:"bmd230:bmdGetFileChunkStart", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdGetFileChunkStart * SOAP_FMAC4 soap_get_bmd230__bmdGetFileChunkStart(struct soap *soap, struct bmd230__bmdGetFileChunkStart *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdGetFileChunkStart(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdGetFileChunkStartResponse(struct soap *soap, struct bmd230__bmdGetFileChunkStartResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tmpdir = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdGetFileChunkStartResponse(struct soap *soap, const struct bmd230__bmdGetFileChunkStartResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->tmpdir);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdGetFileChunkStartResponse(struct soap *soap, const char *tag, int id, const struct bmd230__bmdGetFileChunkStartResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdGetFileChunkStartResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "tmpdir", -1, &a->tmpdir, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdGetFileChunkStartResponse * SOAP_FMAC4 soap_in_bmd230__bmdGetFileChunkStartResponse(struct soap *soap, const char *tag, struct bmd230__bmdGetFileChunkStartResponse *a, const char *type)
{
	size_t soap_flag_tmpdir = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdGetFileChunkStartResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdGetFileChunkStartResponse, sizeof(struct bmd230__bmdGetFileChunkStartResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdGetFileChunkStartResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tmpdir && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, "tmpdir", &a->tmpdir, "xsd:string"))
				{	soap_flag_tmpdir--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdGetFileChunkStartResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdGetFileChunkStartResponse, 0, sizeof(struct bmd230__bmdGetFileChunkStartResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdGetFileChunkStartResponse(struct soap *soap, const struct bmd230__bmdGetFileChunkStartResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdGetFileChunkStartResponse);
	if (soap_out_bmd230__bmdGetFileChunkStartResponse(soap, tag?tag:"bmd230:bmdGetFileChunkStartResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdGetFileChunkStartResponse * SOAP_FMAC4 soap_get_bmd230__bmdGetFileChunkStartResponse(struct soap *soap, struct bmd230__bmdGetFileChunkStartResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdGetFileChunkStartResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdInsertFileChunkIter(struct soap *soap, struct bmd230__bmdInsertFileChunkIter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cert = NULL;
	soap_default_string(soap, &a->userRoleId);
	soap_default_string(soap, &a->userGroupId);
	soap_default_string(soap, &a->userClassId);
	a->input = NULL;
	soap_default_string(soap, &a->tmpfilename);
	soap_default_string(soap, &a->count);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdInsertFileChunkIter(struct soap *soap, const struct bmd230__bmdInsertFileChunkIter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__base64Binary(soap, &a->cert);
	soap_serialize_string(soap, &a->userRoleId);
	soap_serialize_string(soap, &a->userGroupId);
	soap_serialize_string(soap, &a->userClassId);
	soap_serialize_PointerTobmd230__fileInfo(soap, &a->input);
	soap_serialize_string(soap, &a->tmpfilename);
	soap_serialize_string(soap, &a->count);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdInsertFileChunkIter(struct soap *soap, const char *tag, int id, const struct bmd230__bmdInsertFileChunkIter *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdInsertFileChunkIter), type))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "cert", -1, &a->cert, ""))
		return soap->error;
	if (soap_out_string(soap, "userRoleId", -1, &a->userRoleId, ""))
		return soap->error;
	if (soap_out_string(soap, "userGroupId", -1, &a->userGroupId, ""))
		return soap->error;
	if (soap_out_string(soap, "userClassId", -1, &a->userClassId, ""))
		return soap->error;
	if (soap_out_PointerTobmd230__fileInfo(soap, "input", -1, &a->input, ""))
		return soap->error;
	if (soap_out_string(soap, "tmpfilename", -1, &a->tmpfilename, ""))
		return soap->error;
	if (soap_out_string(soap, "count", -1, &a->count, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdInsertFileChunkIter * SOAP_FMAC4 soap_in_bmd230__bmdInsertFileChunkIter(struct soap *soap, const char *tag, struct bmd230__bmdInsertFileChunkIter *a, const char *type)
{
	size_t soap_flag_cert = 1;
	size_t soap_flag_userRoleId = 1;
	size_t soap_flag_userGroupId = 1;
	size_t soap_flag_userClassId = 1;
	size_t soap_flag_input = 1;
	size_t soap_flag_tmpfilename = 1;
	size_t soap_flag_count = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdInsertFileChunkIter *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdInsertFileChunkIter, sizeof(struct bmd230__bmdInsertFileChunkIter), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdInsertFileChunkIter(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cert && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "cert", &a->cert, "xsd:base64Binary"))
				{	soap_flag_cert--;
					continue;
				}
			if (soap_flag_userRoleId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userRoleId", &a->userRoleId, "xsd:string"))
				{	soap_flag_userRoleId--;
					continue;
				}
			if (soap_flag_userGroupId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userGroupId", &a->userGroupId, "xsd:string"))
				{	soap_flag_userGroupId--;
					continue;
				}
			if (soap_flag_userClassId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userClassId", &a->userClassId, "xsd:string"))
				{	soap_flag_userClassId--;
					continue;
				}
			if (soap_flag_input && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobmd230__fileInfo(soap, "input", &a->input, "bmd230:fileInfo"))
				{	soap_flag_input--;
					continue;
				}
			if (soap_flag_tmpfilename && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tmpfilename", &a->tmpfilename, "xsd:string"))
				{	soap_flag_tmpfilename--;
					continue;
				}
			if (soap_flag_count && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "count", &a->count, "xsd:string"))
				{	soap_flag_count--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdInsertFileChunkIter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdInsertFileChunkIter, 0, sizeof(struct bmd230__bmdInsertFileChunkIter), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdInsertFileChunkIter(struct soap *soap, const struct bmd230__bmdInsertFileChunkIter *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdInsertFileChunkIter);
	if (soap_out_bmd230__bmdInsertFileChunkIter(soap, tag?tag:"bmd230:bmdInsertFileChunkIter", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdInsertFileChunkIter * SOAP_FMAC4 soap_get_bmd230__bmdInsertFileChunkIter(struct soap *soap, struct bmd230__bmdInsertFileChunkIter *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdInsertFileChunkIter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdInsertFileChunkIterResponse(struct soap *soap, struct bmd230__bmdInsertFileChunkIterResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdInsertFileChunkIterResponse(struct soap *soap, const struct bmd230__bmdInsertFileChunkIterResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTolong(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdInsertFileChunkIterResponse(struct soap *soap, const char *tag, int id, const struct bmd230__bmdInsertFileChunkIterResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdInsertFileChunkIterResponse), type))
		return soap->error;
	if (soap_out_PointerTolong(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdInsertFileChunkIterResponse * SOAP_FMAC4 soap_in_bmd230__bmdInsertFileChunkIterResponse(struct soap *soap, const char *tag, struct bmd230__bmdInsertFileChunkIterResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdInsertFileChunkIterResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdInsertFileChunkIterResponse, sizeof(struct bmd230__bmdInsertFileChunkIterResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdInsertFileChunkIterResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTolong(soap, "result", &a->result, "xsd:long"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdInsertFileChunkIterResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdInsertFileChunkIterResponse, 0, sizeof(struct bmd230__bmdInsertFileChunkIterResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdInsertFileChunkIterResponse(struct soap *soap, const struct bmd230__bmdInsertFileChunkIterResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdInsertFileChunkIterResponse);
	if (soap_out_bmd230__bmdInsertFileChunkIterResponse(soap, tag?tag:"bmd230:bmdInsertFileChunkIterResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdInsertFileChunkIterResponse * SOAP_FMAC4 soap_get_bmd230__bmdInsertFileChunkIterResponse(struct soap *soap, struct bmd230__bmdInsertFileChunkIterResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdInsertFileChunkIterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdInsertFileChunkStart(struct soap *soap, struct bmd230__bmdInsertFileChunkStart *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cert = NULL;
	soap_default_string(soap, &a->userRoleId);
	soap_default_string(soap, &a->userGroupId);
	soap_default_string(soap, &a->userClassId);
	a->mtds = NULL;
	soap_default_string(soap, &a->finalfilename);
	soap_default_long(soap, &a->totalfilesize);
	soap_default_string(soap, &a->transactionId);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdInsertFileChunkStart(struct soap *soap, const struct bmd230__bmdInsertFileChunkStart *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__base64Binary(soap, &a->cert);
	soap_serialize_string(soap, &a->userRoleId);
	soap_serialize_string(soap, &a->userGroupId);
	soap_serialize_string(soap, &a->userClassId);
	soap_serialize_PointerTobmd230__mtdsValues(soap, &a->mtds);
	soap_serialize_string(soap, &a->finalfilename);
	soap_embedded(soap, &a->totalfilesize, SOAP_TYPE_long);
	soap_serialize_string(soap, &a->transactionId);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdInsertFileChunkStart(struct soap *soap, const char *tag, int id, const struct bmd230__bmdInsertFileChunkStart *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdInsertFileChunkStart), type))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "cert", -1, &a->cert, ""))
		return soap->error;
	if (soap_out_string(soap, "userRoleId", -1, &a->userRoleId, ""))
		return soap->error;
	if (soap_out_string(soap, "userGroupId", -1, &a->userGroupId, ""))
		return soap->error;
	if (soap_out_string(soap, "userClassId", -1, &a->userClassId, ""))
		return soap->error;
	if (soap_out_PointerTobmd230__mtdsValues(soap, "mtds", -1, &a->mtds, ""))
		return soap->error;
	if (soap_out_string(soap, "finalfilename", -1, &a->finalfilename, ""))
		return soap->error;
	if (soap_out_long(soap, "totalfilesize", -1, &a->totalfilesize, ""))
		return soap->error;
	if (soap_out_string(soap, "transactionId", -1, &a->transactionId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdInsertFileChunkStart * SOAP_FMAC4 soap_in_bmd230__bmdInsertFileChunkStart(struct soap *soap, const char *tag, struct bmd230__bmdInsertFileChunkStart *a, const char *type)
{
	size_t soap_flag_cert = 1;
	size_t soap_flag_userRoleId = 1;
	size_t soap_flag_userGroupId = 1;
	size_t soap_flag_userClassId = 1;
	size_t soap_flag_mtds = 1;
	size_t soap_flag_finalfilename = 1;
	size_t soap_flag_totalfilesize = 1;
	size_t soap_flag_transactionId = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdInsertFileChunkStart *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdInsertFileChunkStart, sizeof(struct bmd230__bmdInsertFileChunkStart), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdInsertFileChunkStart(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cert && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "cert", &a->cert, "xsd:base64Binary"))
				{	soap_flag_cert--;
					continue;
				}
			if (soap_flag_userRoleId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userRoleId", &a->userRoleId, "xsd:string"))
				{	soap_flag_userRoleId--;
					continue;
				}
			if (soap_flag_userGroupId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userGroupId", &a->userGroupId, "xsd:string"))
				{	soap_flag_userGroupId--;
					continue;
				}
			if (soap_flag_userClassId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userClassId", &a->userClassId, "xsd:string"))
				{	soap_flag_userClassId--;
					continue;
				}
			if (soap_flag_mtds && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobmd230__mtdsValues(soap, "mtds", &a->mtds, "bmd230:mtdsValues"))
				{	soap_flag_mtds--;
					continue;
				}
			if (soap_flag_finalfilename && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "finalfilename", &a->finalfilename, "xsd:string"))
				{	soap_flag_finalfilename--;
					continue;
				}
			if (soap_flag_totalfilesize && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_long(soap, "totalfilesize", &a->totalfilesize, "xsd:long"))
				{	soap_flag_totalfilesize--;
					continue;
				}
			if (soap_flag_transactionId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "transactionId", &a->transactionId, "xsd:string"))
				{	soap_flag_transactionId--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdInsertFileChunkStart *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdInsertFileChunkStart, 0, sizeof(struct bmd230__bmdInsertFileChunkStart), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_totalfilesize > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdInsertFileChunkStart(struct soap *soap, const struct bmd230__bmdInsertFileChunkStart *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdInsertFileChunkStart);
	if (soap_out_bmd230__bmdInsertFileChunkStart(soap, tag?tag:"bmd230:bmdInsertFileChunkStart", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdInsertFileChunkStart * SOAP_FMAC4 soap_get_bmd230__bmdInsertFileChunkStart(struct soap *soap, struct bmd230__bmdInsertFileChunkStart *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdInsertFileChunkStart(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdInsertFileChunkStartResponse(struct soap *soap, struct bmd230__bmdInsertFileChunkStartResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tmpfilename = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdInsertFileChunkStartResponse(struct soap *soap, const struct bmd230__bmdInsertFileChunkStartResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->tmpfilename);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdInsertFileChunkStartResponse(struct soap *soap, const char *tag, int id, const struct bmd230__bmdInsertFileChunkStartResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdInsertFileChunkStartResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "tmpfilename", -1, &a->tmpfilename, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdInsertFileChunkStartResponse * SOAP_FMAC4 soap_in_bmd230__bmdInsertFileChunkStartResponse(struct soap *soap, const char *tag, struct bmd230__bmdInsertFileChunkStartResponse *a, const char *type)
{
	size_t soap_flag_tmpfilename = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdInsertFileChunkStartResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdInsertFileChunkStartResponse, sizeof(struct bmd230__bmdInsertFileChunkStartResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdInsertFileChunkStartResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tmpfilename && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, "tmpfilename", &a->tmpfilename, "xsd:string"))
				{	soap_flag_tmpfilename--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdInsertFileChunkStartResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdInsertFileChunkStartResponse, 0, sizeof(struct bmd230__bmdInsertFileChunkStartResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdInsertFileChunkStartResponse(struct soap *soap, const struct bmd230__bmdInsertFileChunkStartResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdInsertFileChunkStartResponse);
	if (soap_out_bmd230__bmdInsertFileChunkStartResponse(soap, tag?tag:"bmd230:bmdInsertFileChunkStartResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdInsertFileChunkStartResponse * SOAP_FMAC4 soap_get_bmd230__bmdInsertFileChunkStartResponse(struct soap *soap, struct bmd230__bmdInsertFileChunkStartResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdInsertFileChunkStartResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__getFile(struct soap *soap, struct bmd230__getFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->accountId);
	soap_default_string(soap, &a->invoiceId);
	soap_default_string(soap, &a->userIdentifier);
	soap_default_string(soap, &a->getReason);
	a->cert = NULL;
	soap_default_string(soap, &a->userRoleId);
	soap_default_string(soap, &a->userGroupId);
	soap_default_string(soap, &a->userClassId);
	soap_default_trans_t(soap, &a->type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__getFile(struct soap *soap, const struct bmd230__getFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->accountId);
	soap_serialize_string(soap, &a->invoiceId);
	soap_serialize_string(soap, &a->userIdentifier);
	soap_serialize_string(soap, &a->getReason);
	soap_serialize_PointerToxsd__base64Binary(soap, &a->cert);
	soap_serialize_string(soap, &a->userRoleId);
	soap_serialize_string(soap, &a->userGroupId);
	soap_serialize_string(soap, &a->userClassId);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__getFile(struct soap *soap, const char *tag, int id, const struct bmd230__getFile *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__getFile), type))
		return soap->error;
	if (soap_out_string(soap, "accountId", -1, &a->accountId, ""))
		return soap->error;
	if (soap_out_string(soap, "invoiceId", -1, &a->invoiceId, ""))
		return soap->error;
	if (soap_out_string(soap, "userIdentifier", -1, &a->userIdentifier, ""))
		return soap->error;
	if (soap_out_string(soap, "getReason", -1, &a->getReason, ""))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "cert", -1, &a->cert, ""))
		return soap->error;
	if (soap_out_string(soap, "userRoleId", -1, &a->userRoleId, ""))
		return soap->error;
	if (soap_out_string(soap, "userGroupId", -1, &a->userGroupId, ""))
		return soap->error;
	if (soap_out_string(soap, "userClassId", -1, &a->userClassId, ""))
		return soap->error;
	if (soap_out_trans_t(soap, "type", -1, &a->type, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__getFile * SOAP_FMAC4 soap_in_bmd230__getFile(struct soap *soap, const char *tag, struct bmd230__getFile *a, const char *type)
{
	size_t soap_flag_accountId = 1;
	size_t soap_flag_invoiceId = 1;
	size_t soap_flag_userIdentifier = 1;
	size_t soap_flag_getReason = 1;
	size_t soap_flag_cert = 1;
	size_t soap_flag_userRoleId = 1;
	size_t soap_flag_userGroupId = 1;
	size_t soap_flag_userClassId = 1;
	size_t soap_flag_type = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__getFile *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__getFile, sizeof(struct bmd230__getFile), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__getFile(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_accountId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "accountId", &a->accountId, "xsd:string"))
				{	soap_flag_accountId--;
					continue;
				}
			if (soap_flag_invoiceId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "invoiceId", &a->invoiceId, "xsd:string"))
				{	soap_flag_invoiceId--;
					continue;
				}
			if (soap_flag_userIdentifier && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userIdentifier", &a->userIdentifier, "xsd:string"))
				{	soap_flag_userIdentifier--;
					continue;
				}
			if (soap_flag_getReason && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "getReason", &a->getReason, "xsd:string"))
				{	soap_flag_getReason--;
					continue;
				}
			if (soap_flag_cert && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "cert", &a->cert, "xsd:base64Binary"))
				{	soap_flag_cert--;
					continue;
				}
			if (soap_flag_userRoleId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userRoleId", &a->userRoleId, "xsd:string"))
				{	soap_flag_userRoleId--;
					continue;
				}
			if (soap_flag_userGroupId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userGroupId", &a->userGroupId, "xsd:string"))
				{	soap_flag_userGroupId--;
					continue;
				}
			if (soap_flag_userClassId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userClassId", &a->userClassId, "xsd:string"))
				{	soap_flag_userClassId--;
					continue;
				}
			if (soap_flag_type && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_trans_t(soap, "type", &a->type, "trans-t"))
				{	soap_flag_type--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__getFile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__getFile, 0, sizeof(struct bmd230__getFile), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_type > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__getFile(struct soap *soap, const struct bmd230__getFile *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__getFile);
	if (soap_out_bmd230__getFile(soap, tag?tag:"bmd230:getFile", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__getFile * SOAP_FMAC4 soap_get_bmd230__getFile(struct soap *soap, struct bmd230__getFile *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__getFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__getFileResponse(struct soap *soap, struct bmd230__getFileResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->output = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__getFileResponse(struct soap *soap, const struct bmd230__getFileResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToPointerTobmd230__fileInfo(soap, &a->output);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__getFileResponse(struct soap *soap, const char *tag, int id, const struct bmd230__getFileResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__getFileResponse), type))
		return soap->error;
	if (soap_out_PointerToPointerTobmd230__fileInfo(soap, "output", -1, &a->output, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__getFileResponse * SOAP_FMAC4 soap_in_bmd230__getFileResponse(struct soap *soap, const char *tag, struct bmd230__getFileResponse *a, const char *type)
{
	size_t soap_flag_output = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__getFileResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__getFileResponse, sizeof(struct bmd230__getFileResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__getFileResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_output && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToPointerTobmd230__fileInfo(soap, "output", &a->output, "bmd230:fileInfo"))
				{	soap_flag_output--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__getFileResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__getFileResponse, 0, sizeof(struct bmd230__getFileResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__getFileResponse(struct soap *soap, const struct bmd230__getFileResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__getFileResponse);
	if (soap_out_bmd230__getFileResponse(soap, tag?tag:"bmd230:getFileResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__getFileResponse * SOAP_FMAC4 soap_get_bmd230__getFileResponse(struct soap *soap, struct bmd230__getFileResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__getFileResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__countInvoice(struct soap *soap, struct bmd230__countInvoice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->accountId);
	soap_default_string(soap, &a->invoiceId);
	soap_default_string(soap, &a->userIdentifier);
	a->cert = NULL;
	soap_default_string(soap, &a->userRoleId);
	soap_default_string(soap, &a->userGroupId);
	soap_default_string(soap, &a->userClassId);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__countInvoice(struct soap *soap, const struct bmd230__countInvoice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->accountId);
	soap_serialize_string(soap, &a->invoiceId);
	soap_serialize_string(soap, &a->userIdentifier);
	soap_serialize_PointerToxsd__base64Binary(soap, &a->cert);
	soap_serialize_string(soap, &a->userRoleId);
	soap_serialize_string(soap, &a->userGroupId);
	soap_serialize_string(soap, &a->userClassId);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__countInvoice(struct soap *soap, const char *tag, int id, const struct bmd230__countInvoice *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__countInvoice), type))
		return soap->error;
	if (soap_out_string(soap, "accountId", -1, &a->accountId, ""))
		return soap->error;
	if (soap_out_string(soap, "invoiceId", -1, &a->invoiceId, ""))
		return soap->error;
	if (soap_out_string(soap, "userIdentifier", -1, &a->userIdentifier, ""))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "cert", -1, &a->cert, ""))
		return soap->error;
	if (soap_out_string(soap, "userRoleId", -1, &a->userRoleId, ""))
		return soap->error;
	if (soap_out_string(soap, "userGroupId", -1, &a->userGroupId, ""))
		return soap->error;
	if (soap_out_string(soap, "userClassId", -1, &a->userClassId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__countInvoice * SOAP_FMAC4 soap_in_bmd230__countInvoice(struct soap *soap, const char *tag, struct bmd230__countInvoice *a, const char *type)
{
	size_t soap_flag_accountId = 1;
	size_t soap_flag_invoiceId = 1;
	size_t soap_flag_userIdentifier = 1;
	size_t soap_flag_cert = 1;
	size_t soap_flag_userRoleId = 1;
	size_t soap_flag_userGroupId = 1;
	size_t soap_flag_userClassId = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__countInvoice *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__countInvoice, sizeof(struct bmd230__countInvoice), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__countInvoice(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_accountId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "accountId", &a->accountId, "xsd:string"))
				{	soap_flag_accountId--;
					continue;
				}
			if (soap_flag_invoiceId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "invoiceId", &a->invoiceId, "xsd:string"))
				{	soap_flag_invoiceId--;
					continue;
				}
			if (soap_flag_userIdentifier && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userIdentifier", &a->userIdentifier, "xsd:string"))
				{	soap_flag_userIdentifier--;
					continue;
				}
			if (soap_flag_cert && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "cert", &a->cert, "xsd:base64Binary"))
				{	soap_flag_cert--;
					continue;
				}
			if (soap_flag_userRoleId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userRoleId", &a->userRoleId, "xsd:string"))
				{	soap_flag_userRoleId--;
					continue;
				}
			if (soap_flag_userGroupId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userGroupId", &a->userGroupId, "xsd:string"))
				{	soap_flag_userGroupId--;
					continue;
				}
			if (soap_flag_userClassId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userClassId", &a->userClassId, "xsd:string"))
				{	soap_flag_userClassId--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__countInvoice *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__countInvoice, 0, sizeof(struct bmd230__countInvoice), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__countInvoice(struct soap *soap, const struct bmd230__countInvoice *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__countInvoice);
	if (soap_out_bmd230__countInvoice(soap, tag?tag:"bmd230:countInvoice", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__countInvoice * SOAP_FMAC4 soap_get_bmd230__countInvoice(struct soap *soap, struct bmd230__countInvoice *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__countInvoice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__countInvoiceResponse(struct soap *soap, struct bmd230__countInvoiceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->count = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__countInvoiceResponse(struct soap *soap, const struct bmd230__countInvoiceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->count);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__countInvoiceResponse(struct soap *soap, const char *tag, int id, const struct bmd230__countInvoiceResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__countInvoiceResponse), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "count", -1, &a->count, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__countInvoiceResponse * SOAP_FMAC4 soap_in_bmd230__countInvoiceResponse(struct soap *soap, const char *tag, struct bmd230__countInvoiceResponse *a, const char *type)
{
	size_t soap_flag_count = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__countInvoiceResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__countInvoiceResponse, sizeof(struct bmd230__countInvoiceResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__countInvoiceResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_count && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "count", &a->count, "xsd:int"))
				{	soap_flag_count--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__countInvoiceResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__countInvoiceResponse, 0, sizeof(struct bmd230__countInvoiceResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__countInvoiceResponse(struct soap *soap, const struct bmd230__countInvoiceResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__countInvoiceResponse);
	if (soap_out_bmd230__countInvoiceResponse(soap, tag?tag:"bmd230:countInvoiceResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__countInvoiceResponse * SOAP_FMAC4 soap_get_bmd230__countInvoiceResponse(struct soap *soap, struct bmd230__countInvoiceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__countInvoiceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__verifyInvoiceWithDetails(struct soap *soap, struct bmd230__verifyInvoiceWithDetails *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->accountId);
	soap_default_string(soap, &a->invoiceId);
	soap_default_string(soap, &a->userIdentifier);
	soap_default_int(soap, &a->forceVerification);
	a->cert = NULL;
	soap_default_string(soap, &a->userRoleId);
	soap_default_string(soap, &a->userGroupId);
	soap_default_string(soap, &a->userClassId);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__verifyInvoiceWithDetails(struct soap *soap, const struct bmd230__verifyInvoiceWithDetails *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->accountId);
	soap_serialize_string(soap, &a->invoiceId);
	soap_serialize_string(soap, &a->userIdentifier);
	soap_embedded(soap, &a->forceVerification, SOAP_TYPE_int);
	soap_serialize_PointerToxsd__base64Binary(soap, &a->cert);
	soap_serialize_string(soap, &a->userRoleId);
	soap_serialize_string(soap, &a->userGroupId);
	soap_serialize_string(soap, &a->userClassId);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__verifyInvoiceWithDetails(struct soap *soap, const char *tag, int id, const struct bmd230__verifyInvoiceWithDetails *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__verifyInvoiceWithDetails), type))
		return soap->error;
	if (soap_out_string(soap, "accountId", -1, &a->accountId, ""))
		return soap->error;
	if (soap_out_string(soap, "invoiceId", -1, &a->invoiceId, ""))
		return soap->error;
	if (soap_out_string(soap, "userIdentifier", -1, &a->userIdentifier, ""))
		return soap->error;
	if (soap_out_int(soap, "forceVerification", -1, &a->forceVerification, ""))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "cert", -1, &a->cert, ""))
		return soap->error;
	if (soap_out_string(soap, "userRoleId", -1, &a->userRoleId, ""))
		return soap->error;
	if (soap_out_string(soap, "userGroupId", -1, &a->userGroupId, ""))
		return soap->error;
	if (soap_out_string(soap, "userClassId", -1, &a->userClassId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__verifyInvoiceWithDetails * SOAP_FMAC4 soap_in_bmd230__verifyInvoiceWithDetails(struct soap *soap, const char *tag, struct bmd230__verifyInvoiceWithDetails *a, const char *type)
{
	size_t soap_flag_accountId = 1;
	size_t soap_flag_invoiceId = 1;
	size_t soap_flag_userIdentifier = 1;
	size_t soap_flag_forceVerification = 1;
	size_t soap_flag_cert = 1;
	size_t soap_flag_userRoleId = 1;
	size_t soap_flag_userGroupId = 1;
	size_t soap_flag_userClassId = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__verifyInvoiceWithDetails *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__verifyInvoiceWithDetails, sizeof(struct bmd230__verifyInvoiceWithDetails), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__verifyInvoiceWithDetails(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_accountId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "accountId", &a->accountId, "xsd:string"))
				{	soap_flag_accountId--;
					continue;
				}
			if (soap_flag_invoiceId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "invoiceId", &a->invoiceId, "xsd:string"))
				{	soap_flag_invoiceId--;
					continue;
				}
			if (soap_flag_userIdentifier && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userIdentifier", &a->userIdentifier, "xsd:string"))
				{	soap_flag_userIdentifier--;
					continue;
				}
			if (soap_flag_forceVerification && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "forceVerification", &a->forceVerification, "xsd:int"))
				{	soap_flag_forceVerification--;
					continue;
				}
			if (soap_flag_cert && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "cert", &a->cert, "xsd:base64Binary"))
				{	soap_flag_cert--;
					continue;
				}
			if (soap_flag_userRoleId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userRoleId", &a->userRoleId, "xsd:string"))
				{	soap_flag_userRoleId--;
					continue;
				}
			if (soap_flag_userGroupId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userGroupId", &a->userGroupId, "xsd:string"))
				{	soap_flag_userGroupId--;
					continue;
				}
			if (soap_flag_userClassId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userClassId", &a->userClassId, "xsd:string"))
				{	soap_flag_userClassId--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__verifyInvoiceWithDetails *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__verifyInvoiceWithDetails, 0, sizeof(struct bmd230__verifyInvoiceWithDetails), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_forceVerification > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__verifyInvoiceWithDetails(struct soap *soap, const struct bmd230__verifyInvoiceWithDetails *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__verifyInvoiceWithDetails);
	if (soap_out_bmd230__verifyInvoiceWithDetails(soap, tag?tag:"bmd230:verifyInvoiceWithDetails", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__verifyInvoiceWithDetails * SOAP_FMAC4 soap_get_bmd230__verifyInvoiceWithDetails(struct soap *soap, struct bmd230__verifyInvoiceWithDetails *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__verifyInvoiceWithDetails(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__verifyInvoiceWithDetailsResponse(struct soap *soap, struct bmd230__verifyInvoiceWithDetailsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->output = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__verifyInvoiceWithDetailsResponse(struct soap *soap, const struct bmd230__verifyInvoiceWithDetailsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToPointerTobmd230__fileInfo(soap, &a->output);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__verifyInvoiceWithDetailsResponse(struct soap *soap, const char *tag, int id, const struct bmd230__verifyInvoiceWithDetailsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__verifyInvoiceWithDetailsResponse), type))
		return soap->error;
	if (soap_out_PointerToPointerTobmd230__fileInfo(soap, "output", -1, &a->output, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__verifyInvoiceWithDetailsResponse * SOAP_FMAC4 soap_in_bmd230__verifyInvoiceWithDetailsResponse(struct soap *soap, const char *tag, struct bmd230__verifyInvoiceWithDetailsResponse *a, const char *type)
{
	size_t soap_flag_output = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__verifyInvoiceWithDetailsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__verifyInvoiceWithDetailsResponse, sizeof(struct bmd230__verifyInvoiceWithDetailsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__verifyInvoiceWithDetailsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_output && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToPointerTobmd230__fileInfo(soap, "output", &a->output, "bmd230:fileInfo"))
				{	soap_flag_output--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__verifyInvoiceWithDetailsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__verifyInvoiceWithDetailsResponse, 0, sizeof(struct bmd230__verifyInvoiceWithDetailsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__verifyInvoiceWithDetailsResponse(struct soap *soap, const struct bmd230__verifyInvoiceWithDetailsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__verifyInvoiceWithDetailsResponse);
	if (soap_out_bmd230__verifyInvoiceWithDetailsResponse(soap, tag?tag:"bmd230:verifyInvoiceWithDetailsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__verifyInvoiceWithDetailsResponse * SOAP_FMAC4 soap_get_bmd230__verifyInvoiceWithDetailsResponse(struct soap *soap, struct bmd230__verifyInvoiceWithDetailsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__verifyInvoiceWithDetailsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__verifyInvoiceSimplified(struct soap *soap, struct bmd230__verifyInvoiceSimplified *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->accountId);
	soap_default_string(soap, &a->invoiceId);
	soap_default_string(soap, &a->userIdentifier);
	soap_default_int(soap, &a->forceVerification);
	a->cert = NULL;
	soap_default_string(soap, &a->userRoleId);
	soap_default_string(soap, &a->userGroupId);
	soap_default_string(soap, &a->userClassId);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__verifyInvoiceSimplified(struct soap *soap, const struct bmd230__verifyInvoiceSimplified *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->accountId);
	soap_serialize_string(soap, &a->invoiceId);
	soap_serialize_string(soap, &a->userIdentifier);
	soap_embedded(soap, &a->forceVerification, SOAP_TYPE_int);
	soap_serialize_PointerToxsd__base64Binary(soap, &a->cert);
	soap_serialize_string(soap, &a->userRoleId);
	soap_serialize_string(soap, &a->userGroupId);
	soap_serialize_string(soap, &a->userClassId);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__verifyInvoiceSimplified(struct soap *soap, const char *tag, int id, const struct bmd230__verifyInvoiceSimplified *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__verifyInvoiceSimplified), type))
		return soap->error;
	if (soap_out_string(soap, "accountId", -1, &a->accountId, ""))
		return soap->error;
	if (soap_out_string(soap, "invoiceId", -1, &a->invoiceId, ""))
		return soap->error;
	if (soap_out_string(soap, "userIdentifier", -1, &a->userIdentifier, ""))
		return soap->error;
	if (soap_out_int(soap, "forceVerification", -1, &a->forceVerification, ""))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "cert", -1, &a->cert, ""))
		return soap->error;
	if (soap_out_string(soap, "userRoleId", -1, &a->userRoleId, ""))
		return soap->error;
	if (soap_out_string(soap, "userGroupId", -1, &a->userGroupId, ""))
		return soap->error;
	if (soap_out_string(soap, "userClassId", -1, &a->userClassId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__verifyInvoiceSimplified * SOAP_FMAC4 soap_in_bmd230__verifyInvoiceSimplified(struct soap *soap, const char *tag, struct bmd230__verifyInvoiceSimplified *a, const char *type)
{
	size_t soap_flag_accountId = 1;
	size_t soap_flag_invoiceId = 1;
	size_t soap_flag_userIdentifier = 1;
	size_t soap_flag_forceVerification = 1;
	size_t soap_flag_cert = 1;
	size_t soap_flag_userRoleId = 1;
	size_t soap_flag_userGroupId = 1;
	size_t soap_flag_userClassId = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__verifyInvoiceSimplified *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__verifyInvoiceSimplified, sizeof(struct bmd230__verifyInvoiceSimplified), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__verifyInvoiceSimplified(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_accountId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "accountId", &a->accountId, "xsd:string"))
				{	soap_flag_accountId--;
					continue;
				}
			if (soap_flag_invoiceId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "invoiceId", &a->invoiceId, "xsd:string"))
				{	soap_flag_invoiceId--;
					continue;
				}
			if (soap_flag_userIdentifier && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userIdentifier", &a->userIdentifier, "xsd:string"))
				{	soap_flag_userIdentifier--;
					continue;
				}
			if (soap_flag_forceVerification && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "forceVerification", &a->forceVerification, "xsd:int"))
				{	soap_flag_forceVerification--;
					continue;
				}
			if (soap_flag_cert && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "cert", &a->cert, "xsd:base64Binary"))
				{	soap_flag_cert--;
					continue;
				}
			if (soap_flag_userRoleId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userRoleId", &a->userRoleId, "xsd:string"))
				{	soap_flag_userRoleId--;
					continue;
				}
			if (soap_flag_userGroupId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userGroupId", &a->userGroupId, "xsd:string"))
				{	soap_flag_userGroupId--;
					continue;
				}
			if (soap_flag_userClassId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userClassId", &a->userClassId, "xsd:string"))
				{	soap_flag_userClassId--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__verifyInvoiceSimplified *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__verifyInvoiceSimplified, 0, sizeof(struct bmd230__verifyInvoiceSimplified), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_forceVerification > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__verifyInvoiceSimplified(struct soap *soap, const struct bmd230__verifyInvoiceSimplified *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__verifyInvoiceSimplified);
	if (soap_out_bmd230__verifyInvoiceSimplified(soap, tag?tag:"bmd230:verifyInvoiceSimplified", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__verifyInvoiceSimplified * SOAP_FMAC4 soap_get_bmd230__verifyInvoiceSimplified(struct soap *soap, struct bmd230__verifyInvoiceSimplified *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__verifyInvoiceSimplified(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__verifyInvoiceSimplifiedResponse(struct soap *soap, struct bmd230__verifyInvoiceSimplifiedResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__verifyInvoiceSimplifiedResponse(struct soap *soap, const struct bmd230__verifyInvoiceSimplifiedResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__verifyInvoiceSimplifiedResponse(struct soap *soap, const char *tag, int id, const struct bmd230__verifyInvoiceSimplifiedResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__verifyInvoiceSimplifiedResponse), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__verifyInvoiceSimplifiedResponse * SOAP_FMAC4 soap_in_bmd230__verifyInvoiceSimplifiedResponse(struct soap *soap, const char *tag, struct bmd230__verifyInvoiceSimplifiedResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__verifyInvoiceSimplifiedResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__verifyInvoiceSimplifiedResponse, sizeof(struct bmd230__verifyInvoiceSimplifiedResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__verifyInvoiceSimplifiedResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__verifyInvoiceSimplifiedResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__verifyInvoiceSimplifiedResponse, 0, sizeof(struct bmd230__verifyInvoiceSimplifiedResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__verifyInvoiceSimplifiedResponse(struct soap *soap, const struct bmd230__verifyInvoiceSimplifiedResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__verifyInvoiceSimplifiedResponse);
	if (soap_out_bmd230__verifyInvoiceSimplifiedResponse(soap, tag?tag:"bmd230:verifyInvoiceSimplifiedResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__verifyInvoiceSimplifiedResponse * SOAP_FMAC4 soap_get_bmd230__verifyInvoiceSimplifiedResponse(struct soap *soap, struct bmd230__verifyInvoiceSimplifiedResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__verifyInvoiceSimplifiedResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__verifyInvoice(struct soap *soap, struct bmd230__verifyInvoice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->accountId);
	soap_default_string(soap, &a->invoiceId);
	soap_default_string(soap, &a->userIdentifier);
	soap_default_int(soap, &a->forceVerification);
	a->cert = NULL;
	soap_default_string(soap, &a->userRoleId);
	soap_default_string(soap, &a->userGroupId);
	soap_default_string(soap, &a->userClassId);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__verifyInvoice(struct soap *soap, const struct bmd230__verifyInvoice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->accountId);
	soap_serialize_string(soap, &a->invoiceId);
	soap_serialize_string(soap, &a->userIdentifier);
	soap_embedded(soap, &a->forceVerification, SOAP_TYPE_int);
	soap_serialize_PointerToxsd__base64Binary(soap, &a->cert);
	soap_serialize_string(soap, &a->userRoleId);
	soap_serialize_string(soap, &a->userGroupId);
	soap_serialize_string(soap, &a->userClassId);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__verifyInvoice(struct soap *soap, const char *tag, int id, const struct bmd230__verifyInvoice *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__verifyInvoice), type))
		return soap->error;
	if (soap_out_string(soap, "accountId", -1, &a->accountId, ""))
		return soap->error;
	if (soap_out_string(soap, "invoiceId", -1, &a->invoiceId, ""))
		return soap->error;
	if (soap_out_string(soap, "userIdentifier", -1, &a->userIdentifier, ""))
		return soap->error;
	if (soap_out_int(soap, "forceVerification", -1, &a->forceVerification, ""))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "cert", -1, &a->cert, ""))
		return soap->error;
	if (soap_out_string(soap, "userRoleId", -1, &a->userRoleId, ""))
		return soap->error;
	if (soap_out_string(soap, "userGroupId", -1, &a->userGroupId, ""))
		return soap->error;
	if (soap_out_string(soap, "userClassId", -1, &a->userClassId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__verifyInvoice * SOAP_FMAC4 soap_in_bmd230__verifyInvoice(struct soap *soap, const char *tag, struct bmd230__verifyInvoice *a, const char *type)
{
	size_t soap_flag_accountId = 1;
	size_t soap_flag_invoiceId = 1;
	size_t soap_flag_userIdentifier = 1;
	size_t soap_flag_forceVerification = 1;
	size_t soap_flag_cert = 1;
	size_t soap_flag_userRoleId = 1;
	size_t soap_flag_userGroupId = 1;
	size_t soap_flag_userClassId = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__verifyInvoice *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__verifyInvoice, sizeof(struct bmd230__verifyInvoice), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__verifyInvoice(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_accountId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "accountId", &a->accountId, "xsd:string"))
				{	soap_flag_accountId--;
					continue;
				}
			if (soap_flag_invoiceId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "invoiceId", &a->invoiceId, "xsd:string"))
				{	soap_flag_invoiceId--;
					continue;
				}
			if (soap_flag_userIdentifier && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userIdentifier", &a->userIdentifier, "xsd:string"))
				{	soap_flag_userIdentifier--;
					continue;
				}
			if (soap_flag_forceVerification && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "forceVerification", &a->forceVerification, "xsd:int"))
				{	soap_flag_forceVerification--;
					continue;
				}
			if (soap_flag_cert && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "cert", &a->cert, "xsd:base64Binary"))
				{	soap_flag_cert--;
					continue;
				}
			if (soap_flag_userRoleId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userRoleId", &a->userRoleId, "xsd:string"))
				{	soap_flag_userRoleId--;
					continue;
				}
			if (soap_flag_userGroupId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userGroupId", &a->userGroupId, "xsd:string"))
				{	soap_flag_userGroupId--;
					continue;
				}
			if (soap_flag_userClassId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userClassId", &a->userClassId, "xsd:string"))
				{	soap_flag_userClassId--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__verifyInvoice *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__verifyInvoice, 0, sizeof(struct bmd230__verifyInvoice), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_forceVerification > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__verifyInvoice(struct soap *soap, const struct bmd230__verifyInvoice *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__verifyInvoice);
	if (soap_out_bmd230__verifyInvoice(soap, tag?tag:"bmd230:verifyInvoice", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__verifyInvoice * SOAP_FMAC4 soap_get_bmd230__verifyInvoice(struct soap *soap, struct bmd230__verifyInvoice *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__verifyInvoice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__verifyInvoiceResponse(struct soap *soap, struct bmd230__verifyInvoiceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__verifyInvoiceResponse(struct soap *soap, const struct bmd230__verifyInvoiceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__verifyInvoiceResponse(struct soap *soap, const char *tag, int id, const struct bmd230__verifyInvoiceResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__verifyInvoiceResponse), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__verifyInvoiceResponse * SOAP_FMAC4 soap_in_bmd230__verifyInvoiceResponse(struct soap *soap, const char *tag, struct bmd230__verifyInvoiceResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__verifyInvoiceResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__verifyInvoiceResponse, sizeof(struct bmd230__verifyInvoiceResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__verifyInvoiceResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__verifyInvoiceResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__verifyInvoiceResponse, 0, sizeof(struct bmd230__verifyInvoiceResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__verifyInvoiceResponse(struct soap *soap, const struct bmd230__verifyInvoiceResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__verifyInvoiceResponse);
	if (soap_out_bmd230__verifyInvoiceResponse(soap, tag?tag:"bmd230:verifyInvoiceResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__verifyInvoiceResponse * SOAP_FMAC4 soap_get_bmd230__verifyInvoiceResponse(struct soap *soap, struct bmd230__verifyInvoiceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__verifyInvoiceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__getHTMLImage(struct soap *soap, struct bmd230__getHTMLImage *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->accountId);
	soap_default_string(soap, &a->invoiceId);
	soap_default_string(soap, &a->userIdentifier);
	soap_default_string(soap, &a->getReason);
	a->cert = NULL;
	soap_default_string(soap, &a->userRoleId);
	soap_default_string(soap, &a->userGroupId);
	soap_default_string(soap, &a->userClassId);
	soap_default_trans_t(soap, &a->type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__getHTMLImage(struct soap *soap, const struct bmd230__getHTMLImage *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->accountId);
	soap_serialize_string(soap, &a->invoiceId);
	soap_serialize_string(soap, &a->userIdentifier);
	soap_serialize_string(soap, &a->getReason);
	soap_serialize_PointerToxsd__base64Binary(soap, &a->cert);
	soap_serialize_string(soap, &a->userRoleId);
	soap_serialize_string(soap, &a->userGroupId);
	soap_serialize_string(soap, &a->userClassId);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__getHTMLImage(struct soap *soap, const char *tag, int id, const struct bmd230__getHTMLImage *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__getHTMLImage), type))
		return soap->error;
	if (soap_out_string(soap, "accountId", -1, &a->accountId, ""))
		return soap->error;
	if (soap_out_string(soap, "invoiceId", -1, &a->invoiceId, ""))
		return soap->error;
	if (soap_out_string(soap, "userIdentifier", -1, &a->userIdentifier, ""))
		return soap->error;
	if (soap_out_string(soap, "getReason", -1, &a->getReason, ""))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "cert", -1, &a->cert, ""))
		return soap->error;
	if (soap_out_string(soap, "userRoleId", -1, &a->userRoleId, ""))
		return soap->error;
	if (soap_out_string(soap, "userGroupId", -1, &a->userGroupId, ""))
		return soap->error;
	if (soap_out_string(soap, "userClassId", -1, &a->userClassId, ""))
		return soap->error;
	if (soap_out_trans_t(soap, "type", -1, &a->type, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__getHTMLImage * SOAP_FMAC4 soap_in_bmd230__getHTMLImage(struct soap *soap, const char *tag, struct bmd230__getHTMLImage *a, const char *type)
{
	size_t soap_flag_accountId = 1;
	size_t soap_flag_invoiceId = 1;
	size_t soap_flag_userIdentifier = 1;
	size_t soap_flag_getReason = 1;
	size_t soap_flag_cert = 1;
	size_t soap_flag_userRoleId = 1;
	size_t soap_flag_userGroupId = 1;
	size_t soap_flag_userClassId = 1;
	size_t soap_flag_type = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__getHTMLImage *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__getHTMLImage, sizeof(struct bmd230__getHTMLImage), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__getHTMLImage(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_accountId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "accountId", &a->accountId, "xsd:string"))
				{	soap_flag_accountId--;
					continue;
				}
			if (soap_flag_invoiceId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "invoiceId", &a->invoiceId, "xsd:string"))
				{	soap_flag_invoiceId--;
					continue;
				}
			if (soap_flag_userIdentifier && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userIdentifier", &a->userIdentifier, "xsd:string"))
				{	soap_flag_userIdentifier--;
					continue;
				}
			if (soap_flag_getReason && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "getReason", &a->getReason, "xsd:string"))
				{	soap_flag_getReason--;
					continue;
				}
			if (soap_flag_cert && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "cert", &a->cert, "xsd:base64Binary"))
				{	soap_flag_cert--;
					continue;
				}
			if (soap_flag_userRoleId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userRoleId", &a->userRoleId, "xsd:string"))
				{	soap_flag_userRoleId--;
					continue;
				}
			if (soap_flag_userGroupId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userGroupId", &a->userGroupId, "xsd:string"))
				{	soap_flag_userGroupId--;
					continue;
				}
			if (soap_flag_userClassId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userClassId", &a->userClassId, "xsd:string"))
				{	soap_flag_userClassId--;
					continue;
				}
			if (soap_flag_type && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_trans_t(soap, "type", &a->type, "trans-t"))
				{	soap_flag_type--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__getHTMLImage *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__getHTMLImage, 0, sizeof(struct bmd230__getHTMLImage), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_type > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__getHTMLImage(struct soap *soap, const struct bmd230__getHTMLImage *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__getHTMLImage);
	if (soap_out_bmd230__getHTMLImage(soap, tag?tag:"bmd230:getHTMLImage", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__getHTMLImage * SOAP_FMAC4 soap_get_bmd230__getHTMLImage(struct soap *soap, struct bmd230__getHTMLImage *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__getHTMLImage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__getHTMLImageResponse(struct soap *soap, struct bmd230__getHTMLImageResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->output = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__getHTMLImageResponse(struct soap *soap, const struct bmd230__getHTMLImageResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToPointerTobmd230__fileInfo(soap, &a->output);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__getHTMLImageResponse(struct soap *soap, const char *tag, int id, const struct bmd230__getHTMLImageResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__getHTMLImageResponse), type))
		return soap->error;
	if (soap_out_PointerToPointerTobmd230__fileInfo(soap, "output", -1, &a->output, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__getHTMLImageResponse * SOAP_FMAC4 soap_in_bmd230__getHTMLImageResponse(struct soap *soap, const char *tag, struct bmd230__getHTMLImageResponse *a, const char *type)
{
	size_t soap_flag_output = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__getHTMLImageResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__getHTMLImageResponse, sizeof(struct bmd230__getHTMLImageResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__getHTMLImageResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_output && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToPointerTobmd230__fileInfo(soap, "output", &a->output, "bmd230:fileInfo"))
				{	soap_flag_output--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__getHTMLImageResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__getHTMLImageResponse, 0, sizeof(struct bmd230__getHTMLImageResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__getHTMLImageResponse(struct soap *soap, const struct bmd230__getHTMLImageResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__getHTMLImageResponse);
	if (soap_out_bmd230__getHTMLImageResponse(soap, tag?tag:"bmd230:getHTMLImageResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__getHTMLImageResponse * SOAP_FMAC4 soap_get_bmd230__getHTMLImageResponse(struct soap *soap, struct bmd230__getHTMLImageResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__getHTMLImageResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__getInvoicePack(struct soap *soap, struct bmd230__getInvoicePack *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->accountId);
	soap_default_string(soap, &a->invoiceId);
	soap_default_string(soap, &a->userIdentifier);
	soap_default_string(soap, &a->getReason);
	a->cert = NULL;
	soap_default_string(soap, &a->userRoleId);
	soap_default_string(soap, &a->userGroupId);
	soap_default_string(soap, &a->userClassId);
	soap_default_trans_t(soap, &a->type);
	soap_default_string(soap, &a->parameter);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__getInvoicePack(struct soap *soap, const struct bmd230__getInvoicePack *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->accountId);
	soap_serialize_string(soap, &a->invoiceId);
	soap_serialize_string(soap, &a->userIdentifier);
	soap_serialize_string(soap, &a->getReason);
	soap_serialize_PointerToxsd__base64Binary(soap, &a->cert);
	soap_serialize_string(soap, &a->userRoleId);
	soap_serialize_string(soap, &a->userGroupId);
	soap_serialize_string(soap, &a->userClassId);
	soap_serialize_string(soap, &a->parameter);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__getInvoicePack(struct soap *soap, const char *tag, int id, const struct bmd230__getInvoicePack *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__getInvoicePack), type))
		return soap->error;
	if (soap_out_string(soap, "accountId", -1, &a->accountId, ""))
		return soap->error;
	if (soap_out_string(soap, "invoiceId", -1, &a->invoiceId, ""))
		return soap->error;
	if (soap_out_string(soap, "userIdentifier", -1, &a->userIdentifier, ""))
		return soap->error;
	if (soap_out_string(soap, "getReason", -1, &a->getReason, ""))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "cert", -1, &a->cert, ""))
		return soap->error;
	if (soap_out_string(soap, "userRoleId", -1, &a->userRoleId, ""))
		return soap->error;
	if (soap_out_string(soap, "userGroupId", -1, &a->userGroupId, ""))
		return soap->error;
	if (soap_out_string(soap, "userClassId", -1, &a->userClassId, ""))
		return soap->error;
	if (soap_out_trans_t(soap, "type", -1, &a->type, ""))
		return soap->error;
	if (soap_out_string(soap, "parameter", -1, &a->parameter, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__getInvoicePack * SOAP_FMAC4 soap_in_bmd230__getInvoicePack(struct soap *soap, const char *tag, struct bmd230__getInvoicePack *a, const char *type)
{
	size_t soap_flag_accountId = 1;
	size_t soap_flag_invoiceId = 1;
	size_t soap_flag_userIdentifier = 1;
	size_t soap_flag_getReason = 1;
	size_t soap_flag_cert = 1;
	size_t soap_flag_userRoleId = 1;
	size_t soap_flag_userGroupId = 1;
	size_t soap_flag_userClassId = 1;
	size_t soap_flag_type = 1;
	size_t soap_flag_parameter = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__getInvoicePack *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__getInvoicePack, sizeof(struct bmd230__getInvoicePack), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__getInvoicePack(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_accountId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "accountId", &a->accountId, "xsd:string"))
				{	soap_flag_accountId--;
					continue;
				}
			if (soap_flag_invoiceId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "invoiceId", &a->invoiceId, "xsd:string"))
				{	soap_flag_invoiceId--;
					continue;
				}
			if (soap_flag_userIdentifier && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userIdentifier", &a->userIdentifier, "xsd:string"))
				{	soap_flag_userIdentifier--;
					continue;
				}
			if (soap_flag_getReason && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "getReason", &a->getReason, "xsd:string"))
				{	soap_flag_getReason--;
					continue;
				}
			if (soap_flag_cert && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "cert", &a->cert, "xsd:base64Binary"))
				{	soap_flag_cert--;
					continue;
				}
			if (soap_flag_userRoleId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userRoleId", &a->userRoleId, "xsd:string"))
				{	soap_flag_userRoleId--;
					continue;
				}
			if (soap_flag_userGroupId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userGroupId", &a->userGroupId, "xsd:string"))
				{	soap_flag_userGroupId--;
					continue;
				}
			if (soap_flag_userClassId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userClassId", &a->userClassId, "xsd:string"))
				{	soap_flag_userClassId--;
					continue;
				}
			if (soap_flag_type && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_trans_t(soap, "type", &a->type, "trans-t"))
				{	soap_flag_type--;
					continue;
				}
			if (soap_flag_parameter && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "parameter", &a->parameter, "xsd:string"))
				{	soap_flag_parameter--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__getInvoicePack *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__getInvoicePack, 0, sizeof(struct bmd230__getInvoicePack), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_type > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__getInvoicePack(struct soap *soap, const struct bmd230__getInvoicePack *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__getInvoicePack);
	if (soap_out_bmd230__getInvoicePack(soap, tag?tag:"bmd230:getInvoicePack", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__getInvoicePack * SOAP_FMAC4 soap_get_bmd230__getInvoicePack(struct soap *soap, struct bmd230__getInvoicePack *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__getInvoicePack(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__getInvoicePackResponse(struct soap *soap, struct bmd230__getInvoicePackResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->output = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__getInvoicePackResponse(struct soap *soap, const struct bmd230__getInvoicePackResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToPointerTobmd230__fileInfo(soap, &a->output);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__getInvoicePackResponse(struct soap *soap, const char *tag, int id, const struct bmd230__getInvoicePackResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__getInvoicePackResponse), type))
		return soap->error;
	if (soap_out_PointerToPointerTobmd230__fileInfo(soap, "output", -1, &a->output, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__getInvoicePackResponse * SOAP_FMAC4 soap_in_bmd230__getInvoicePackResponse(struct soap *soap, const char *tag, struct bmd230__getInvoicePackResponse *a, const char *type)
{
	size_t soap_flag_output = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__getInvoicePackResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__getInvoicePackResponse, sizeof(struct bmd230__getInvoicePackResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__getInvoicePackResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_output && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToPointerTobmd230__fileInfo(soap, "output", &a->output, "bmd230:fileInfo"))
				{	soap_flag_output--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__getInvoicePackResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__getInvoicePackResponse, 0, sizeof(struct bmd230__getInvoicePackResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__getInvoicePackResponse(struct soap *soap, const struct bmd230__getInvoicePackResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__getInvoicePackResponse);
	if (soap_out_bmd230__getInvoicePackResponse(soap, tag?tag:"bmd230:getInvoicePackResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__getInvoicePackResponse * SOAP_FMAC4 soap_get_bmd230__getInvoicePackResponse(struct soap *soap, struct bmd230__getInvoicePackResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__getInvoicePackResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__SendAdviceWithParameters(struct soap *soap, struct bmd230__SendAdviceWithParameters *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cert = NULL;
	soap_default_string(soap, &a->userRoleId);
	soap_default_string(soap, &a->userGroupId);
	soap_default_string(soap, &a->userClassId);
	soap_default_string(soap, &a->bmdID);
	soap_default_string(soap, &a->accountId);
	soap_default_string(soap, &a->invoiceId);
	soap_default_string(soap, &a->userIdentifier);
	soap_default_string(soap, &a->adviceTemplateName);
	soap_default_string(soap, &a->adviceTitle);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__SendAdviceWithParameters(struct soap *soap, const struct bmd230__SendAdviceWithParameters *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__base64Binary(soap, &a->cert);
	soap_serialize_string(soap, &a->userRoleId);
	soap_serialize_string(soap, &a->userGroupId);
	soap_serialize_string(soap, &a->userClassId);
	soap_serialize_string(soap, &a->bmdID);
	soap_serialize_string(soap, &a->accountId);
	soap_serialize_string(soap, &a->invoiceId);
	soap_serialize_string(soap, &a->userIdentifier);
	soap_serialize_string(soap, &a->adviceTemplateName);
	soap_serialize_string(soap, &a->adviceTitle);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__SendAdviceWithParameters(struct soap *soap, const char *tag, int id, const struct bmd230__SendAdviceWithParameters *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__SendAdviceWithParameters), type))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "cert", -1, &a->cert, ""))
		return soap->error;
	if (soap_out_string(soap, "userRoleId", -1, &a->userRoleId, ""))
		return soap->error;
	if (soap_out_string(soap, "userGroupId", -1, &a->userGroupId, ""))
		return soap->error;
	if (soap_out_string(soap, "userClassId", -1, &a->userClassId, ""))
		return soap->error;
	if (soap_out_string(soap, "bmdID", -1, &a->bmdID, ""))
		return soap->error;
	if (soap_out_string(soap, "accountId", -1, &a->accountId, ""))
		return soap->error;
	if (soap_out_string(soap, "invoiceId", -1, &a->invoiceId, ""))
		return soap->error;
	if (soap_out_string(soap, "userIdentifier", -1, &a->userIdentifier, ""))
		return soap->error;
	if (soap_out_string(soap, "adviceTemplateName", -1, &a->adviceTemplateName, ""))
		return soap->error;
	if (soap_out_string(soap, "adviceTitle", -1, &a->adviceTitle, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__SendAdviceWithParameters * SOAP_FMAC4 soap_in_bmd230__SendAdviceWithParameters(struct soap *soap, const char *tag, struct bmd230__SendAdviceWithParameters *a, const char *type)
{
	size_t soap_flag_cert = 1;
	size_t soap_flag_userRoleId = 1;
	size_t soap_flag_userGroupId = 1;
	size_t soap_flag_userClassId = 1;
	size_t soap_flag_bmdID = 1;
	size_t soap_flag_accountId = 1;
	size_t soap_flag_invoiceId = 1;
	size_t soap_flag_userIdentifier = 1;
	size_t soap_flag_adviceTemplateName = 1;
	size_t soap_flag_adviceTitle = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__SendAdviceWithParameters *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__SendAdviceWithParameters, sizeof(struct bmd230__SendAdviceWithParameters), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__SendAdviceWithParameters(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cert && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "cert", &a->cert, "xsd:base64Binary"))
				{	soap_flag_cert--;
					continue;
				}
			if (soap_flag_userRoleId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userRoleId", &a->userRoleId, "xsd:string"))
				{	soap_flag_userRoleId--;
					continue;
				}
			if (soap_flag_userGroupId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userGroupId", &a->userGroupId, "xsd:string"))
				{	soap_flag_userGroupId--;
					continue;
				}
			if (soap_flag_userClassId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userClassId", &a->userClassId, "xsd:string"))
				{	soap_flag_userClassId--;
					continue;
				}
			if (soap_flag_bmdID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "bmdID", &a->bmdID, "xsd:string"))
				{	soap_flag_bmdID--;
					continue;
				}
			if (soap_flag_accountId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "accountId", &a->accountId, "xsd:string"))
				{	soap_flag_accountId--;
					continue;
				}
			if (soap_flag_invoiceId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "invoiceId", &a->invoiceId, "xsd:string"))
				{	soap_flag_invoiceId--;
					continue;
				}
			if (soap_flag_userIdentifier && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userIdentifier", &a->userIdentifier, "xsd:string"))
				{	soap_flag_userIdentifier--;
					continue;
				}
			if (soap_flag_adviceTemplateName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "adviceTemplateName", &a->adviceTemplateName, "xsd:string"))
				{	soap_flag_adviceTemplateName--;
					continue;
				}
			if (soap_flag_adviceTitle && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "adviceTitle", &a->adviceTitle, "xsd:string"))
				{	soap_flag_adviceTitle--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__SendAdviceWithParameters *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__SendAdviceWithParameters, 0, sizeof(struct bmd230__SendAdviceWithParameters), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__SendAdviceWithParameters(struct soap *soap, const struct bmd230__SendAdviceWithParameters *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__SendAdviceWithParameters);
	if (soap_out_bmd230__SendAdviceWithParameters(soap, tag?tag:"bmd230:SendAdviceWithParameters", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__SendAdviceWithParameters * SOAP_FMAC4 soap_get_bmd230__SendAdviceWithParameters(struct soap *soap, struct bmd230__SendAdviceWithParameters *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__SendAdviceWithParameters(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__SendAdviceWithParametersResponse(struct soap *soap, struct bmd230__SendAdviceWithParametersResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->returnCode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__SendAdviceWithParametersResponse(struct soap *soap, const struct bmd230__SendAdviceWithParametersResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->returnCode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__SendAdviceWithParametersResponse(struct soap *soap, const char *tag, int id, const struct bmd230__SendAdviceWithParametersResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__SendAdviceWithParametersResponse), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "returnCode", -1, &a->returnCode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__SendAdviceWithParametersResponse * SOAP_FMAC4 soap_in_bmd230__SendAdviceWithParametersResponse(struct soap *soap, const char *tag, struct bmd230__SendAdviceWithParametersResponse *a, const char *type)
{
	size_t soap_flag_returnCode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__SendAdviceWithParametersResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__SendAdviceWithParametersResponse, sizeof(struct bmd230__SendAdviceWithParametersResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__SendAdviceWithParametersResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_returnCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "returnCode", &a->returnCode, "xsd:int"))
				{	soap_flag_returnCode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__SendAdviceWithParametersResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__SendAdviceWithParametersResponse, 0, sizeof(struct bmd230__SendAdviceWithParametersResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__SendAdviceWithParametersResponse(struct soap *soap, const struct bmd230__SendAdviceWithParametersResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__SendAdviceWithParametersResponse);
	if (soap_out_bmd230__SendAdviceWithParametersResponse(soap, tag?tag:"bmd230:SendAdviceWithParametersResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__SendAdviceWithParametersResponse * SOAP_FMAC4 soap_get_bmd230__SendAdviceWithParametersResponse(struct soap *soap, struct bmd230__SendAdviceWithParametersResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__SendAdviceWithParametersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__SendAdvice(struct soap *soap, struct bmd230__SendAdvice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cert = NULL;
	soap_default_string(soap, &a->userRoleId);
	soap_default_string(soap, &a->userGroupId);
	soap_default_string(soap, &a->userClassId);
	soap_default_long(soap, &a->bmdID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__SendAdvice(struct soap *soap, const struct bmd230__SendAdvice *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__base64Binary(soap, &a->cert);
	soap_serialize_string(soap, &a->userRoleId);
	soap_serialize_string(soap, &a->userGroupId);
	soap_serialize_string(soap, &a->userClassId);
	soap_embedded(soap, &a->bmdID, SOAP_TYPE_long);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__SendAdvice(struct soap *soap, const char *tag, int id, const struct bmd230__SendAdvice *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__SendAdvice), type))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "cert", -1, &a->cert, ""))
		return soap->error;
	if (soap_out_string(soap, "userRoleId", -1, &a->userRoleId, ""))
		return soap->error;
	if (soap_out_string(soap, "userGroupId", -1, &a->userGroupId, ""))
		return soap->error;
	if (soap_out_string(soap, "userClassId", -1, &a->userClassId, ""))
		return soap->error;
	if (soap_out_long(soap, "bmdID", -1, &a->bmdID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__SendAdvice * SOAP_FMAC4 soap_in_bmd230__SendAdvice(struct soap *soap, const char *tag, struct bmd230__SendAdvice *a, const char *type)
{
	size_t soap_flag_cert = 1;
	size_t soap_flag_userRoleId = 1;
	size_t soap_flag_userGroupId = 1;
	size_t soap_flag_userClassId = 1;
	size_t soap_flag_bmdID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__SendAdvice *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__SendAdvice, sizeof(struct bmd230__SendAdvice), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__SendAdvice(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cert && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "cert", &a->cert, "xsd:base64Binary"))
				{	soap_flag_cert--;
					continue;
				}
			if (soap_flag_userRoleId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userRoleId", &a->userRoleId, "xsd:string"))
				{	soap_flag_userRoleId--;
					continue;
				}
			if (soap_flag_userGroupId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userGroupId", &a->userGroupId, "xsd:string"))
				{	soap_flag_userGroupId--;
					continue;
				}
			if (soap_flag_userClassId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userClassId", &a->userClassId, "xsd:string"))
				{	soap_flag_userClassId--;
					continue;
				}
			if (soap_flag_bmdID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_long(soap, "bmdID", &a->bmdID, "xsd:long"))
				{	soap_flag_bmdID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__SendAdvice *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__SendAdvice, 0, sizeof(struct bmd230__SendAdvice), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_bmdID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__SendAdvice(struct soap *soap, const struct bmd230__SendAdvice *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__SendAdvice);
	if (soap_out_bmd230__SendAdvice(soap, tag?tag:"bmd230:SendAdvice", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__SendAdvice * SOAP_FMAC4 soap_get_bmd230__SendAdvice(struct soap *soap, struct bmd230__SendAdvice *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__SendAdvice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__SendAdviceResponse(struct soap *soap, struct bmd230__SendAdviceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->returnCode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__SendAdviceResponse(struct soap *soap, const struct bmd230__SendAdviceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->returnCode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__SendAdviceResponse(struct soap *soap, const char *tag, int id, const struct bmd230__SendAdviceResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__SendAdviceResponse), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "returnCode", -1, &a->returnCode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__SendAdviceResponse * SOAP_FMAC4 soap_in_bmd230__SendAdviceResponse(struct soap *soap, const char *tag, struct bmd230__SendAdviceResponse *a, const char *type)
{
	size_t soap_flag_returnCode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__SendAdviceResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__SendAdviceResponse, sizeof(struct bmd230__SendAdviceResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__SendAdviceResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_returnCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "returnCode", &a->returnCode, "xsd:int"))
				{	soap_flag_returnCode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__SendAdviceResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__SendAdviceResponse, 0, sizeof(struct bmd230__SendAdviceResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__SendAdviceResponse(struct soap *soap, const struct bmd230__SendAdviceResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__SendAdviceResponse);
	if (soap_out_bmd230__SendAdviceResponse(soap, tag?tag:"bmd230:SendAdviceResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__SendAdviceResponse * SOAP_FMAC4 soap_get_bmd230__SendAdviceResponse(struct soap *soap, struct bmd230__SendAdviceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__SendAdviceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__verifyInvoiceWithDetailsById(struct soap *soap, struct bmd230__verifyInvoiceWithDetailsById *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cert = NULL;
	soap_default_string(soap, &a->userRoleId);
	soap_default_string(soap, &a->userGroupId);
	soap_default_string(soap, &a->userClassId);
	soap_default_long(soap, &a->id);
	soap_default_int(soap, &a->forceVerification);
	soap_default_int(soap, &a->completeVerification);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__verifyInvoiceWithDetailsById(struct soap *soap, const struct bmd230__verifyInvoiceWithDetailsById *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__base64Binary(soap, &a->cert);
	soap_serialize_string(soap, &a->userRoleId);
	soap_serialize_string(soap, &a->userGroupId);
	soap_serialize_string(soap, &a->userClassId);
	soap_embedded(soap, &a->id, SOAP_TYPE_long);
	soap_embedded(soap, &a->forceVerification, SOAP_TYPE_int);
	soap_embedded(soap, &a->completeVerification, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__verifyInvoiceWithDetailsById(struct soap *soap, const char *tag, int id, const struct bmd230__verifyInvoiceWithDetailsById *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__verifyInvoiceWithDetailsById), type))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "cert", -1, &a->cert, ""))
		return soap->error;
	if (soap_out_string(soap, "userRoleId", -1, &a->userRoleId, ""))
		return soap->error;
	if (soap_out_string(soap, "userGroupId", -1, &a->userGroupId, ""))
		return soap->error;
	if (soap_out_string(soap, "userClassId", -1, &a->userClassId, ""))
		return soap->error;
	if (soap_out_long(soap, "id", -1, &a->id, ""))
		return soap->error;
	if (soap_out_int(soap, "forceVerification", -1, &a->forceVerification, ""))
		return soap->error;
	if (soap_out_int(soap, "completeVerification", -1, &a->completeVerification, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__verifyInvoiceWithDetailsById * SOAP_FMAC4 soap_in_bmd230__verifyInvoiceWithDetailsById(struct soap *soap, const char *tag, struct bmd230__verifyInvoiceWithDetailsById *a, const char *type)
{
	size_t soap_flag_cert = 1;
	size_t soap_flag_userRoleId = 1;
	size_t soap_flag_userGroupId = 1;
	size_t soap_flag_userClassId = 1;
	size_t soap_flag_id = 1;
	size_t soap_flag_forceVerification = 1;
	size_t soap_flag_completeVerification = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__verifyInvoiceWithDetailsById *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__verifyInvoiceWithDetailsById, sizeof(struct bmd230__verifyInvoiceWithDetailsById), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__verifyInvoiceWithDetailsById(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cert && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "cert", &a->cert, "xsd:base64Binary"))
				{	soap_flag_cert--;
					continue;
				}
			if (soap_flag_userRoleId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userRoleId", &a->userRoleId, "xsd:string"))
				{	soap_flag_userRoleId--;
					continue;
				}
			if (soap_flag_userGroupId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userGroupId", &a->userGroupId, "xsd:string"))
				{	soap_flag_userGroupId--;
					continue;
				}
			if (soap_flag_userClassId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userClassId", &a->userClassId, "xsd:string"))
				{	soap_flag_userClassId--;
					continue;
				}
			if (soap_flag_id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_long(soap, "id", &a->id, "xsd:long"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_forceVerification && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "forceVerification", &a->forceVerification, "xsd:int"))
				{	soap_flag_forceVerification--;
					continue;
				}
			if (soap_flag_completeVerification && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "completeVerification", &a->completeVerification, "xsd:int"))
				{	soap_flag_completeVerification--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__verifyInvoiceWithDetailsById *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__verifyInvoiceWithDetailsById, 0, sizeof(struct bmd230__verifyInvoiceWithDetailsById), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0 || soap_flag_forceVerification > 0 || soap_flag_completeVerification > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__verifyInvoiceWithDetailsById(struct soap *soap, const struct bmd230__verifyInvoiceWithDetailsById *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__verifyInvoiceWithDetailsById);
	if (soap_out_bmd230__verifyInvoiceWithDetailsById(soap, tag?tag:"bmd230:verifyInvoiceWithDetailsById", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__verifyInvoiceWithDetailsById * SOAP_FMAC4 soap_get_bmd230__verifyInvoiceWithDetailsById(struct soap *soap, struct bmd230__verifyInvoiceWithDetailsById *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__verifyInvoiceWithDetailsById(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__verifyInvoiceWithDetailsByIdResponse(struct soap *soap, struct bmd230__verifyInvoiceWithDetailsByIdResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->output = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__verifyInvoiceWithDetailsByIdResponse(struct soap *soap, const struct bmd230__verifyInvoiceWithDetailsByIdResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToPointerTobmd230__fileInfoList(soap, &a->output);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__verifyInvoiceWithDetailsByIdResponse(struct soap *soap, const char *tag, int id, const struct bmd230__verifyInvoiceWithDetailsByIdResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__verifyInvoiceWithDetailsByIdResponse), type))
		return soap->error;
	if (soap_out_PointerToPointerTobmd230__fileInfoList(soap, "output", -1, &a->output, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__verifyInvoiceWithDetailsByIdResponse * SOAP_FMAC4 soap_in_bmd230__verifyInvoiceWithDetailsByIdResponse(struct soap *soap, const char *tag, struct bmd230__verifyInvoiceWithDetailsByIdResponse *a, const char *type)
{
	size_t soap_flag_output = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__verifyInvoiceWithDetailsByIdResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__verifyInvoiceWithDetailsByIdResponse, sizeof(struct bmd230__verifyInvoiceWithDetailsByIdResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__verifyInvoiceWithDetailsByIdResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_output && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToPointerTobmd230__fileInfoList(soap, "output", &a->output, "bmd230:fileInfoList"))
				{	soap_flag_output--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__verifyInvoiceWithDetailsByIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__verifyInvoiceWithDetailsByIdResponse, 0, sizeof(struct bmd230__verifyInvoiceWithDetailsByIdResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__verifyInvoiceWithDetailsByIdResponse(struct soap *soap, const struct bmd230__verifyInvoiceWithDetailsByIdResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__verifyInvoiceWithDetailsByIdResponse);
	if (soap_out_bmd230__verifyInvoiceWithDetailsByIdResponse(soap, tag?tag:"bmd230:verifyInvoiceWithDetailsByIdResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__verifyInvoiceWithDetailsByIdResponse * SOAP_FMAC4 soap_get_bmd230__verifyInvoiceWithDetailsByIdResponse(struct soap *soap, struct bmd230__verifyInvoiceWithDetailsByIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__verifyInvoiceWithDetailsByIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__verifyInvoiceById(struct soap *soap, struct bmd230__verifyInvoiceById *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cert = NULL;
	soap_default_string(soap, &a->userRoleId);
	soap_default_string(soap, &a->userGroupId);
	soap_default_string(soap, &a->userClassId);
	soap_default_long(soap, &a->id);
	soap_default_int(soap, &a->forceVerification);
	soap_default_int(soap, &a->completeVerification);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__verifyInvoiceById(struct soap *soap, const struct bmd230__verifyInvoiceById *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__base64Binary(soap, &a->cert);
	soap_serialize_string(soap, &a->userRoleId);
	soap_serialize_string(soap, &a->userGroupId);
	soap_serialize_string(soap, &a->userClassId);
	soap_embedded(soap, &a->id, SOAP_TYPE_long);
	soap_embedded(soap, &a->forceVerification, SOAP_TYPE_int);
	soap_embedded(soap, &a->completeVerification, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__verifyInvoiceById(struct soap *soap, const char *tag, int id, const struct bmd230__verifyInvoiceById *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__verifyInvoiceById), type))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "cert", -1, &a->cert, ""))
		return soap->error;
	if (soap_out_string(soap, "userRoleId", -1, &a->userRoleId, ""))
		return soap->error;
	if (soap_out_string(soap, "userGroupId", -1, &a->userGroupId, ""))
		return soap->error;
	if (soap_out_string(soap, "userClassId", -1, &a->userClassId, ""))
		return soap->error;
	if (soap_out_long(soap, "id", -1, &a->id, ""))
		return soap->error;
	if (soap_out_int(soap, "forceVerification", -1, &a->forceVerification, ""))
		return soap->error;
	if (soap_out_int(soap, "completeVerification", -1, &a->completeVerification, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__verifyInvoiceById * SOAP_FMAC4 soap_in_bmd230__verifyInvoiceById(struct soap *soap, const char *tag, struct bmd230__verifyInvoiceById *a, const char *type)
{
	size_t soap_flag_cert = 1;
	size_t soap_flag_userRoleId = 1;
	size_t soap_flag_userGroupId = 1;
	size_t soap_flag_userClassId = 1;
	size_t soap_flag_id = 1;
	size_t soap_flag_forceVerification = 1;
	size_t soap_flag_completeVerification = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__verifyInvoiceById *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__verifyInvoiceById, sizeof(struct bmd230__verifyInvoiceById), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__verifyInvoiceById(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cert && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "cert", &a->cert, "xsd:base64Binary"))
				{	soap_flag_cert--;
					continue;
				}
			if (soap_flag_userRoleId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userRoleId", &a->userRoleId, "xsd:string"))
				{	soap_flag_userRoleId--;
					continue;
				}
			if (soap_flag_userGroupId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userGroupId", &a->userGroupId, "xsd:string"))
				{	soap_flag_userGroupId--;
					continue;
				}
			if (soap_flag_userClassId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userClassId", &a->userClassId, "xsd:string"))
				{	soap_flag_userClassId--;
					continue;
				}
			if (soap_flag_id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_long(soap, "id", &a->id, "xsd:long"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_forceVerification && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "forceVerification", &a->forceVerification, "xsd:int"))
				{	soap_flag_forceVerification--;
					continue;
				}
			if (soap_flag_completeVerification && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "completeVerification", &a->completeVerification, "xsd:int"))
				{	soap_flag_completeVerification--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__verifyInvoiceById *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__verifyInvoiceById, 0, sizeof(struct bmd230__verifyInvoiceById), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0 || soap_flag_forceVerification > 0 || soap_flag_completeVerification > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__verifyInvoiceById(struct soap *soap, const struct bmd230__verifyInvoiceById *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__verifyInvoiceById);
	if (soap_out_bmd230__verifyInvoiceById(soap, tag?tag:"bmd230:verifyInvoiceById", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__verifyInvoiceById * SOAP_FMAC4 soap_get_bmd230__verifyInvoiceById(struct soap *soap, struct bmd230__verifyInvoiceById *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__verifyInvoiceById(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__verifyInvoiceByIdResponse(struct soap *soap, struct bmd230__verifyInvoiceByIdResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__verifyInvoiceByIdResponse(struct soap *soap, const struct bmd230__verifyInvoiceByIdResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToPointerTobmd230__stringList(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__verifyInvoiceByIdResponse(struct soap *soap, const char *tag, int id, const struct bmd230__verifyInvoiceByIdResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__verifyInvoiceByIdResponse), type))
		return soap->error;
	if (soap_out_PointerToPointerTobmd230__stringList(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__verifyInvoiceByIdResponse * SOAP_FMAC4 soap_in_bmd230__verifyInvoiceByIdResponse(struct soap *soap, const char *tag, struct bmd230__verifyInvoiceByIdResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__verifyInvoiceByIdResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__verifyInvoiceByIdResponse, sizeof(struct bmd230__verifyInvoiceByIdResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__verifyInvoiceByIdResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToPointerTobmd230__stringList(soap, "result", &a->result, "bmd230:stringList"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__verifyInvoiceByIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__verifyInvoiceByIdResponse, 0, sizeof(struct bmd230__verifyInvoiceByIdResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__verifyInvoiceByIdResponse(struct soap *soap, const struct bmd230__verifyInvoiceByIdResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__verifyInvoiceByIdResponse);
	if (soap_out_bmd230__verifyInvoiceByIdResponse(soap, tag?tag:"bmd230:verifyInvoiceByIdResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__verifyInvoiceByIdResponse * SOAP_FMAC4 soap_get_bmd230__verifyInvoiceByIdResponse(struct soap *soap, struct bmd230__verifyInvoiceByIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__verifyInvoiceByIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__getHTMLImageById(struct soap *soap, struct bmd230__getHTMLImageById *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cert = NULL;
	soap_default_string(soap, &a->userRoleId);
	soap_default_string(soap, &a->userGroupId);
	soap_default_string(soap, &a->userClassId);
	soap_default_long(soap, &a->id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__getHTMLImageById(struct soap *soap, const struct bmd230__getHTMLImageById *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__base64Binary(soap, &a->cert);
	soap_serialize_string(soap, &a->userRoleId);
	soap_serialize_string(soap, &a->userGroupId);
	soap_serialize_string(soap, &a->userClassId);
	soap_embedded(soap, &a->id, SOAP_TYPE_long);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__getHTMLImageById(struct soap *soap, const char *tag, int id, const struct bmd230__getHTMLImageById *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__getHTMLImageById), type))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "cert", -1, &a->cert, ""))
		return soap->error;
	if (soap_out_string(soap, "userRoleId", -1, &a->userRoleId, ""))
		return soap->error;
	if (soap_out_string(soap, "userGroupId", -1, &a->userGroupId, ""))
		return soap->error;
	if (soap_out_string(soap, "userClassId", -1, &a->userClassId, ""))
		return soap->error;
	if (soap_out_long(soap, "id", -1, &a->id, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__getHTMLImageById * SOAP_FMAC4 soap_in_bmd230__getHTMLImageById(struct soap *soap, const char *tag, struct bmd230__getHTMLImageById *a, const char *type)
{
	size_t soap_flag_cert = 1;
	size_t soap_flag_userRoleId = 1;
	size_t soap_flag_userGroupId = 1;
	size_t soap_flag_userClassId = 1;
	size_t soap_flag_id = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__getHTMLImageById *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__getHTMLImageById, sizeof(struct bmd230__getHTMLImageById), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__getHTMLImageById(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cert && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "cert", &a->cert, "xsd:base64Binary"))
				{	soap_flag_cert--;
					continue;
				}
			if (soap_flag_userRoleId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userRoleId", &a->userRoleId, "xsd:string"))
				{	soap_flag_userRoleId--;
					continue;
				}
			if (soap_flag_userGroupId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userGroupId", &a->userGroupId, "xsd:string"))
				{	soap_flag_userGroupId--;
					continue;
				}
			if (soap_flag_userClassId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userClassId", &a->userClassId, "xsd:string"))
				{	soap_flag_userClassId--;
					continue;
				}
			if (soap_flag_id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_long(soap, "id", &a->id, "xsd:long"))
				{	soap_flag_id--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__getHTMLImageById *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__getHTMLImageById, 0, sizeof(struct bmd230__getHTMLImageById), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__getHTMLImageById(struct soap *soap, const struct bmd230__getHTMLImageById *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__getHTMLImageById);
	if (soap_out_bmd230__getHTMLImageById(soap, tag?tag:"bmd230:getHTMLImageById", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__getHTMLImageById * SOAP_FMAC4 soap_get_bmd230__getHTMLImageById(struct soap *soap, struct bmd230__getHTMLImageById *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__getHTMLImageById(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__getHTMLImageByIdResponse(struct soap *soap, struct bmd230__getHTMLImageByIdResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->output = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__getHTMLImageByIdResponse(struct soap *soap, const struct bmd230__getHTMLImageByIdResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToPointerTobmd230__fileInfo(soap, &a->output);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__getHTMLImageByIdResponse(struct soap *soap, const char *tag, int id, const struct bmd230__getHTMLImageByIdResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__getHTMLImageByIdResponse), type))
		return soap->error;
	if (soap_out_PointerToPointerTobmd230__fileInfo(soap, "output", -1, &a->output, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__getHTMLImageByIdResponse * SOAP_FMAC4 soap_in_bmd230__getHTMLImageByIdResponse(struct soap *soap, const char *tag, struct bmd230__getHTMLImageByIdResponse *a, const char *type)
{
	size_t soap_flag_output = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__getHTMLImageByIdResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__getHTMLImageByIdResponse, sizeof(struct bmd230__getHTMLImageByIdResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__getHTMLImageByIdResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_output && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToPointerTobmd230__fileInfo(soap, "output", &a->output, "bmd230:fileInfo"))
				{	soap_flag_output--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__getHTMLImageByIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__getHTMLImageByIdResponse, 0, sizeof(struct bmd230__getHTMLImageByIdResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__getHTMLImageByIdResponse(struct soap *soap, const struct bmd230__getHTMLImageByIdResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__getHTMLImageByIdResponse);
	if (soap_out_bmd230__getHTMLImageByIdResponse(soap, tag?tag:"bmd230:getHTMLImageByIdResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__getHTMLImageByIdResponse * SOAP_FMAC4 soap_get_bmd230__getHTMLImageByIdResponse(struct soap *soap, struct bmd230__getHTMLImageByIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__getHTMLImageByIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__getInvoicePackById(struct soap *soap, struct bmd230__getInvoicePackById *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cert = NULL;
	soap_default_string(soap, &a->userRoleId);
	soap_default_string(soap, &a->userGroupId);
	soap_default_string(soap, &a->userClassId);
	soap_default_long(soap, &a->id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__getInvoicePackById(struct soap *soap, const struct bmd230__getInvoicePackById *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__base64Binary(soap, &a->cert);
	soap_serialize_string(soap, &a->userRoleId);
	soap_serialize_string(soap, &a->userGroupId);
	soap_serialize_string(soap, &a->userClassId);
	soap_embedded(soap, &a->id, SOAP_TYPE_long);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__getInvoicePackById(struct soap *soap, const char *tag, int id, const struct bmd230__getInvoicePackById *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__getInvoicePackById), type))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "cert", -1, &a->cert, ""))
		return soap->error;
	if (soap_out_string(soap, "userRoleId", -1, &a->userRoleId, ""))
		return soap->error;
	if (soap_out_string(soap, "userGroupId", -1, &a->userGroupId, ""))
		return soap->error;
	if (soap_out_string(soap, "userClassId", -1, &a->userClassId, ""))
		return soap->error;
	if (soap_out_long(soap, "id", -1, &a->id, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__getInvoicePackById * SOAP_FMAC4 soap_in_bmd230__getInvoicePackById(struct soap *soap, const char *tag, struct bmd230__getInvoicePackById *a, const char *type)
{
	size_t soap_flag_cert = 1;
	size_t soap_flag_userRoleId = 1;
	size_t soap_flag_userGroupId = 1;
	size_t soap_flag_userClassId = 1;
	size_t soap_flag_id = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__getInvoicePackById *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__getInvoicePackById, sizeof(struct bmd230__getInvoicePackById), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__getInvoicePackById(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cert && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "cert", &a->cert, "xsd:base64Binary"))
				{	soap_flag_cert--;
					continue;
				}
			if (soap_flag_userRoleId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userRoleId", &a->userRoleId, "xsd:string"))
				{	soap_flag_userRoleId--;
					continue;
				}
			if (soap_flag_userGroupId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userGroupId", &a->userGroupId, "xsd:string"))
				{	soap_flag_userGroupId--;
					continue;
				}
			if (soap_flag_userClassId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userClassId", &a->userClassId, "xsd:string"))
				{	soap_flag_userClassId--;
					continue;
				}
			if (soap_flag_id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_long(soap, "id", &a->id, "xsd:long"))
				{	soap_flag_id--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__getInvoicePackById *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__getInvoicePackById, 0, sizeof(struct bmd230__getInvoicePackById), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__getInvoicePackById(struct soap *soap, const struct bmd230__getInvoicePackById *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__getInvoicePackById);
	if (soap_out_bmd230__getInvoicePackById(soap, tag?tag:"bmd230:getInvoicePackById", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__getInvoicePackById * SOAP_FMAC4 soap_get_bmd230__getInvoicePackById(struct soap *soap, struct bmd230__getInvoicePackById *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__getInvoicePackById(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__getInvoicePackByIdResponse(struct soap *soap, struct bmd230__getInvoicePackByIdResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->output = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__getInvoicePackByIdResponse(struct soap *soap, const struct bmd230__getInvoicePackByIdResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToPointerTobmd230__fileInfo(soap, &a->output);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__getInvoicePackByIdResponse(struct soap *soap, const char *tag, int id, const struct bmd230__getInvoicePackByIdResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__getInvoicePackByIdResponse), type))
		return soap->error;
	if (soap_out_PointerToPointerTobmd230__fileInfo(soap, "output", -1, &a->output, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__getInvoicePackByIdResponse * SOAP_FMAC4 soap_in_bmd230__getInvoicePackByIdResponse(struct soap *soap, const char *tag, struct bmd230__getInvoicePackByIdResponse *a, const char *type)
{
	size_t soap_flag_output = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__getInvoicePackByIdResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__getInvoicePackByIdResponse, sizeof(struct bmd230__getInvoicePackByIdResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__getInvoicePackByIdResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_output && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToPointerTobmd230__fileInfo(soap, "output", &a->output, "bmd230:fileInfo"))
				{	soap_flag_output--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__getInvoicePackByIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__getInvoicePackByIdResponse, 0, sizeof(struct bmd230__getInvoicePackByIdResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__getInvoicePackByIdResponse(struct soap *soap, const struct bmd230__getInvoicePackByIdResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__getInvoicePackByIdResponse);
	if (soap_out_bmd230__getInvoicePackByIdResponse(soap, tag?tag:"bmd230:getInvoicePackByIdResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__getInvoicePackByIdResponse * SOAP_FMAC4 soap_get_bmd230__getInvoicePackByIdResponse(struct soap *soap, struct bmd230__getInvoicePackByIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__getInvoicePackByIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdGetActionsHistoryById(struct soap *soap, struct bmd230__bmdGetActionsHistoryById *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cert = NULL;
	soap_default_string(soap, &a->userRoleId);
	soap_default_string(soap, &a->userGroupId);
	soap_default_string(soap, &a->userClassId);
	soap_default_string(soap, &a->id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdGetActionsHistoryById(struct soap *soap, const struct bmd230__bmdGetActionsHistoryById *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__base64Binary(soap, &a->cert);
	soap_serialize_string(soap, &a->userRoleId);
	soap_serialize_string(soap, &a->userGroupId);
	soap_serialize_string(soap, &a->userClassId);
	soap_serialize_string(soap, &a->id);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdGetActionsHistoryById(struct soap *soap, const char *tag, int id, const struct bmd230__bmdGetActionsHistoryById *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdGetActionsHistoryById), type))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "cert", -1, &a->cert, ""))
		return soap->error;
	if (soap_out_string(soap, "userRoleId", -1, &a->userRoleId, ""))
		return soap->error;
	if (soap_out_string(soap, "userGroupId", -1, &a->userGroupId, ""))
		return soap->error;
	if (soap_out_string(soap, "userClassId", -1, &a->userClassId, ""))
		return soap->error;
	if (soap_out_string(soap, "id", -1, &a->id, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdGetActionsHistoryById * SOAP_FMAC4 soap_in_bmd230__bmdGetActionsHistoryById(struct soap *soap, const char *tag, struct bmd230__bmdGetActionsHistoryById *a, const char *type)
{
	size_t soap_flag_cert = 1;
	size_t soap_flag_userRoleId = 1;
	size_t soap_flag_userGroupId = 1;
	size_t soap_flag_userClassId = 1;
	size_t soap_flag_id = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdGetActionsHistoryById *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdGetActionsHistoryById, sizeof(struct bmd230__bmdGetActionsHistoryById), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdGetActionsHistoryById(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cert && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "cert", &a->cert, "xsd:base64Binary"))
				{	soap_flag_cert--;
					continue;
				}
			if (soap_flag_userRoleId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userRoleId", &a->userRoleId, "xsd:string"))
				{	soap_flag_userRoleId--;
					continue;
				}
			if (soap_flag_userGroupId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userGroupId", &a->userGroupId, "xsd:string"))
				{	soap_flag_userGroupId--;
					continue;
				}
			if (soap_flag_userClassId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userClassId", &a->userClassId, "xsd:string"))
				{	soap_flag_userClassId--;
					continue;
				}
			if (soap_flag_id && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "id", &a->id, "xsd:string"))
				{	soap_flag_id--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdGetActionsHistoryById *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdGetActionsHistoryById, 0, sizeof(struct bmd230__bmdGetActionsHistoryById), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdGetActionsHistoryById(struct soap *soap, const struct bmd230__bmdGetActionsHistoryById *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdGetActionsHistoryById);
	if (soap_out_bmd230__bmdGetActionsHistoryById(soap, tag?tag:"bmd230:bmdGetActionsHistoryById", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdGetActionsHistoryById * SOAP_FMAC4 soap_get_bmd230__bmdGetActionsHistoryById(struct soap *soap, struct bmd230__bmdGetActionsHistoryById *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdGetActionsHistoryById(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdGetActionsHistoryByIdResponse(struct soap *soap, struct bmd230__bmdGetActionsHistoryByIdResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->output = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdGetActionsHistoryByIdResponse(struct soap *soap, const struct bmd230__bmdGetActionsHistoryByIdResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToPointerTobmd230__ActionsHistoryList(soap, &a->output);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdGetActionsHistoryByIdResponse(struct soap *soap, const char *tag, int id, const struct bmd230__bmdGetActionsHistoryByIdResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdGetActionsHistoryByIdResponse), type))
		return soap->error;
	if (soap_out_PointerToPointerTobmd230__ActionsHistoryList(soap, "output", -1, &a->output, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdGetActionsHistoryByIdResponse * SOAP_FMAC4 soap_in_bmd230__bmdGetActionsHistoryByIdResponse(struct soap *soap, const char *tag, struct bmd230__bmdGetActionsHistoryByIdResponse *a, const char *type)
{
	size_t soap_flag_output = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdGetActionsHistoryByIdResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdGetActionsHistoryByIdResponse, sizeof(struct bmd230__bmdGetActionsHistoryByIdResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdGetActionsHistoryByIdResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_output && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToPointerTobmd230__ActionsHistoryList(soap, "output", &a->output, "bmd230:ActionsHistoryList"))
				{	soap_flag_output--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdGetActionsHistoryByIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdGetActionsHistoryByIdResponse, 0, sizeof(struct bmd230__bmdGetActionsHistoryByIdResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdGetActionsHistoryByIdResponse(struct soap *soap, const struct bmd230__bmdGetActionsHistoryByIdResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdGetActionsHistoryByIdResponse);
	if (soap_out_bmd230__bmdGetActionsHistoryByIdResponse(soap, tag?tag:"bmd230:bmdGetActionsHistoryByIdResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdGetActionsHistoryByIdResponse * SOAP_FMAC4 soap_get_bmd230__bmdGetActionsHistoryByIdResponse(struct soap *soap, struct bmd230__bmdGetActionsHistoryByIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdGetActionsHistoryByIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdGetVersionsHistory(struct soap *soap, struct bmd230__bmdGetVersionsHistory *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cert = NULL;
	soap_default_string(soap, &a->userRoleId);
	soap_default_string(soap, &a->userGroupId);
	soap_default_string(soap, &a->userClassId);
	a->fileIds = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdGetVersionsHistory(struct soap *soap, const struct bmd230__bmdGetVersionsHistory *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__base64Binary(soap, &a->cert);
	soap_serialize_string(soap, &a->userRoleId);
	soap_serialize_string(soap, &a->userGroupId);
	soap_serialize_string(soap, &a->userClassId);
	soap_serialize_PointerTobmd230__LongNumbersList(soap, &a->fileIds);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdGetVersionsHistory(struct soap *soap, const char *tag, int id, const struct bmd230__bmdGetVersionsHistory *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdGetVersionsHistory), type))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "cert", -1, &a->cert, ""))
		return soap->error;
	if (soap_out_string(soap, "userRoleId", -1, &a->userRoleId, ""))
		return soap->error;
	if (soap_out_string(soap, "userGroupId", -1, &a->userGroupId, ""))
		return soap->error;
	if (soap_out_string(soap, "userClassId", -1, &a->userClassId, ""))
		return soap->error;
	if (soap_out_PointerTobmd230__LongNumbersList(soap, "fileIds", -1, &a->fileIds, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdGetVersionsHistory * SOAP_FMAC4 soap_in_bmd230__bmdGetVersionsHistory(struct soap *soap, const char *tag, struct bmd230__bmdGetVersionsHistory *a, const char *type)
{
	size_t soap_flag_cert = 1;
	size_t soap_flag_userRoleId = 1;
	size_t soap_flag_userGroupId = 1;
	size_t soap_flag_userClassId = 1;
	size_t soap_flag_fileIds = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdGetVersionsHistory *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdGetVersionsHistory, sizeof(struct bmd230__bmdGetVersionsHistory), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdGetVersionsHistory(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cert && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "cert", &a->cert, "xsd:base64Binary"))
				{	soap_flag_cert--;
					continue;
				}
			if (soap_flag_userRoleId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userRoleId", &a->userRoleId, "xsd:string"))
				{	soap_flag_userRoleId--;
					continue;
				}
			if (soap_flag_userGroupId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userGroupId", &a->userGroupId, "xsd:string"))
				{	soap_flag_userGroupId--;
					continue;
				}
			if (soap_flag_userClassId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userClassId", &a->userClassId, "xsd:string"))
				{	soap_flag_userClassId--;
					continue;
				}
			if (soap_flag_fileIds && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobmd230__LongNumbersList(soap, "fileIds", &a->fileIds, "bmd230:LongNumbersList"))
				{	soap_flag_fileIds--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdGetVersionsHistory *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdGetVersionsHistory, 0, sizeof(struct bmd230__bmdGetVersionsHistory), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdGetVersionsHistory(struct soap *soap, const struct bmd230__bmdGetVersionsHistory *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdGetVersionsHistory);
	if (soap_out_bmd230__bmdGetVersionsHistory(soap, tag?tag:"bmd230:bmdGetVersionsHistory", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdGetVersionsHistory * SOAP_FMAC4 soap_get_bmd230__bmdGetVersionsHistory(struct soap *soap, struct bmd230__bmdGetVersionsHistory *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdGetVersionsHistory(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdGetVersionsHistoryResponse(struct soap *soap, struct bmd230__bmdGetVersionsHistoryResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdGetVersionsHistoryResponse(struct soap *soap, const struct bmd230__bmdGetVersionsHistoryResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToPointerTobmd230__GetVersionsHistoryResultList(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdGetVersionsHistoryResponse(struct soap *soap, const char *tag, int id, const struct bmd230__bmdGetVersionsHistoryResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdGetVersionsHistoryResponse), type))
		return soap->error;
	if (soap_out_PointerToPointerTobmd230__GetVersionsHistoryResultList(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdGetVersionsHistoryResponse * SOAP_FMAC4 soap_in_bmd230__bmdGetVersionsHistoryResponse(struct soap *soap, const char *tag, struct bmd230__bmdGetVersionsHistoryResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdGetVersionsHistoryResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdGetVersionsHistoryResponse, sizeof(struct bmd230__bmdGetVersionsHistoryResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdGetVersionsHistoryResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToPointerTobmd230__GetVersionsHistoryResultList(soap, "result", &a->result, "bmd230:GetVersionsHistoryResultList"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdGetVersionsHistoryResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdGetVersionsHistoryResponse, 0, sizeof(struct bmd230__bmdGetVersionsHistoryResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdGetVersionsHistoryResponse(struct soap *soap, const struct bmd230__bmdGetVersionsHistoryResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdGetVersionsHistoryResponse);
	if (soap_out_bmd230__bmdGetVersionsHistoryResponse(soap, tag?tag:"bmd230:bmdGetVersionsHistoryResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdGetVersionsHistoryResponse * SOAP_FMAC4 soap_get_bmd230__bmdGetVersionsHistoryResponse(struct soap *soap, struct bmd230__bmdGetVersionsHistoryResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdGetVersionsHistoryResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdGetAccessObjects(struct soap *soap, struct bmd230__bmdGetAccessObjects *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cert = NULL;
	soap_default_string(soap, &a->userRoleId);
	soap_default_string(soap, &a->userGroupId);
	soap_default_string(soap, &a->userClassId);
	soap_default_long(soap, &a->bmdId);
	soap_default_visibilityType_t(soap, &a->visible);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdGetAccessObjects(struct soap *soap, const struct bmd230__bmdGetAccessObjects *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__base64Binary(soap, &a->cert);
	soap_serialize_string(soap, &a->userRoleId);
	soap_serialize_string(soap, &a->userGroupId);
	soap_serialize_string(soap, &a->userClassId);
	soap_embedded(soap, &a->bmdId, SOAP_TYPE_long);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdGetAccessObjects(struct soap *soap, const char *tag, int id, const struct bmd230__bmdGetAccessObjects *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdGetAccessObjects), type))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "cert", -1, &a->cert, ""))
		return soap->error;
	if (soap_out_string(soap, "userRoleId", -1, &a->userRoleId, ""))
		return soap->error;
	if (soap_out_string(soap, "userGroupId", -1, &a->userGroupId, ""))
		return soap->error;
	if (soap_out_string(soap, "userClassId", -1, &a->userClassId, ""))
		return soap->error;
	if (soap_out_long(soap, "bmdId", -1, &a->bmdId, ""))
		return soap->error;
	if (soap_out_visibilityType_t(soap, "visible", -1, &a->visible, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdGetAccessObjects * SOAP_FMAC4 soap_in_bmd230__bmdGetAccessObjects(struct soap *soap, const char *tag, struct bmd230__bmdGetAccessObjects *a, const char *type)
{
	size_t soap_flag_cert = 1;
	size_t soap_flag_userRoleId = 1;
	size_t soap_flag_userGroupId = 1;
	size_t soap_flag_userClassId = 1;
	size_t soap_flag_bmdId = 1;
	size_t soap_flag_visible = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdGetAccessObjects *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdGetAccessObjects, sizeof(struct bmd230__bmdGetAccessObjects), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdGetAccessObjects(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cert && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "cert", &a->cert, "xsd:base64Binary"))
				{	soap_flag_cert--;
					continue;
				}
			if (soap_flag_userRoleId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userRoleId", &a->userRoleId, "xsd:string"))
				{	soap_flag_userRoleId--;
					continue;
				}
			if (soap_flag_userGroupId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userGroupId", &a->userGroupId, "xsd:string"))
				{	soap_flag_userGroupId--;
					continue;
				}
			if (soap_flag_userClassId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userClassId", &a->userClassId, "xsd:string"))
				{	soap_flag_userClassId--;
					continue;
				}
			if (soap_flag_bmdId && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_long(soap, "bmdId", &a->bmdId, "xsd:long"))
				{	soap_flag_bmdId--;
					continue;
				}
			if (soap_flag_visible && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_visibilityType_t(soap, "visible", &a->visible, "visibilityType-t"))
				{	soap_flag_visible--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdGetAccessObjects *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdGetAccessObjects, 0, sizeof(struct bmd230__bmdGetAccessObjects), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_bmdId > 0 || soap_flag_visible > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdGetAccessObjects(struct soap *soap, const struct bmd230__bmdGetAccessObjects *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdGetAccessObjects);
	if (soap_out_bmd230__bmdGetAccessObjects(soap, tag?tag:"bmd230:bmdGetAccessObjects", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdGetAccessObjects * SOAP_FMAC4 soap_get_bmd230__bmdGetAccessObjects(struct soap *soap, struct bmd230__bmdGetAccessObjects *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdGetAccessObjects(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdGetAccessObjectsResponse(struct soap *soap, struct bmd230__bmdGetAccessObjectsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->accessObjects = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdGetAccessObjectsResponse(struct soap *soap, const struct bmd230__bmdGetAccessObjectsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToPointerTobmd230__accessObjectList(soap, &a->accessObjects);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdGetAccessObjectsResponse(struct soap *soap, const char *tag, int id, const struct bmd230__bmdGetAccessObjectsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdGetAccessObjectsResponse), type))
		return soap->error;
	if (soap_out_PointerToPointerTobmd230__accessObjectList(soap, "accessObjects", -1, &a->accessObjects, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdGetAccessObjectsResponse * SOAP_FMAC4 soap_in_bmd230__bmdGetAccessObjectsResponse(struct soap *soap, const char *tag, struct bmd230__bmdGetAccessObjectsResponse *a, const char *type)
{
	size_t soap_flag_accessObjects = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdGetAccessObjectsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdGetAccessObjectsResponse, sizeof(struct bmd230__bmdGetAccessObjectsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdGetAccessObjectsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_accessObjects && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToPointerTobmd230__accessObjectList(soap, "accessObjects", &a->accessObjects, "bmd230:accessObjectList"))
				{	soap_flag_accessObjects--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdGetAccessObjectsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdGetAccessObjectsResponse, 0, sizeof(struct bmd230__bmdGetAccessObjectsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdGetAccessObjectsResponse(struct soap *soap, const struct bmd230__bmdGetAccessObjectsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdGetAccessObjectsResponse);
	if (soap_out_bmd230__bmdGetAccessObjectsResponse(soap, tag?tag:"bmd230:bmdGetAccessObjectsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdGetAccessObjectsResponse * SOAP_FMAC4 soap_get_bmd230__bmdGetAccessObjectsResponse(struct soap *soap, struct bmd230__bmdGetAccessObjectsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdGetAccessObjectsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdGetArchPack(struct soap *soap, struct bmd230__bmdGetArchPack *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cert = NULL;
	soap_default_string(soap, &a->userRoleId);
	soap_default_string(soap, &a->userGroupId);
	soap_default_string(soap, &a->userClassId);
	soap_default_long(soap, &a->id);
	soap_default_trans_t(soap, &a->type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdGetArchPack(struct soap *soap, const struct bmd230__bmdGetArchPack *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__base64Binary(soap, &a->cert);
	soap_serialize_string(soap, &a->userRoleId);
	soap_serialize_string(soap, &a->userGroupId);
	soap_serialize_string(soap, &a->userClassId);
	soap_embedded(soap, &a->id, SOAP_TYPE_long);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdGetArchPack(struct soap *soap, const char *tag, int id, const struct bmd230__bmdGetArchPack *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdGetArchPack), type))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "cert", -1, &a->cert, ""))
		return soap->error;
	if (soap_out_string(soap, "userRoleId", -1, &a->userRoleId, ""))
		return soap->error;
	if (soap_out_string(soap, "userGroupId", -1, &a->userGroupId, ""))
		return soap->error;
	if (soap_out_string(soap, "userClassId", -1, &a->userClassId, ""))
		return soap->error;
	if (soap_out_long(soap, "id", -1, &a->id, ""))
		return soap->error;
	if (soap_out_trans_t(soap, "type", -1, &a->type, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdGetArchPack * SOAP_FMAC4 soap_in_bmd230__bmdGetArchPack(struct soap *soap, const char *tag, struct bmd230__bmdGetArchPack *a, const char *type)
{
	size_t soap_flag_cert = 1;
	size_t soap_flag_userRoleId = 1;
	size_t soap_flag_userGroupId = 1;
	size_t soap_flag_userClassId = 1;
	size_t soap_flag_id = 1;
	size_t soap_flag_type = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdGetArchPack *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdGetArchPack, sizeof(struct bmd230__bmdGetArchPack), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdGetArchPack(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cert && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "cert", &a->cert, "xsd:base64Binary"))
				{	soap_flag_cert--;
					continue;
				}
			if (soap_flag_userRoleId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userRoleId", &a->userRoleId, "xsd:string"))
				{	soap_flag_userRoleId--;
					continue;
				}
			if (soap_flag_userGroupId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userGroupId", &a->userGroupId, "xsd:string"))
				{	soap_flag_userGroupId--;
					continue;
				}
			if (soap_flag_userClassId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userClassId", &a->userClassId, "xsd:string"))
				{	soap_flag_userClassId--;
					continue;
				}
			if (soap_flag_id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_long(soap, "id", &a->id, "xsd:long"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_type && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_trans_t(soap, "type", &a->type, "trans-t"))
				{	soap_flag_type--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdGetArchPack *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdGetArchPack, 0, sizeof(struct bmd230__bmdGetArchPack), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0 || soap_flag_type > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdGetArchPack(struct soap *soap, const struct bmd230__bmdGetArchPack *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdGetArchPack);
	if (soap_out_bmd230__bmdGetArchPack(soap, tag?tag:"bmd230:bmdGetArchPack", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdGetArchPack * SOAP_FMAC4 soap_get_bmd230__bmdGetArchPack(struct soap *soap, struct bmd230__bmdGetArchPack *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdGetArchPack(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdGetArchPackResponse(struct soap *soap, struct bmd230__bmdGetArchPackResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->output = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdGetArchPackResponse(struct soap *soap, const struct bmd230__bmdGetArchPackResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToPointerTobmd230__fileInfo(soap, &a->output);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdGetArchPackResponse(struct soap *soap, const char *tag, int id, const struct bmd230__bmdGetArchPackResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdGetArchPackResponse), type))
		return soap->error;
	if (soap_out_PointerToPointerTobmd230__fileInfo(soap, "output", -1, &a->output, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdGetArchPackResponse * SOAP_FMAC4 soap_in_bmd230__bmdGetArchPackResponse(struct soap *soap, const char *tag, struct bmd230__bmdGetArchPackResponse *a, const char *type)
{
	size_t soap_flag_output = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdGetArchPackResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdGetArchPackResponse, sizeof(struct bmd230__bmdGetArchPackResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdGetArchPackResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_output && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToPointerTobmd230__fileInfo(soap, "output", &a->output, "bmd230:fileInfo"))
				{	soap_flag_output--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdGetArchPackResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdGetArchPackResponse, 0, sizeof(struct bmd230__bmdGetArchPackResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdGetArchPackResponse(struct soap *soap, const struct bmd230__bmdGetArchPackResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdGetArchPackResponse);
	if (soap_out_bmd230__bmdGetArchPackResponse(soap, tag?tag:"bmd230:bmdGetArchPackResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdGetArchPackResponse * SOAP_FMAC4 soap_get_bmd230__bmdGetArchPackResponse(struct soap *soap, struct bmd230__bmdGetArchPackResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdGetArchPackResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdGetTimeStamp(struct soap *soap, struct bmd230__bmdGetTimeStamp *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->input = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdGetTimeStamp(struct soap *soap, const struct bmd230__bmdGetTimeStamp *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTobmd230__fileInfo(soap, &a->input);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdGetTimeStamp(struct soap *soap, const char *tag, int id, const struct bmd230__bmdGetTimeStamp *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdGetTimeStamp), type))
		return soap->error;
	if (soap_out_PointerTobmd230__fileInfo(soap, "input", -1, &a->input, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdGetTimeStamp * SOAP_FMAC4 soap_in_bmd230__bmdGetTimeStamp(struct soap *soap, const char *tag, struct bmd230__bmdGetTimeStamp *a, const char *type)
{
	size_t soap_flag_input = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdGetTimeStamp *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdGetTimeStamp, sizeof(struct bmd230__bmdGetTimeStamp), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdGetTimeStamp(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_input && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobmd230__fileInfo(soap, "input", &a->input, "bmd230:fileInfo"))
				{	soap_flag_input--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdGetTimeStamp *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdGetTimeStamp, 0, sizeof(struct bmd230__bmdGetTimeStamp), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdGetTimeStamp(struct soap *soap, const struct bmd230__bmdGetTimeStamp *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdGetTimeStamp);
	if (soap_out_bmd230__bmdGetTimeStamp(soap, tag?tag:"bmd230:bmdGetTimeStamp", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdGetTimeStamp * SOAP_FMAC4 soap_get_bmd230__bmdGetTimeStamp(struct soap *soap, struct bmd230__bmdGetTimeStamp *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdGetTimeStamp(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdGetTimeStampResponse(struct soap *soap, struct bmd230__bmdGetTimeStampResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->output = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdGetTimeStampResponse(struct soap *soap, const struct bmd230__bmdGetTimeStampResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToPointerTobmd230__bmdTimestamp(soap, &a->output);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdGetTimeStampResponse(struct soap *soap, const char *tag, int id, const struct bmd230__bmdGetTimeStampResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdGetTimeStampResponse), type))
		return soap->error;
	if (soap_out_PointerToPointerTobmd230__bmdTimestamp(soap, "output", -1, &a->output, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdGetTimeStampResponse * SOAP_FMAC4 soap_in_bmd230__bmdGetTimeStampResponse(struct soap *soap, const char *tag, struct bmd230__bmdGetTimeStampResponse *a, const char *type)
{
	size_t soap_flag_output = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdGetTimeStampResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdGetTimeStampResponse, sizeof(struct bmd230__bmdGetTimeStampResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdGetTimeStampResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_output && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToPointerTobmd230__bmdTimestamp(soap, "output", &a->output, "bmd230:bmdTimestamp"))
				{	soap_flag_output--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdGetTimeStampResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdGetTimeStampResponse, 0, sizeof(struct bmd230__bmdGetTimeStampResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdGetTimeStampResponse(struct soap *soap, const struct bmd230__bmdGetTimeStampResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdGetTimeStampResponse);
	if (soap_out_bmd230__bmdGetTimeStampResponse(soap, tag?tag:"bmd230:bmdGetTimeStampResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdGetTimeStampResponse * SOAP_FMAC4 soap_get_bmd230__bmdGetTimeStampResponse(struct soap *soap, struct bmd230__bmdGetTimeStampResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdGetTimeStampResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdGetFilePKIById(struct soap *soap, struct bmd230__bmdGetFilePKIById *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cert = NULL;
	soap_default_string(soap, &a->userRoleId);
	soap_default_string(soap, &a->userGroupId);
	soap_default_string(soap, &a->userClassId);
	soap_default_long(soap, &a->id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdGetFilePKIById(struct soap *soap, const struct bmd230__bmdGetFilePKIById *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__base64Binary(soap, &a->cert);
	soap_serialize_string(soap, &a->userRoleId);
	soap_serialize_string(soap, &a->userGroupId);
	soap_serialize_string(soap, &a->userClassId);
	soap_embedded(soap, &a->id, SOAP_TYPE_long);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdGetFilePKIById(struct soap *soap, const char *tag, int id, const struct bmd230__bmdGetFilePKIById *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdGetFilePKIById), type))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "cert", -1, &a->cert, ""))
		return soap->error;
	if (soap_out_string(soap, "userRoleId", -1, &a->userRoleId, ""))
		return soap->error;
	if (soap_out_string(soap, "userGroupId", -1, &a->userGroupId, ""))
		return soap->error;
	if (soap_out_string(soap, "userClassId", -1, &a->userClassId, ""))
		return soap->error;
	if (soap_out_long(soap, "id", -1, &a->id, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdGetFilePKIById * SOAP_FMAC4 soap_in_bmd230__bmdGetFilePKIById(struct soap *soap, const char *tag, struct bmd230__bmdGetFilePKIById *a, const char *type)
{
	size_t soap_flag_cert = 1;
	size_t soap_flag_userRoleId = 1;
	size_t soap_flag_userGroupId = 1;
	size_t soap_flag_userClassId = 1;
	size_t soap_flag_id = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdGetFilePKIById *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdGetFilePKIById, sizeof(struct bmd230__bmdGetFilePKIById), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdGetFilePKIById(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cert && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "cert", &a->cert, "xsd:base64Binary"))
				{	soap_flag_cert--;
					continue;
				}
			if (soap_flag_userRoleId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userRoleId", &a->userRoleId, "xsd:string"))
				{	soap_flag_userRoleId--;
					continue;
				}
			if (soap_flag_userGroupId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userGroupId", &a->userGroupId, "xsd:string"))
				{	soap_flag_userGroupId--;
					continue;
				}
			if (soap_flag_userClassId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userClassId", &a->userClassId, "xsd:string"))
				{	soap_flag_userClassId--;
					continue;
				}
			if (soap_flag_id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_long(soap, "id", &a->id, "xsd:long"))
				{	soap_flag_id--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdGetFilePKIById *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdGetFilePKIById, 0, sizeof(struct bmd230__bmdGetFilePKIById), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdGetFilePKIById(struct soap *soap, const struct bmd230__bmdGetFilePKIById *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdGetFilePKIById);
	if (soap_out_bmd230__bmdGetFilePKIById(soap, tag?tag:"bmd230:bmdGetFilePKIById", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdGetFilePKIById * SOAP_FMAC4 soap_get_bmd230__bmdGetFilePKIById(struct soap *soap, struct bmd230__bmdGetFilePKIById *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdGetFilePKIById(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdGetFilePKIByIdResponse(struct soap *soap, struct bmd230__bmdGetFilePKIByIdResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->output = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdGetFilePKIByIdResponse(struct soap *soap, const struct bmd230__bmdGetFilePKIByIdResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToPointerTobmd230__PkiFileInfo(soap, &a->output);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdGetFilePKIByIdResponse(struct soap *soap, const char *tag, int id, const struct bmd230__bmdGetFilePKIByIdResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdGetFilePKIByIdResponse), type))
		return soap->error;
	if (soap_out_PointerToPointerTobmd230__PkiFileInfo(soap, "output", -1, &a->output, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdGetFilePKIByIdResponse * SOAP_FMAC4 soap_in_bmd230__bmdGetFilePKIByIdResponse(struct soap *soap, const char *tag, struct bmd230__bmdGetFilePKIByIdResponse *a, const char *type)
{
	size_t soap_flag_output = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdGetFilePKIByIdResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdGetFilePKIByIdResponse, sizeof(struct bmd230__bmdGetFilePKIByIdResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdGetFilePKIByIdResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_output && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToPointerTobmd230__PkiFileInfo(soap, "output", &a->output, "bmd230:PkiFileInfo"))
				{	soap_flag_output--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdGetFilePKIByIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdGetFilePKIByIdResponse, 0, sizeof(struct bmd230__bmdGetFilePKIByIdResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdGetFilePKIByIdResponse(struct soap *soap, const struct bmd230__bmdGetFilePKIByIdResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdGetFilePKIByIdResponse);
	if (soap_out_bmd230__bmdGetFilePKIByIdResponse(soap, tag?tag:"bmd230:bmdGetFilePKIByIdResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdGetFilePKIByIdResponse * SOAP_FMAC4 soap_get_bmd230__bmdGetFilePKIByIdResponse(struct soap *soap, struct bmd230__bmdGetFilePKIByIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdGetFilePKIByIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdGetFilePropByID(struct soap *soap, struct bmd230__bmdGetFilePropByID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cert = NULL;
	soap_default_string(soap, &a->userRoleId);
	soap_default_string(soap, &a->userGroupId);
	soap_default_string(soap, &a->userClassId);
	soap_default_long(soap, &a->id);
	soap_default_int(soap, &a->property);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdGetFilePropByID(struct soap *soap, const struct bmd230__bmdGetFilePropByID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__base64Binary(soap, &a->cert);
	soap_serialize_string(soap, &a->userRoleId);
	soap_serialize_string(soap, &a->userGroupId);
	soap_serialize_string(soap, &a->userClassId);
	soap_embedded(soap, &a->id, SOAP_TYPE_long);
	soap_embedded(soap, &a->property, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdGetFilePropByID(struct soap *soap, const char *tag, int id, const struct bmd230__bmdGetFilePropByID *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdGetFilePropByID), type))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "cert", -1, &a->cert, ""))
		return soap->error;
	if (soap_out_string(soap, "userRoleId", -1, &a->userRoleId, ""))
		return soap->error;
	if (soap_out_string(soap, "userGroupId", -1, &a->userGroupId, ""))
		return soap->error;
	if (soap_out_string(soap, "userClassId", -1, &a->userClassId, ""))
		return soap->error;
	if (soap_out_long(soap, "id", -1, &a->id, ""))
		return soap->error;
	if (soap_out_int(soap, "property", -1, &a->property, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdGetFilePropByID * SOAP_FMAC4 soap_in_bmd230__bmdGetFilePropByID(struct soap *soap, const char *tag, struct bmd230__bmdGetFilePropByID *a, const char *type)
{
	size_t soap_flag_cert = 1;
	size_t soap_flag_userRoleId = 1;
	size_t soap_flag_userGroupId = 1;
	size_t soap_flag_userClassId = 1;
	size_t soap_flag_id = 1;
	size_t soap_flag_property = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdGetFilePropByID *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdGetFilePropByID, sizeof(struct bmd230__bmdGetFilePropByID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdGetFilePropByID(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cert && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "cert", &a->cert, "xsd:base64Binary"))
				{	soap_flag_cert--;
					continue;
				}
			if (soap_flag_userRoleId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userRoleId", &a->userRoleId, "xsd:string"))
				{	soap_flag_userRoleId--;
					continue;
				}
			if (soap_flag_userGroupId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userGroupId", &a->userGroupId, "xsd:string"))
				{	soap_flag_userGroupId--;
					continue;
				}
			if (soap_flag_userClassId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userClassId", &a->userClassId, "xsd:string"))
				{	soap_flag_userClassId--;
					continue;
				}
			if (soap_flag_id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_long(soap, "id", &a->id, "xsd:long"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_property && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "property", &a->property, "xsd:int"))
				{	soap_flag_property--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdGetFilePropByID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdGetFilePropByID, 0, sizeof(struct bmd230__bmdGetFilePropByID), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0 || soap_flag_property > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdGetFilePropByID(struct soap *soap, const struct bmd230__bmdGetFilePropByID *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdGetFilePropByID);
	if (soap_out_bmd230__bmdGetFilePropByID(soap, tag?tag:"bmd230:bmdGetFilePropByID", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdGetFilePropByID * SOAP_FMAC4 soap_get_bmd230__bmdGetFilePropByID(struct soap *soap, struct bmd230__bmdGetFilePropByID *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdGetFilePropByID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdGetFilePropByIDResponse(struct soap *soap, struct bmd230__bmdGetFilePropByIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->output = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdGetFilePropByIDResponse(struct soap *soap, const struct bmd230__bmdGetFilePropByIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToPointerTobmd230__fileInfo(soap, &a->output);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdGetFilePropByIDResponse(struct soap *soap, const char *tag, int id, const struct bmd230__bmdGetFilePropByIDResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdGetFilePropByIDResponse), type))
		return soap->error;
	if (soap_out_PointerToPointerTobmd230__fileInfo(soap, "output", -1, &a->output, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdGetFilePropByIDResponse * SOAP_FMAC4 soap_in_bmd230__bmdGetFilePropByIDResponse(struct soap *soap, const char *tag, struct bmd230__bmdGetFilePropByIDResponse *a, const char *type)
{
	size_t soap_flag_output = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdGetFilePropByIDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdGetFilePropByIDResponse, sizeof(struct bmd230__bmdGetFilePropByIDResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdGetFilePropByIDResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_output && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToPointerTobmd230__fileInfo(soap, "output", &a->output, "bmd230:fileInfo"))
				{	soap_flag_output--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdGetFilePropByIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdGetFilePropByIDResponse, 0, sizeof(struct bmd230__bmdGetFilePropByIDResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdGetFilePropByIDResponse(struct soap *soap, const struct bmd230__bmdGetFilePropByIDResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdGetFilePropByIDResponse);
	if (soap_out_bmd230__bmdGetFilePropByIDResponse(soap, tag?tag:"bmd230:bmdGetFilePropByIDResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdGetFilePropByIDResponse * SOAP_FMAC4 soap_get_bmd230__bmdGetFilePropByIDResponse(struct soap *soap, struct bmd230__bmdGetFilePropByIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdGetFilePropByIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdGetFileByIdInZipPack(struct soap *soap, struct bmd230__bmdGetFileByIdInZipPack *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cert = NULL;
	soap_default_string(soap, &a->userRoleId);
	soap_default_string(soap, &a->userGroupId);
	soap_default_string(soap, &a->userClassId);
	soap_default_long(soap, &a->id);
	soap_default_trans_t(soap, &a->type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdGetFileByIdInZipPack(struct soap *soap, const struct bmd230__bmdGetFileByIdInZipPack *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__base64Binary(soap, &a->cert);
	soap_serialize_string(soap, &a->userRoleId);
	soap_serialize_string(soap, &a->userGroupId);
	soap_serialize_string(soap, &a->userClassId);
	soap_embedded(soap, &a->id, SOAP_TYPE_long);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdGetFileByIdInZipPack(struct soap *soap, const char *tag, int id, const struct bmd230__bmdGetFileByIdInZipPack *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdGetFileByIdInZipPack), type))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "cert", -1, &a->cert, ""))
		return soap->error;
	if (soap_out_string(soap, "userRoleId", -1, &a->userRoleId, ""))
		return soap->error;
	if (soap_out_string(soap, "userGroupId", -1, &a->userGroupId, ""))
		return soap->error;
	if (soap_out_string(soap, "userClassId", -1, &a->userClassId, ""))
		return soap->error;
	if (soap_out_long(soap, "id", -1, &a->id, ""))
		return soap->error;
	if (soap_out_trans_t(soap, "type", -1, &a->type, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdGetFileByIdInZipPack * SOAP_FMAC4 soap_in_bmd230__bmdGetFileByIdInZipPack(struct soap *soap, const char *tag, struct bmd230__bmdGetFileByIdInZipPack *a, const char *type)
{
	size_t soap_flag_cert = 1;
	size_t soap_flag_userRoleId = 1;
	size_t soap_flag_userGroupId = 1;
	size_t soap_flag_userClassId = 1;
	size_t soap_flag_id = 1;
	size_t soap_flag_type = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdGetFileByIdInZipPack *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdGetFileByIdInZipPack, sizeof(struct bmd230__bmdGetFileByIdInZipPack), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdGetFileByIdInZipPack(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cert && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "cert", &a->cert, "xsd:base64Binary"))
				{	soap_flag_cert--;
					continue;
				}
			if (soap_flag_userRoleId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userRoleId", &a->userRoleId, "xsd:string"))
				{	soap_flag_userRoleId--;
					continue;
				}
			if (soap_flag_userGroupId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userGroupId", &a->userGroupId, "xsd:string"))
				{	soap_flag_userGroupId--;
					continue;
				}
			if (soap_flag_userClassId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userClassId", &a->userClassId, "xsd:string"))
				{	soap_flag_userClassId--;
					continue;
				}
			if (soap_flag_id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_long(soap, "id", &a->id, "xsd:long"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_type && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_trans_t(soap, "type", &a->type, "trans-t"))
				{	soap_flag_type--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdGetFileByIdInZipPack *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdGetFileByIdInZipPack, 0, sizeof(struct bmd230__bmdGetFileByIdInZipPack), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0 || soap_flag_type > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdGetFileByIdInZipPack(struct soap *soap, const struct bmd230__bmdGetFileByIdInZipPack *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdGetFileByIdInZipPack);
	if (soap_out_bmd230__bmdGetFileByIdInZipPack(soap, tag?tag:"bmd230:bmdGetFileByIdInZipPack", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdGetFileByIdInZipPack * SOAP_FMAC4 soap_get_bmd230__bmdGetFileByIdInZipPack(struct soap *soap, struct bmd230__bmdGetFileByIdInZipPack *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdGetFileByIdInZipPack(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdGetFileByIdInZipPackResponse(struct soap *soap, struct bmd230__bmdGetFileByIdInZipPackResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->output = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdGetFileByIdInZipPackResponse(struct soap *soap, const struct bmd230__bmdGetFileByIdInZipPackResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToPointerTobmd230__fileInfo(soap, &a->output);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdGetFileByIdInZipPackResponse(struct soap *soap, const char *tag, int id, const struct bmd230__bmdGetFileByIdInZipPackResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdGetFileByIdInZipPackResponse), type))
		return soap->error;
	if (soap_out_PointerToPointerTobmd230__fileInfo(soap, "output", -1, &a->output, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdGetFileByIdInZipPackResponse * SOAP_FMAC4 soap_in_bmd230__bmdGetFileByIdInZipPackResponse(struct soap *soap, const char *tag, struct bmd230__bmdGetFileByIdInZipPackResponse *a, const char *type)
{
	size_t soap_flag_output = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdGetFileByIdInZipPackResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdGetFileByIdInZipPackResponse, sizeof(struct bmd230__bmdGetFileByIdInZipPackResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdGetFileByIdInZipPackResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_output && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToPointerTobmd230__fileInfo(soap, "output", &a->output, "bmd230:fileInfo"))
				{	soap_flag_output--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdGetFileByIdInZipPackResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdGetFileByIdInZipPackResponse, 0, sizeof(struct bmd230__bmdGetFileByIdInZipPackResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdGetFileByIdInZipPackResponse(struct soap *soap, const struct bmd230__bmdGetFileByIdInZipPackResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdGetFileByIdInZipPackResponse);
	if (soap_out_bmd230__bmdGetFileByIdInZipPackResponse(soap, tag?tag:"bmd230:bmdGetFileByIdInZipPackResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdGetFileByIdInZipPackResponse * SOAP_FMAC4 soap_get_bmd230__bmdGetFileByIdInZipPackResponse(struct soap *soap, struct bmd230__bmdGetFileByIdInZipPackResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdGetFileByIdInZipPackResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdGetFileByHash(struct soap *soap, struct bmd230__bmdGetFileByHash *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cert = NULL;
	soap_default_string(soap, &a->userRoleId);
	soap_default_string(soap, &a->userGroupId);
	soap_default_string(soap, &a->userClassId);
	soap_default_string(soap, &a->hash);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdGetFileByHash(struct soap *soap, const struct bmd230__bmdGetFileByHash *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__base64Binary(soap, &a->cert);
	soap_serialize_string(soap, &a->userRoleId);
	soap_serialize_string(soap, &a->userGroupId);
	soap_serialize_string(soap, &a->userClassId);
	soap_serialize_string(soap, &a->hash);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdGetFileByHash(struct soap *soap, const char *tag, int id, const struct bmd230__bmdGetFileByHash *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdGetFileByHash), type))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "cert", -1, &a->cert, ""))
		return soap->error;
	if (soap_out_string(soap, "userRoleId", -1, &a->userRoleId, ""))
		return soap->error;
	if (soap_out_string(soap, "userGroupId", -1, &a->userGroupId, ""))
		return soap->error;
	if (soap_out_string(soap, "userClassId", -1, &a->userClassId, ""))
		return soap->error;
	if (soap_out_string(soap, "hash", -1, &a->hash, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdGetFileByHash * SOAP_FMAC4 soap_in_bmd230__bmdGetFileByHash(struct soap *soap, const char *tag, struct bmd230__bmdGetFileByHash *a, const char *type)
{
	size_t soap_flag_cert = 1;
	size_t soap_flag_userRoleId = 1;
	size_t soap_flag_userGroupId = 1;
	size_t soap_flag_userClassId = 1;
	size_t soap_flag_hash = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdGetFileByHash *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdGetFileByHash, sizeof(struct bmd230__bmdGetFileByHash), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdGetFileByHash(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cert && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "cert", &a->cert, "xsd:base64Binary"))
				{	soap_flag_cert--;
					continue;
				}
			if (soap_flag_userRoleId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userRoleId", &a->userRoleId, "xsd:string"))
				{	soap_flag_userRoleId--;
					continue;
				}
			if (soap_flag_userGroupId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userGroupId", &a->userGroupId, "xsd:string"))
				{	soap_flag_userGroupId--;
					continue;
				}
			if (soap_flag_userClassId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userClassId", &a->userClassId, "xsd:string"))
				{	soap_flag_userClassId--;
					continue;
				}
			if (soap_flag_hash && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "hash", &a->hash, "xsd:string"))
				{	soap_flag_hash--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdGetFileByHash *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdGetFileByHash, 0, sizeof(struct bmd230__bmdGetFileByHash), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdGetFileByHash(struct soap *soap, const struct bmd230__bmdGetFileByHash *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdGetFileByHash);
	if (soap_out_bmd230__bmdGetFileByHash(soap, tag?tag:"bmd230:bmdGetFileByHash", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdGetFileByHash * SOAP_FMAC4 soap_get_bmd230__bmdGetFileByHash(struct soap *soap, struct bmd230__bmdGetFileByHash *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdGetFileByHash(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdGetFileByHashResponse(struct soap *soap, struct bmd230__bmdGetFileByHashResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->output = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdGetFileByHashResponse(struct soap *soap, const struct bmd230__bmdGetFileByHashResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToPointerTobmd230__fileInfo(soap, &a->output);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdGetFileByHashResponse(struct soap *soap, const char *tag, int id, const struct bmd230__bmdGetFileByHashResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdGetFileByHashResponse), type))
		return soap->error;
	if (soap_out_PointerToPointerTobmd230__fileInfo(soap, "output", -1, &a->output, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdGetFileByHashResponse * SOAP_FMAC4 soap_in_bmd230__bmdGetFileByHashResponse(struct soap *soap, const char *tag, struct bmd230__bmdGetFileByHashResponse *a, const char *type)
{
	size_t soap_flag_output = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdGetFileByHashResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdGetFileByHashResponse, sizeof(struct bmd230__bmdGetFileByHashResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdGetFileByHashResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_output && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToPointerTobmd230__fileInfo(soap, "output", &a->output, "bmd230:fileInfo"))
				{	soap_flag_output--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdGetFileByHashResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdGetFileByHashResponse, 0, sizeof(struct bmd230__bmdGetFileByHashResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdGetFileByHashResponse(struct soap *soap, const struct bmd230__bmdGetFileByHashResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdGetFileByHashResponse);
	if (soap_out_bmd230__bmdGetFileByHashResponse(soap, tag?tag:"bmd230:bmdGetFileByHashResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdGetFileByHashResponse * SOAP_FMAC4 soap_get_bmd230__bmdGetFileByHashResponse(struct soap *soap, struct bmd230__bmdGetFileByHashResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdGetFileByHashResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdGetArchiveFileVersion(struct soap *soap, struct bmd230__bmdGetArchiveFileVersion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cert = NULL;
	soap_default_string(soap, &a->userRoleId);
	soap_default_string(soap, &a->userGroupId);
	soap_default_string(soap, &a->userClassId);
	soap_default_long(soap, &a->currentVersionFileId);
	soap_default_long(soap, &a->archiveVersionFileId);
	soap_default_trans_t(soap, &a->type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdGetArchiveFileVersion(struct soap *soap, const struct bmd230__bmdGetArchiveFileVersion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__base64Binary(soap, &a->cert);
	soap_serialize_string(soap, &a->userRoleId);
	soap_serialize_string(soap, &a->userGroupId);
	soap_serialize_string(soap, &a->userClassId);
	soap_embedded(soap, &a->currentVersionFileId, SOAP_TYPE_long);
	soap_embedded(soap, &a->archiveVersionFileId, SOAP_TYPE_long);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdGetArchiveFileVersion(struct soap *soap, const char *tag, int id, const struct bmd230__bmdGetArchiveFileVersion *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdGetArchiveFileVersion), type))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "cert", -1, &a->cert, ""))
		return soap->error;
	if (soap_out_string(soap, "userRoleId", -1, &a->userRoleId, ""))
		return soap->error;
	if (soap_out_string(soap, "userGroupId", -1, &a->userGroupId, ""))
		return soap->error;
	if (soap_out_string(soap, "userClassId", -1, &a->userClassId, ""))
		return soap->error;
	if (soap_out_long(soap, "currentVersionFileId", -1, &a->currentVersionFileId, ""))
		return soap->error;
	if (soap_out_long(soap, "archiveVersionFileId", -1, &a->archiveVersionFileId, ""))
		return soap->error;
	if (soap_out_trans_t(soap, "type", -1, &a->type, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdGetArchiveFileVersion * SOAP_FMAC4 soap_in_bmd230__bmdGetArchiveFileVersion(struct soap *soap, const char *tag, struct bmd230__bmdGetArchiveFileVersion *a, const char *type)
{
	size_t soap_flag_cert = 1;
	size_t soap_flag_userRoleId = 1;
	size_t soap_flag_userGroupId = 1;
	size_t soap_flag_userClassId = 1;
	size_t soap_flag_currentVersionFileId = 1;
	size_t soap_flag_archiveVersionFileId = 1;
	size_t soap_flag_type = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdGetArchiveFileVersion *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdGetArchiveFileVersion, sizeof(struct bmd230__bmdGetArchiveFileVersion), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdGetArchiveFileVersion(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cert && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "cert", &a->cert, "xsd:base64Binary"))
				{	soap_flag_cert--;
					continue;
				}
			if (soap_flag_userRoleId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userRoleId", &a->userRoleId, "xsd:string"))
				{	soap_flag_userRoleId--;
					continue;
				}
			if (soap_flag_userGroupId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userGroupId", &a->userGroupId, "xsd:string"))
				{	soap_flag_userGroupId--;
					continue;
				}
			if (soap_flag_userClassId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userClassId", &a->userClassId, "xsd:string"))
				{	soap_flag_userClassId--;
					continue;
				}
			if (soap_flag_currentVersionFileId && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_long(soap, "currentVersionFileId", &a->currentVersionFileId, "xsd:long"))
				{	soap_flag_currentVersionFileId--;
					continue;
				}
			if (soap_flag_archiveVersionFileId && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_long(soap, "archiveVersionFileId", &a->archiveVersionFileId, "xsd:long"))
				{	soap_flag_archiveVersionFileId--;
					continue;
				}
			if (soap_flag_type && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_trans_t(soap, "type", &a->type, "trans-t"))
				{	soap_flag_type--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdGetArchiveFileVersion *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdGetArchiveFileVersion, 0, sizeof(struct bmd230__bmdGetArchiveFileVersion), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_currentVersionFileId > 0 || soap_flag_archiveVersionFileId > 0 || soap_flag_type > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdGetArchiveFileVersion(struct soap *soap, const struct bmd230__bmdGetArchiveFileVersion *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdGetArchiveFileVersion);
	if (soap_out_bmd230__bmdGetArchiveFileVersion(soap, tag?tag:"bmd230:bmdGetArchiveFileVersion", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdGetArchiveFileVersion * SOAP_FMAC4 soap_get_bmd230__bmdGetArchiveFileVersion(struct soap *soap, struct bmd230__bmdGetArchiveFileVersion *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdGetArchiveFileVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdGetArchiveFileVersionResponse(struct soap *soap, struct bmd230__bmdGetArchiveFileVersionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->output = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdGetArchiveFileVersionResponse(struct soap *soap, const struct bmd230__bmdGetArchiveFileVersionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToPointerTobmd230__fileInfo(soap, &a->output);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdGetArchiveFileVersionResponse(struct soap *soap, const char *tag, int id, const struct bmd230__bmdGetArchiveFileVersionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdGetArchiveFileVersionResponse), type))
		return soap->error;
	if (soap_out_PointerToPointerTobmd230__fileInfo(soap, "output", -1, &a->output, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdGetArchiveFileVersionResponse * SOAP_FMAC4 soap_in_bmd230__bmdGetArchiveFileVersionResponse(struct soap *soap, const char *tag, struct bmd230__bmdGetArchiveFileVersionResponse *a, const char *type)
{
	size_t soap_flag_output = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdGetArchiveFileVersionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdGetArchiveFileVersionResponse, sizeof(struct bmd230__bmdGetArchiveFileVersionResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdGetArchiveFileVersionResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_output && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToPointerTobmd230__fileInfo(soap, "output", &a->output, "bmd230:fileInfo"))
				{	soap_flag_output--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdGetArchiveFileVersionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdGetArchiveFileVersionResponse, 0, sizeof(struct bmd230__bmdGetArchiveFileVersionResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdGetArchiveFileVersionResponse(struct soap *soap, const struct bmd230__bmdGetArchiveFileVersionResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdGetArchiveFileVersionResponse);
	if (soap_out_bmd230__bmdGetArchiveFileVersionResponse(soap, tag?tag:"bmd230:bmdGetArchiveFileVersionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdGetArchiveFileVersionResponse * SOAP_FMAC4 soap_get_bmd230__bmdGetArchiveFileVersionResponse(struct soap *soap, struct bmd230__bmdGetArchiveFileVersionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdGetArchiveFileVersionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdGetFileById(struct soap *soap, struct bmd230__bmdGetFileById *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cert = NULL;
	soap_default_string(soap, &a->userRoleId);
	soap_default_string(soap, &a->userGroupId);
	soap_default_string(soap, &a->userClassId);
	soap_default_long(soap, &a->id);
	soap_default_trans_t(soap, &a->type);
	soap_default_string(soap, &a->parameter);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdGetFileById(struct soap *soap, const struct bmd230__bmdGetFileById *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__base64Binary(soap, &a->cert);
	soap_serialize_string(soap, &a->userRoleId);
	soap_serialize_string(soap, &a->userGroupId);
	soap_serialize_string(soap, &a->userClassId);
	soap_embedded(soap, &a->id, SOAP_TYPE_long);
	soap_serialize_string(soap, &a->parameter);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdGetFileById(struct soap *soap, const char *tag, int id, const struct bmd230__bmdGetFileById *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdGetFileById), type))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "cert", -1, &a->cert, ""))
		return soap->error;
	if (soap_out_string(soap, "userRoleId", -1, &a->userRoleId, ""))
		return soap->error;
	if (soap_out_string(soap, "userGroupId", -1, &a->userGroupId, ""))
		return soap->error;
	if (soap_out_string(soap, "userClassId", -1, &a->userClassId, ""))
		return soap->error;
	if (soap_out_long(soap, "id", -1, &a->id, ""))
		return soap->error;
	if (soap_out_trans_t(soap, "type", -1, &a->type, ""))
		return soap->error;
	if (soap_out_string(soap, "parameter", -1, &a->parameter, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdGetFileById * SOAP_FMAC4 soap_in_bmd230__bmdGetFileById(struct soap *soap, const char *tag, struct bmd230__bmdGetFileById *a, const char *type)
{
	size_t soap_flag_cert = 1;
	size_t soap_flag_userRoleId = 1;
	size_t soap_flag_userGroupId = 1;
	size_t soap_flag_userClassId = 1;
	size_t soap_flag_id = 1;
	size_t soap_flag_type = 1;
	size_t soap_flag_parameter = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdGetFileById *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdGetFileById, sizeof(struct bmd230__bmdGetFileById), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdGetFileById(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cert && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "cert", &a->cert, "xsd:base64Binary"))
				{	soap_flag_cert--;
					continue;
				}
			if (soap_flag_userRoleId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userRoleId", &a->userRoleId, "xsd:string"))
				{	soap_flag_userRoleId--;
					continue;
				}
			if (soap_flag_userGroupId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userGroupId", &a->userGroupId, "xsd:string"))
				{	soap_flag_userGroupId--;
					continue;
				}
			if (soap_flag_userClassId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userClassId", &a->userClassId, "xsd:string"))
				{	soap_flag_userClassId--;
					continue;
				}
			if (soap_flag_id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_long(soap, "id", &a->id, "xsd:long"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_type && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_trans_t(soap, "type", &a->type, "trans-t"))
				{	soap_flag_type--;
					continue;
				}
			if (soap_flag_parameter && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "parameter", &a->parameter, "xsd:string"))
				{	soap_flag_parameter--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdGetFileById *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdGetFileById, 0, sizeof(struct bmd230__bmdGetFileById), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0 || soap_flag_type > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdGetFileById(struct soap *soap, const struct bmd230__bmdGetFileById *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdGetFileById);
	if (soap_out_bmd230__bmdGetFileById(soap, tag?tag:"bmd230:bmdGetFileById", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdGetFileById * SOAP_FMAC4 soap_get_bmd230__bmdGetFileById(struct soap *soap, struct bmd230__bmdGetFileById *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdGetFileById(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdGetFileByIdResponse(struct soap *soap, struct bmd230__bmdGetFileByIdResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->output = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdGetFileByIdResponse(struct soap *soap, const struct bmd230__bmdGetFileByIdResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToPointerTobmd230__fileInfo(soap, &a->output);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdGetFileByIdResponse(struct soap *soap, const char *tag, int id, const struct bmd230__bmdGetFileByIdResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdGetFileByIdResponse), type))
		return soap->error;
	if (soap_out_PointerToPointerTobmd230__fileInfo(soap, "output", -1, &a->output, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdGetFileByIdResponse * SOAP_FMAC4 soap_in_bmd230__bmdGetFileByIdResponse(struct soap *soap, const char *tag, struct bmd230__bmdGetFileByIdResponse *a, const char *type)
{
	size_t soap_flag_output = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdGetFileByIdResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdGetFileByIdResponse, sizeof(struct bmd230__bmdGetFileByIdResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdGetFileByIdResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_output && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToPointerTobmd230__fileInfo(soap, "output", &a->output, "bmd230:fileInfo"))
				{	soap_flag_output--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdGetFileByIdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdGetFileByIdResponse, 0, sizeof(struct bmd230__bmdGetFileByIdResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdGetFileByIdResponse(struct soap *soap, const struct bmd230__bmdGetFileByIdResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdGetFileByIdResponse);
	if (soap_out_bmd230__bmdGetFileByIdResponse(soap, tag?tag:"bmd230:bmdGetFileByIdResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdGetFileByIdResponse * SOAP_FMAC4 soap_get_bmd230__bmdGetFileByIdResponse(struct soap *soap, struct bmd230__bmdGetFileByIdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdGetFileByIdResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdGetSecurityList(struct soap *soap, struct bmd230__bmdGetSecurityList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cert = NULL;
	soap_default_string(soap, &a->userRoleId);
	soap_default_string(soap, &a->userGroupId);
	soap_default_string(soap, &a->userClassId);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdGetSecurityList(struct soap *soap, const struct bmd230__bmdGetSecurityList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__base64Binary(soap, &a->cert);
	soap_serialize_string(soap, &a->userRoleId);
	soap_serialize_string(soap, &a->userGroupId);
	soap_serialize_string(soap, &a->userClassId);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdGetSecurityList(struct soap *soap, const char *tag, int id, const struct bmd230__bmdGetSecurityList *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdGetSecurityList), type))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "cert", -1, &a->cert, ""))
		return soap->error;
	if (soap_out_string(soap, "userRoleId", -1, &a->userRoleId, ""))
		return soap->error;
	if (soap_out_string(soap, "userGroupId", -1, &a->userGroupId, ""))
		return soap->error;
	if (soap_out_string(soap, "userClassId", -1, &a->userClassId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdGetSecurityList * SOAP_FMAC4 soap_in_bmd230__bmdGetSecurityList(struct soap *soap, const char *tag, struct bmd230__bmdGetSecurityList *a, const char *type)
{
	size_t soap_flag_cert = 1;
	size_t soap_flag_userRoleId = 1;
	size_t soap_flag_userGroupId = 1;
	size_t soap_flag_userClassId = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdGetSecurityList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdGetSecurityList, sizeof(struct bmd230__bmdGetSecurityList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdGetSecurityList(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cert && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "cert", &a->cert, "xsd:base64Binary"))
				{	soap_flag_cert--;
					continue;
				}
			if (soap_flag_userRoleId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userRoleId", &a->userRoleId, "xsd:string"))
				{	soap_flag_userRoleId--;
					continue;
				}
			if (soap_flag_userGroupId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userGroupId", &a->userGroupId, "xsd:string"))
				{	soap_flag_userGroupId--;
					continue;
				}
			if (soap_flag_userClassId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userClassId", &a->userClassId, "xsd:string"))
				{	soap_flag_userClassId--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdGetSecurityList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdGetSecurityList, 0, sizeof(struct bmd230__bmdGetSecurityList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdGetSecurityList(struct soap *soap, const struct bmd230__bmdGetSecurityList *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdGetSecurityList);
	if (soap_out_bmd230__bmdGetSecurityList(soap, tag?tag:"bmd230:bmdGetSecurityList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdGetSecurityList * SOAP_FMAC4 soap_get_bmd230__bmdGetSecurityList(struct soap *soap, struct bmd230__bmdGetSecurityList *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdGetSecurityList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdGetSecurityListResponse(struct soap *soap, struct bmd230__bmdGetSecurityListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdGetSecurityListResponse(struct soap *soap, const struct bmd230__bmdGetSecurityListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToPointerTobmd230__securityInfo(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdGetSecurityListResponse(struct soap *soap, const char *tag, int id, const struct bmd230__bmdGetSecurityListResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdGetSecurityListResponse), type))
		return soap->error;
	if (soap_out_PointerToPointerTobmd230__securityInfo(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdGetSecurityListResponse * SOAP_FMAC4 soap_in_bmd230__bmdGetSecurityListResponse(struct soap *soap, const char *tag, struct bmd230__bmdGetSecurityListResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdGetSecurityListResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdGetSecurityListResponse, sizeof(struct bmd230__bmdGetSecurityListResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdGetSecurityListResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToPointerTobmd230__securityInfo(soap, "result", &a->result, "bmd230:securityInfo"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdGetSecurityListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdGetSecurityListResponse, 0, sizeof(struct bmd230__bmdGetSecurityListResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdGetSecurityListResponse(struct soap *soap, const struct bmd230__bmdGetSecurityListResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdGetSecurityListResponse);
	if (soap_out_bmd230__bmdGetSecurityListResponse(soap, tag?tag:"bmd230:bmdGetSecurityListResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdGetSecurityListResponse * SOAP_FMAC4 soap_get_bmd230__bmdGetSecurityListResponse(struct soap *soap, struct bmd230__bmdGetSecurityListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdGetSecurityListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdRegisterNewSecurityCategory(struct soap *soap, struct bmd230__bmdRegisterNewSecurityCategory *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cert = NULL;
	soap_default_string(soap, &a->userRoleId);
	soap_default_string(soap, &a->userGroupId);
	soap_default_string(soap, &a->userClassId);
	a->secCategoryInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdRegisterNewSecurityCategory(struct soap *soap, const struct bmd230__bmdRegisterNewSecurityCategory *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__base64Binary(soap, &a->cert);
	soap_serialize_string(soap, &a->userRoleId);
	soap_serialize_string(soap, &a->userGroupId);
	soap_serialize_string(soap, &a->userClassId);
	soap_serialize_PointerTobmd230__singleSecCategoryInfo(soap, &a->secCategoryInfo);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdRegisterNewSecurityCategory(struct soap *soap, const char *tag, int id, const struct bmd230__bmdRegisterNewSecurityCategory *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdRegisterNewSecurityCategory), type))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "cert", -1, &a->cert, ""))
		return soap->error;
	if (soap_out_string(soap, "userRoleId", -1, &a->userRoleId, ""))
		return soap->error;
	if (soap_out_string(soap, "userGroupId", -1, &a->userGroupId, ""))
		return soap->error;
	if (soap_out_string(soap, "userClassId", -1, &a->userClassId, ""))
		return soap->error;
	if (soap_out_PointerTobmd230__singleSecCategoryInfo(soap, "secCategoryInfo", -1, &a->secCategoryInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdRegisterNewSecurityCategory * SOAP_FMAC4 soap_in_bmd230__bmdRegisterNewSecurityCategory(struct soap *soap, const char *tag, struct bmd230__bmdRegisterNewSecurityCategory *a, const char *type)
{
	size_t soap_flag_cert = 1;
	size_t soap_flag_userRoleId = 1;
	size_t soap_flag_userGroupId = 1;
	size_t soap_flag_userClassId = 1;
	size_t soap_flag_secCategoryInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdRegisterNewSecurityCategory *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdRegisterNewSecurityCategory, sizeof(struct bmd230__bmdRegisterNewSecurityCategory), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdRegisterNewSecurityCategory(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cert && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "cert", &a->cert, "xsd:base64Binary"))
				{	soap_flag_cert--;
					continue;
				}
			if (soap_flag_userRoleId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userRoleId", &a->userRoleId, "xsd:string"))
				{	soap_flag_userRoleId--;
					continue;
				}
			if (soap_flag_userGroupId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userGroupId", &a->userGroupId, "xsd:string"))
				{	soap_flag_userGroupId--;
					continue;
				}
			if (soap_flag_userClassId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userClassId", &a->userClassId, "xsd:string"))
				{	soap_flag_userClassId--;
					continue;
				}
			if (soap_flag_secCategoryInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobmd230__singleSecCategoryInfo(soap, "secCategoryInfo", &a->secCategoryInfo, "bmd230:singleSecCategoryInfo"))
				{	soap_flag_secCategoryInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdRegisterNewSecurityCategory *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdRegisterNewSecurityCategory, 0, sizeof(struct bmd230__bmdRegisterNewSecurityCategory), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdRegisterNewSecurityCategory(struct soap *soap, const struct bmd230__bmdRegisterNewSecurityCategory *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdRegisterNewSecurityCategory);
	if (soap_out_bmd230__bmdRegisterNewSecurityCategory(soap, tag?tag:"bmd230:bmdRegisterNewSecurityCategory", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdRegisterNewSecurityCategory * SOAP_FMAC4 soap_get_bmd230__bmdRegisterNewSecurityCategory(struct soap *soap, struct bmd230__bmdRegisterNewSecurityCategory *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdRegisterNewSecurityCategory(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdRegisterNewSecurityCategoryResponse(struct soap *soap, struct bmd230__bmdRegisterNewSecurityCategoryResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdRegisterNewSecurityCategoryResponse(struct soap *soap, const struct bmd230__bmdRegisterNewSecurityCategoryResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdRegisterNewSecurityCategoryResponse(struct soap *soap, const char *tag, int id, const struct bmd230__bmdRegisterNewSecurityCategoryResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdRegisterNewSecurityCategoryResponse), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdRegisterNewSecurityCategoryResponse * SOAP_FMAC4 soap_in_bmd230__bmdRegisterNewSecurityCategoryResponse(struct soap *soap, const char *tag, struct bmd230__bmdRegisterNewSecurityCategoryResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdRegisterNewSecurityCategoryResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdRegisterNewSecurityCategoryResponse, sizeof(struct bmd230__bmdRegisterNewSecurityCategoryResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdRegisterNewSecurityCategoryResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdRegisterNewSecurityCategoryResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdRegisterNewSecurityCategoryResponse, 0, sizeof(struct bmd230__bmdRegisterNewSecurityCategoryResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdRegisterNewSecurityCategoryResponse(struct soap *soap, const struct bmd230__bmdRegisterNewSecurityCategoryResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdRegisterNewSecurityCategoryResponse);
	if (soap_out_bmd230__bmdRegisterNewSecurityCategoryResponse(soap, tag?tag:"bmd230:bmdRegisterNewSecurityCategoryResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdRegisterNewSecurityCategoryResponse * SOAP_FMAC4 soap_get_bmd230__bmdRegisterNewSecurityCategoryResponse(struct soap *soap, struct bmd230__bmdRegisterNewSecurityCategoryResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdRegisterNewSecurityCategoryResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdDeleteClass(struct soap *soap, struct bmd230__bmdDeleteClass *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cert = NULL;
	soap_default_string(soap, &a->userRoleId);
	soap_default_string(soap, &a->userGroupId);
	soap_default_string(soap, &a->userClassId);
	soap_default_string(soap, &a->classId);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdDeleteClass(struct soap *soap, const struct bmd230__bmdDeleteClass *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__base64Binary(soap, &a->cert);
	soap_serialize_string(soap, &a->userRoleId);
	soap_serialize_string(soap, &a->userGroupId);
	soap_serialize_string(soap, &a->userClassId);
	soap_serialize_string(soap, &a->classId);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdDeleteClass(struct soap *soap, const char *tag, int id, const struct bmd230__bmdDeleteClass *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdDeleteClass), type))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "cert", -1, &a->cert, ""))
		return soap->error;
	if (soap_out_string(soap, "userRoleId", -1, &a->userRoleId, ""))
		return soap->error;
	if (soap_out_string(soap, "userGroupId", -1, &a->userGroupId, ""))
		return soap->error;
	if (soap_out_string(soap, "userClassId", -1, &a->userClassId, ""))
		return soap->error;
	if (soap_out_string(soap, "classId", -1, &a->classId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdDeleteClass * SOAP_FMAC4 soap_in_bmd230__bmdDeleteClass(struct soap *soap, const char *tag, struct bmd230__bmdDeleteClass *a, const char *type)
{
	size_t soap_flag_cert = 1;
	size_t soap_flag_userRoleId = 1;
	size_t soap_flag_userGroupId = 1;
	size_t soap_flag_userClassId = 1;
	size_t soap_flag_classId = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdDeleteClass *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdDeleteClass, sizeof(struct bmd230__bmdDeleteClass), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdDeleteClass(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cert && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "cert", &a->cert, "xsd:base64Binary"))
				{	soap_flag_cert--;
					continue;
				}
			if (soap_flag_userRoleId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userRoleId", &a->userRoleId, "xsd:string"))
				{	soap_flag_userRoleId--;
					continue;
				}
			if (soap_flag_userGroupId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userGroupId", &a->userGroupId, "xsd:string"))
				{	soap_flag_userGroupId--;
					continue;
				}
			if (soap_flag_userClassId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userClassId", &a->userClassId, "xsd:string"))
				{	soap_flag_userClassId--;
					continue;
				}
			if (soap_flag_classId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "classId", &a->classId, "xsd:string"))
				{	soap_flag_classId--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdDeleteClass *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdDeleteClass, 0, sizeof(struct bmd230__bmdDeleteClass), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdDeleteClass(struct soap *soap, const struct bmd230__bmdDeleteClass *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdDeleteClass);
	if (soap_out_bmd230__bmdDeleteClass(soap, tag?tag:"bmd230:bmdDeleteClass", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdDeleteClass * SOAP_FMAC4 soap_get_bmd230__bmdDeleteClass(struct soap *soap, struct bmd230__bmdDeleteClass *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdDeleteClass(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdDeleteClassResponse(struct soap *soap, struct bmd230__bmdDeleteClassResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdDeleteClassResponse(struct soap *soap, const struct bmd230__bmdDeleteClassResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdDeleteClassResponse(struct soap *soap, const char *tag, int id, const struct bmd230__bmdDeleteClassResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdDeleteClassResponse), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdDeleteClassResponse * SOAP_FMAC4 soap_in_bmd230__bmdDeleteClassResponse(struct soap *soap, const char *tag, struct bmd230__bmdDeleteClassResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdDeleteClassResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdDeleteClassResponse, sizeof(struct bmd230__bmdDeleteClassResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdDeleteClassResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdDeleteClassResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdDeleteClassResponse, 0, sizeof(struct bmd230__bmdDeleteClassResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdDeleteClassResponse(struct soap *soap, const struct bmd230__bmdDeleteClassResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdDeleteClassResponse);
	if (soap_out_bmd230__bmdDeleteClassResponse(soap, tag?tag:"bmd230:bmdDeleteClassResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdDeleteClassResponse * SOAP_FMAC4 soap_get_bmd230__bmdDeleteClassResponse(struct soap *soap, struct bmd230__bmdDeleteClassResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdDeleteClassResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdGetClassList(struct soap *soap, struct bmd230__bmdGetClassList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cert = NULL;
	soap_default_string(soap, &a->userRoleId);
	soap_default_string(soap, &a->userGroupId);
	soap_default_string(soap, &a->userClassId);
	soap_default_string(soap, &a->classId);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdGetClassList(struct soap *soap, const struct bmd230__bmdGetClassList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__base64Binary(soap, &a->cert);
	soap_serialize_string(soap, &a->userRoleId);
	soap_serialize_string(soap, &a->userGroupId);
	soap_serialize_string(soap, &a->userClassId);
	soap_serialize_string(soap, &a->classId);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdGetClassList(struct soap *soap, const char *tag, int id, const struct bmd230__bmdGetClassList *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdGetClassList), type))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "cert", -1, &a->cert, ""))
		return soap->error;
	if (soap_out_string(soap, "userRoleId", -1, &a->userRoleId, ""))
		return soap->error;
	if (soap_out_string(soap, "userGroupId", -1, &a->userGroupId, ""))
		return soap->error;
	if (soap_out_string(soap, "userClassId", -1, &a->userClassId, ""))
		return soap->error;
	if (soap_out_string(soap, "classId", -1, &a->classId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdGetClassList * SOAP_FMAC4 soap_in_bmd230__bmdGetClassList(struct soap *soap, const char *tag, struct bmd230__bmdGetClassList *a, const char *type)
{
	size_t soap_flag_cert = 1;
	size_t soap_flag_userRoleId = 1;
	size_t soap_flag_userGroupId = 1;
	size_t soap_flag_userClassId = 1;
	size_t soap_flag_classId = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdGetClassList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdGetClassList, sizeof(struct bmd230__bmdGetClassList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdGetClassList(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cert && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "cert", &a->cert, "xsd:base64Binary"))
				{	soap_flag_cert--;
					continue;
				}
			if (soap_flag_userRoleId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userRoleId", &a->userRoleId, "xsd:string"))
				{	soap_flag_userRoleId--;
					continue;
				}
			if (soap_flag_userGroupId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userGroupId", &a->userGroupId, "xsd:string"))
				{	soap_flag_userGroupId--;
					continue;
				}
			if (soap_flag_userClassId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userClassId", &a->userClassId, "xsd:string"))
				{	soap_flag_userClassId--;
					continue;
				}
			if (soap_flag_classId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "classId", &a->classId, "xsd:string"))
				{	soap_flag_classId--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdGetClassList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdGetClassList, 0, sizeof(struct bmd230__bmdGetClassList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdGetClassList(struct soap *soap, const struct bmd230__bmdGetClassList *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdGetClassList);
	if (soap_out_bmd230__bmdGetClassList(soap, tag?tag:"bmd230:bmdGetClassList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdGetClassList * SOAP_FMAC4 soap_get_bmd230__bmdGetClassList(struct soap *soap, struct bmd230__bmdGetClassList *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdGetClassList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdGetClassListResponse(struct soap *soap, struct bmd230__bmdGetClassListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdGetClassListResponse(struct soap *soap, const struct bmd230__bmdGetClassListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToPointerTobmd230__classInfo(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdGetClassListResponse(struct soap *soap, const char *tag, int id, const struct bmd230__bmdGetClassListResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdGetClassListResponse), type))
		return soap->error;
	if (soap_out_PointerToPointerTobmd230__classInfo(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdGetClassListResponse * SOAP_FMAC4 soap_in_bmd230__bmdGetClassListResponse(struct soap *soap, const char *tag, struct bmd230__bmdGetClassListResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdGetClassListResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdGetClassListResponse, sizeof(struct bmd230__bmdGetClassListResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdGetClassListResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToPointerTobmd230__classInfo(soap, "result", &a->result, "bmd230:classInfo"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdGetClassListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdGetClassListResponse, 0, sizeof(struct bmd230__bmdGetClassListResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdGetClassListResponse(struct soap *soap, const struct bmd230__bmdGetClassListResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdGetClassListResponse);
	if (soap_out_bmd230__bmdGetClassListResponse(soap, tag?tag:"bmd230:bmdGetClassListResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdGetClassListResponse * SOAP_FMAC4 soap_get_bmd230__bmdGetClassListResponse(struct soap *soap, struct bmd230__bmdGetClassListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdGetClassListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdUpdateClass(struct soap *soap, struct bmd230__bmdUpdateClass *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cert = NULL;
	soap_default_string(soap, &a->userRoleId);
	soap_default_string(soap, &a->userGroupId);
	soap_default_string(soap, &a->userClassId);
	soap_default_string(soap, &a->classId);
	a->ClassInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdUpdateClass(struct soap *soap, const struct bmd230__bmdUpdateClass *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__base64Binary(soap, &a->cert);
	soap_serialize_string(soap, &a->userRoleId);
	soap_serialize_string(soap, &a->userGroupId);
	soap_serialize_string(soap, &a->userClassId);
	soap_serialize_string(soap, &a->classId);
	soap_serialize_PointerTobmd230__singleClassInfo(soap, &a->ClassInfo);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdUpdateClass(struct soap *soap, const char *tag, int id, const struct bmd230__bmdUpdateClass *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdUpdateClass), type))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "cert", -1, &a->cert, ""))
		return soap->error;
	if (soap_out_string(soap, "userRoleId", -1, &a->userRoleId, ""))
		return soap->error;
	if (soap_out_string(soap, "userGroupId", -1, &a->userGroupId, ""))
		return soap->error;
	if (soap_out_string(soap, "userClassId", -1, &a->userClassId, ""))
		return soap->error;
	if (soap_out_string(soap, "classId", -1, &a->classId, ""))
		return soap->error;
	if (soap_out_PointerTobmd230__singleClassInfo(soap, "ClassInfo", -1, &a->ClassInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdUpdateClass * SOAP_FMAC4 soap_in_bmd230__bmdUpdateClass(struct soap *soap, const char *tag, struct bmd230__bmdUpdateClass *a, const char *type)
{
	size_t soap_flag_cert = 1;
	size_t soap_flag_userRoleId = 1;
	size_t soap_flag_userGroupId = 1;
	size_t soap_flag_userClassId = 1;
	size_t soap_flag_classId = 1;
	size_t soap_flag_ClassInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdUpdateClass *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdUpdateClass, sizeof(struct bmd230__bmdUpdateClass), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdUpdateClass(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cert && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "cert", &a->cert, "xsd:base64Binary"))
				{	soap_flag_cert--;
					continue;
				}
			if (soap_flag_userRoleId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userRoleId", &a->userRoleId, "xsd:string"))
				{	soap_flag_userRoleId--;
					continue;
				}
			if (soap_flag_userGroupId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userGroupId", &a->userGroupId, "xsd:string"))
				{	soap_flag_userGroupId--;
					continue;
				}
			if (soap_flag_userClassId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userClassId", &a->userClassId, "xsd:string"))
				{	soap_flag_userClassId--;
					continue;
				}
			if (soap_flag_classId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "classId", &a->classId, "xsd:string"))
				{	soap_flag_classId--;
					continue;
				}
			if (soap_flag_ClassInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobmd230__singleClassInfo(soap, "ClassInfo", &a->ClassInfo, "bmd230:singleClassInfo"))
				{	soap_flag_ClassInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdUpdateClass *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdUpdateClass, 0, sizeof(struct bmd230__bmdUpdateClass), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdUpdateClass(struct soap *soap, const struct bmd230__bmdUpdateClass *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdUpdateClass);
	if (soap_out_bmd230__bmdUpdateClass(soap, tag?tag:"bmd230:bmdUpdateClass", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdUpdateClass * SOAP_FMAC4 soap_get_bmd230__bmdUpdateClass(struct soap *soap, struct bmd230__bmdUpdateClass *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdUpdateClass(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdUpdateClassResponse(struct soap *soap, struct bmd230__bmdUpdateClassResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdUpdateClassResponse(struct soap *soap, const struct bmd230__bmdUpdateClassResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdUpdateClassResponse(struct soap *soap, const char *tag, int id, const struct bmd230__bmdUpdateClassResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdUpdateClassResponse), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdUpdateClassResponse * SOAP_FMAC4 soap_in_bmd230__bmdUpdateClassResponse(struct soap *soap, const char *tag, struct bmd230__bmdUpdateClassResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdUpdateClassResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdUpdateClassResponse, sizeof(struct bmd230__bmdUpdateClassResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdUpdateClassResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdUpdateClassResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdUpdateClassResponse, 0, sizeof(struct bmd230__bmdUpdateClassResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdUpdateClassResponse(struct soap *soap, const struct bmd230__bmdUpdateClassResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdUpdateClassResponse);
	if (soap_out_bmd230__bmdUpdateClassResponse(soap, tag?tag:"bmd230:bmdUpdateClassResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdUpdateClassResponse * SOAP_FMAC4 soap_get_bmd230__bmdUpdateClassResponse(struct soap *soap, struct bmd230__bmdUpdateClassResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdUpdateClassResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdRegisterNewClass(struct soap *soap, struct bmd230__bmdRegisterNewClass *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cert = NULL;
	soap_default_string(soap, &a->userRoleId);
	soap_default_string(soap, &a->userGroupId);
	soap_default_string(soap, &a->userClassId);
	a->ClassInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdRegisterNewClass(struct soap *soap, const struct bmd230__bmdRegisterNewClass *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__base64Binary(soap, &a->cert);
	soap_serialize_string(soap, &a->userRoleId);
	soap_serialize_string(soap, &a->userGroupId);
	soap_serialize_string(soap, &a->userClassId);
	soap_serialize_PointerTobmd230__singleClassInfo(soap, &a->ClassInfo);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdRegisterNewClass(struct soap *soap, const char *tag, int id, const struct bmd230__bmdRegisterNewClass *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdRegisterNewClass), type))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "cert", -1, &a->cert, ""))
		return soap->error;
	if (soap_out_string(soap, "userRoleId", -1, &a->userRoleId, ""))
		return soap->error;
	if (soap_out_string(soap, "userGroupId", -1, &a->userGroupId, ""))
		return soap->error;
	if (soap_out_string(soap, "userClassId", -1, &a->userClassId, ""))
		return soap->error;
	if (soap_out_PointerTobmd230__singleClassInfo(soap, "ClassInfo", -1, &a->ClassInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdRegisterNewClass * SOAP_FMAC4 soap_in_bmd230__bmdRegisterNewClass(struct soap *soap, const char *tag, struct bmd230__bmdRegisterNewClass *a, const char *type)
{
	size_t soap_flag_cert = 1;
	size_t soap_flag_userRoleId = 1;
	size_t soap_flag_userGroupId = 1;
	size_t soap_flag_userClassId = 1;
	size_t soap_flag_ClassInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdRegisterNewClass *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdRegisterNewClass, sizeof(struct bmd230__bmdRegisterNewClass), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdRegisterNewClass(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cert && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "cert", &a->cert, "xsd:base64Binary"))
				{	soap_flag_cert--;
					continue;
				}
			if (soap_flag_userRoleId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userRoleId", &a->userRoleId, "xsd:string"))
				{	soap_flag_userRoleId--;
					continue;
				}
			if (soap_flag_userGroupId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userGroupId", &a->userGroupId, "xsd:string"))
				{	soap_flag_userGroupId--;
					continue;
				}
			if (soap_flag_userClassId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userClassId", &a->userClassId, "xsd:string"))
				{	soap_flag_userClassId--;
					continue;
				}
			if (soap_flag_ClassInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobmd230__singleClassInfo(soap, "ClassInfo", &a->ClassInfo, "bmd230:singleClassInfo"))
				{	soap_flag_ClassInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdRegisterNewClass *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdRegisterNewClass, 0, sizeof(struct bmd230__bmdRegisterNewClass), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdRegisterNewClass(struct soap *soap, const struct bmd230__bmdRegisterNewClass *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdRegisterNewClass);
	if (soap_out_bmd230__bmdRegisterNewClass(soap, tag?tag:"bmd230:bmdRegisterNewClass", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdRegisterNewClass * SOAP_FMAC4 soap_get_bmd230__bmdRegisterNewClass(struct soap *soap, struct bmd230__bmdRegisterNewClass *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdRegisterNewClass(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdRegisterNewClassResponse(struct soap *soap, struct bmd230__bmdRegisterNewClassResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdRegisterNewClassResponse(struct soap *soap, const struct bmd230__bmdRegisterNewClassResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdRegisterNewClassResponse(struct soap *soap, const char *tag, int id, const struct bmd230__bmdRegisterNewClassResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdRegisterNewClassResponse), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdRegisterNewClassResponse * SOAP_FMAC4 soap_in_bmd230__bmdRegisterNewClassResponse(struct soap *soap, const char *tag, struct bmd230__bmdRegisterNewClassResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdRegisterNewClassResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdRegisterNewClassResponse, sizeof(struct bmd230__bmdRegisterNewClassResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdRegisterNewClassResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdRegisterNewClassResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdRegisterNewClassResponse, 0, sizeof(struct bmd230__bmdRegisterNewClassResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdRegisterNewClassResponse(struct soap *soap, const struct bmd230__bmdRegisterNewClassResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdRegisterNewClassResponse);
	if (soap_out_bmd230__bmdRegisterNewClassResponse(soap, tag?tag:"bmd230:bmdRegisterNewClassResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdRegisterNewClassResponse * SOAP_FMAC4 soap_get_bmd230__bmdRegisterNewClassResponse(struct soap *soap, struct bmd230__bmdRegisterNewClassResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdRegisterNewClassResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdDeleteGroup(struct soap *soap, struct bmd230__bmdDeleteGroup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cert = NULL;
	soap_default_string(soap, &a->userRoleId);
	soap_default_string(soap, &a->userGroupId);
	soap_default_string(soap, &a->userClassId);
	soap_default_string(soap, &a->groupId);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdDeleteGroup(struct soap *soap, const struct bmd230__bmdDeleteGroup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__base64Binary(soap, &a->cert);
	soap_serialize_string(soap, &a->userRoleId);
	soap_serialize_string(soap, &a->userGroupId);
	soap_serialize_string(soap, &a->userClassId);
	soap_serialize_string(soap, &a->groupId);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdDeleteGroup(struct soap *soap, const char *tag, int id, const struct bmd230__bmdDeleteGroup *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdDeleteGroup), type))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "cert", -1, &a->cert, ""))
		return soap->error;
	if (soap_out_string(soap, "userRoleId", -1, &a->userRoleId, ""))
		return soap->error;
	if (soap_out_string(soap, "userGroupId", -1, &a->userGroupId, ""))
		return soap->error;
	if (soap_out_string(soap, "userClassId", -1, &a->userClassId, ""))
		return soap->error;
	if (soap_out_string(soap, "groupId", -1, &a->groupId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdDeleteGroup * SOAP_FMAC4 soap_in_bmd230__bmdDeleteGroup(struct soap *soap, const char *tag, struct bmd230__bmdDeleteGroup *a, const char *type)
{
	size_t soap_flag_cert = 1;
	size_t soap_flag_userRoleId = 1;
	size_t soap_flag_userGroupId = 1;
	size_t soap_flag_userClassId = 1;
	size_t soap_flag_groupId = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdDeleteGroup *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdDeleteGroup, sizeof(struct bmd230__bmdDeleteGroup), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdDeleteGroup(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cert && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "cert", &a->cert, "xsd:base64Binary"))
				{	soap_flag_cert--;
					continue;
				}
			if (soap_flag_userRoleId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userRoleId", &a->userRoleId, "xsd:string"))
				{	soap_flag_userRoleId--;
					continue;
				}
			if (soap_flag_userGroupId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userGroupId", &a->userGroupId, "xsd:string"))
				{	soap_flag_userGroupId--;
					continue;
				}
			if (soap_flag_userClassId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userClassId", &a->userClassId, "xsd:string"))
				{	soap_flag_userClassId--;
					continue;
				}
			if (soap_flag_groupId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "groupId", &a->groupId, "xsd:string"))
				{	soap_flag_groupId--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdDeleteGroup *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdDeleteGroup, 0, sizeof(struct bmd230__bmdDeleteGroup), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdDeleteGroup(struct soap *soap, const struct bmd230__bmdDeleteGroup *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdDeleteGroup);
	if (soap_out_bmd230__bmdDeleteGroup(soap, tag?tag:"bmd230:bmdDeleteGroup", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdDeleteGroup * SOAP_FMAC4 soap_get_bmd230__bmdDeleteGroup(struct soap *soap, struct bmd230__bmdDeleteGroup *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdDeleteGroup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdDeleteGroupResponse(struct soap *soap, struct bmd230__bmdDeleteGroupResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdDeleteGroupResponse(struct soap *soap, const struct bmd230__bmdDeleteGroupResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdDeleteGroupResponse(struct soap *soap, const char *tag, int id, const struct bmd230__bmdDeleteGroupResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdDeleteGroupResponse), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdDeleteGroupResponse * SOAP_FMAC4 soap_in_bmd230__bmdDeleteGroupResponse(struct soap *soap, const char *tag, struct bmd230__bmdDeleteGroupResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdDeleteGroupResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdDeleteGroupResponse, sizeof(struct bmd230__bmdDeleteGroupResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdDeleteGroupResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdDeleteGroupResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdDeleteGroupResponse, 0, sizeof(struct bmd230__bmdDeleteGroupResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdDeleteGroupResponse(struct soap *soap, const struct bmd230__bmdDeleteGroupResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdDeleteGroupResponse);
	if (soap_out_bmd230__bmdDeleteGroupResponse(soap, tag?tag:"bmd230:bmdDeleteGroupResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdDeleteGroupResponse * SOAP_FMAC4 soap_get_bmd230__bmdDeleteGroupResponse(struct soap *soap, struct bmd230__bmdDeleteGroupResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdDeleteGroupResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdGetGroupsList(struct soap *soap, struct bmd230__bmdGetGroupsList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cert = NULL;
	soap_default_string(soap, &a->userRoleId);
	soap_default_string(soap, &a->userGroupId);
	soap_default_string(soap, &a->userClassId);
	soap_default_string(soap, &a->groupId);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdGetGroupsList(struct soap *soap, const struct bmd230__bmdGetGroupsList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__base64Binary(soap, &a->cert);
	soap_serialize_string(soap, &a->userRoleId);
	soap_serialize_string(soap, &a->userGroupId);
	soap_serialize_string(soap, &a->userClassId);
	soap_serialize_string(soap, &a->groupId);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdGetGroupsList(struct soap *soap, const char *tag, int id, const struct bmd230__bmdGetGroupsList *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdGetGroupsList), type))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "cert", -1, &a->cert, ""))
		return soap->error;
	if (soap_out_string(soap, "userRoleId", -1, &a->userRoleId, ""))
		return soap->error;
	if (soap_out_string(soap, "userGroupId", -1, &a->userGroupId, ""))
		return soap->error;
	if (soap_out_string(soap, "userClassId", -1, &a->userClassId, ""))
		return soap->error;
	if (soap_out_string(soap, "groupId", -1, &a->groupId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdGetGroupsList * SOAP_FMAC4 soap_in_bmd230__bmdGetGroupsList(struct soap *soap, const char *tag, struct bmd230__bmdGetGroupsList *a, const char *type)
{
	size_t soap_flag_cert = 1;
	size_t soap_flag_userRoleId = 1;
	size_t soap_flag_userGroupId = 1;
	size_t soap_flag_userClassId = 1;
	size_t soap_flag_groupId = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdGetGroupsList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdGetGroupsList, sizeof(struct bmd230__bmdGetGroupsList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdGetGroupsList(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cert && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "cert", &a->cert, "xsd:base64Binary"))
				{	soap_flag_cert--;
					continue;
				}
			if (soap_flag_userRoleId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userRoleId", &a->userRoleId, "xsd:string"))
				{	soap_flag_userRoleId--;
					continue;
				}
			if (soap_flag_userGroupId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userGroupId", &a->userGroupId, "xsd:string"))
				{	soap_flag_userGroupId--;
					continue;
				}
			if (soap_flag_userClassId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userClassId", &a->userClassId, "xsd:string"))
				{	soap_flag_userClassId--;
					continue;
				}
			if (soap_flag_groupId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "groupId", &a->groupId, "xsd:string"))
				{	soap_flag_groupId--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdGetGroupsList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdGetGroupsList, 0, sizeof(struct bmd230__bmdGetGroupsList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdGetGroupsList(struct soap *soap, const struct bmd230__bmdGetGroupsList *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdGetGroupsList);
	if (soap_out_bmd230__bmdGetGroupsList(soap, tag?tag:"bmd230:bmdGetGroupsList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdGetGroupsList * SOAP_FMAC4 soap_get_bmd230__bmdGetGroupsList(struct soap *soap, struct bmd230__bmdGetGroupsList *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdGetGroupsList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdGetGroupsListResponse(struct soap *soap, struct bmd230__bmdGetGroupsListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdGetGroupsListResponse(struct soap *soap, const struct bmd230__bmdGetGroupsListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToPointerTobmd230__groupInfo(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdGetGroupsListResponse(struct soap *soap, const char *tag, int id, const struct bmd230__bmdGetGroupsListResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdGetGroupsListResponse), type))
		return soap->error;
	if (soap_out_PointerToPointerTobmd230__groupInfo(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdGetGroupsListResponse * SOAP_FMAC4 soap_in_bmd230__bmdGetGroupsListResponse(struct soap *soap, const char *tag, struct bmd230__bmdGetGroupsListResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdGetGroupsListResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdGetGroupsListResponse, sizeof(struct bmd230__bmdGetGroupsListResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdGetGroupsListResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToPointerTobmd230__groupInfo(soap, "result", &a->result, "bmd230:groupInfo"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdGetGroupsListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdGetGroupsListResponse, 0, sizeof(struct bmd230__bmdGetGroupsListResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdGetGroupsListResponse(struct soap *soap, const struct bmd230__bmdGetGroupsListResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdGetGroupsListResponse);
	if (soap_out_bmd230__bmdGetGroupsListResponse(soap, tag?tag:"bmd230:bmdGetGroupsListResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdGetGroupsListResponse * SOAP_FMAC4 soap_get_bmd230__bmdGetGroupsListResponse(struct soap *soap, struct bmd230__bmdGetGroupsListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdGetGroupsListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdUpdateGroup(struct soap *soap, struct bmd230__bmdUpdateGroup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cert = NULL;
	soap_default_string(soap, &a->userRoleId);
	soap_default_string(soap, &a->userGroupId);
	soap_default_string(soap, &a->userClassId);
	soap_default_string(soap, &a->groupId);
	a->groupInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdUpdateGroup(struct soap *soap, const struct bmd230__bmdUpdateGroup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__base64Binary(soap, &a->cert);
	soap_serialize_string(soap, &a->userRoleId);
	soap_serialize_string(soap, &a->userGroupId);
	soap_serialize_string(soap, &a->userClassId);
	soap_serialize_string(soap, &a->groupId);
	soap_serialize_PointerTobmd230__singleGroupInfo(soap, &a->groupInfo);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdUpdateGroup(struct soap *soap, const char *tag, int id, const struct bmd230__bmdUpdateGroup *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdUpdateGroup), type))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "cert", -1, &a->cert, ""))
		return soap->error;
	if (soap_out_string(soap, "userRoleId", -1, &a->userRoleId, ""))
		return soap->error;
	if (soap_out_string(soap, "userGroupId", -1, &a->userGroupId, ""))
		return soap->error;
	if (soap_out_string(soap, "userClassId", -1, &a->userClassId, ""))
		return soap->error;
	if (soap_out_string(soap, "groupId", -1, &a->groupId, ""))
		return soap->error;
	if (soap_out_PointerTobmd230__singleGroupInfo(soap, "groupInfo", -1, &a->groupInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdUpdateGroup * SOAP_FMAC4 soap_in_bmd230__bmdUpdateGroup(struct soap *soap, const char *tag, struct bmd230__bmdUpdateGroup *a, const char *type)
{
	size_t soap_flag_cert = 1;
	size_t soap_flag_userRoleId = 1;
	size_t soap_flag_userGroupId = 1;
	size_t soap_flag_userClassId = 1;
	size_t soap_flag_groupId = 1;
	size_t soap_flag_groupInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdUpdateGroup *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdUpdateGroup, sizeof(struct bmd230__bmdUpdateGroup), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdUpdateGroup(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cert && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "cert", &a->cert, "xsd:base64Binary"))
				{	soap_flag_cert--;
					continue;
				}
			if (soap_flag_userRoleId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userRoleId", &a->userRoleId, "xsd:string"))
				{	soap_flag_userRoleId--;
					continue;
				}
			if (soap_flag_userGroupId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userGroupId", &a->userGroupId, "xsd:string"))
				{	soap_flag_userGroupId--;
					continue;
				}
			if (soap_flag_userClassId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userClassId", &a->userClassId, "xsd:string"))
				{	soap_flag_userClassId--;
					continue;
				}
			if (soap_flag_groupId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "groupId", &a->groupId, "xsd:string"))
				{	soap_flag_groupId--;
					continue;
				}
			if (soap_flag_groupInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobmd230__singleGroupInfo(soap, "groupInfo", &a->groupInfo, "bmd230:singleGroupInfo"))
				{	soap_flag_groupInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdUpdateGroup *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdUpdateGroup, 0, sizeof(struct bmd230__bmdUpdateGroup), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdUpdateGroup(struct soap *soap, const struct bmd230__bmdUpdateGroup *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdUpdateGroup);
	if (soap_out_bmd230__bmdUpdateGroup(soap, tag?tag:"bmd230:bmdUpdateGroup", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdUpdateGroup * SOAP_FMAC4 soap_get_bmd230__bmdUpdateGroup(struct soap *soap, struct bmd230__bmdUpdateGroup *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdUpdateGroup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdUpdateGroupResponse(struct soap *soap, struct bmd230__bmdUpdateGroupResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdUpdateGroupResponse(struct soap *soap, const struct bmd230__bmdUpdateGroupResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdUpdateGroupResponse(struct soap *soap, const char *tag, int id, const struct bmd230__bmdUpdateGroupResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdUpdateGroupResponse), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdUpdateGroupResponse * SOAP_FMAC4 soap_in_bmd230__bmdUpdateGroupResponse(struct soap *soap, const char *tag, struct bmd230__bmdUpdateGroupResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdUpdateGroupResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdUpdateGroupResponse, sizeof(struct bmd230__bmdUpdateGroupResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdUpdateGroupResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdUpdateGroupResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdUpdateGroupResponse, 0, sizeof(struct bmd230__bmdUpdateGroupResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdUpdateGroupResponse(struct soap *soap, const struct bmd230__bmdUpdateGroupResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdUpdateGroupResponse);
	if (soap_out_bmd230__bmdUpdateGroupResponse(soap, tag?tag:"bmd230:bmdUpdateGroupResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdUpdateGroupResponse * SOAP_FMAC4 soap_get_bmd230__bmdUpdateGroupResponse(struct soap *soap, struct bmd230__bmdUpdateGroupResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdUpdateGroupResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdRegisterNewGroup(struct soap *soap, struct bmd230__bmdRegisterNewGroup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cert = NULL;
	soap_default_string(soap, &a->userRoleId);
	soap_default_string(soap, &a->userGroupId);
	soap_default_string(soap, &a->userClassId);
	a->groupInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdRegisterNewGroup(struct soap *soap, const struct bmd230__bmdRegisterNewGroup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__base64Binary(soap, &a->cert);
	soap_serialize_string(soap, &a->userRoleId);
	soap_serialize_string(soap, &a->userGroupId);
	soap_serialize_string(soap, &a->userClassId);
	soap_serialize_PointerTobmd230__singleGroupInfo(soap, &a->groupInfo);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdRegisterNewGroup(struct soap *soap, const char *tag, int id, const struct bmd230__bmdRegisterNewGroup *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdRegisterNewGroup), type))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "cert", -1, &a->cert, ""))
		return soap->error;
	if (soap_out_string(soap, "userRoleId", -1, &a->userRoleId, ""))
		return soap->error;
	if (soap_out_string(soap, "userGroupId", -1, &a->userGroupId, ""))
		return soap->error;
	if (soap_out_string(soap, "userClassId", -1, &a->userClassId, ""))
		return soap->error;
	if (soap_out_PointerTobmd230__singleGroupInfo(soap, "groupInfo", -1, &a->groupInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdRegisterNewGroup * SOAP_FMAC4 soap_in_bmd230__bmdRegisterNewGroup(struct soap *soap, const char *tag, struct bmd230__bmdRegisterNewGroup *a, const char *type)
{
	size_t soap_flag_cert = 1;
	size_t soap_flag_userRoleId = 1;
	size_t soap_flag_userGroupId = 1;
	size_t soap_flag_userClassId = 1;
	size_t soap_flag_groupInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdRegisterNewGroup *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdRegisterNewGroup, sizeof(struct bmd230__bmdRegisterNewGroup), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdRegisterNewGroup(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cert && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "cert", &a->cert, "xsd:base64Binary"))
				{	soap_flag_cert--;
					continue;
				}
			if (soap_flag_userRoleId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userRoleId", &a->userRoleId, "xsd:string"))
				{	soap_flag_userRoleId--;
					continue;
				}
			if (soap_flag_userGroupId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userGroupId", &a->userGroupId, "xsd:string"))
				{	soap_flag_userGroupId--;
					continue;
				}
			if (soap_flag_userClassId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userClassId", &a->userClassId, "xsd:string"))
				{	soap_flag_userClassId--;
					continue;
				}
			if (soap_flag_groupInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobmd230__singleGroupInfo(soap, "groupInfo", &a->groupInfo, "bmd230:singleGroupInfo"))
				{	soap_flag_groupInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdRegisterNewGroup *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdRegisterNewGroup, 0, sizeof(struct bmd230__bmdRegisterNewGroup), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdRegisterNewGroup(struct soap *soap, const struct bmd230__bmdRegisterNewGroup *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdRegisterNewGroup);
	if (soap_out_bmd230__bmdRegisterNewGroup(soap, tag?tag:"bmd230:bmdRegisterNewGroup", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdRegisterNewGroup * SOAP_FMAC4 soap_get_bmd230__bmdRegisterNewGroup(struct soap *soap, struct bmd230__bmdRegisterNewGroup *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdRegisterNewGroup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdRegisterNewGroupResponse(struct soap *soap, struct bmd230__bmdRegisterNewGroupResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdRegisterNewGroupResponse(struct soap *soap, const struct bmd230__bmdRegisterNewGroupResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdRegisterNewGroupResponse(struct soap *soap, const char *tag, int id, const struct bmd230__bmdRegisterNewGroupResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdRegisterNewGroupResponse), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdRegisterNewGroupResponse * SOAP_FMAC4 soap_in_bmd230__bmdRegisterNewGroupResponse(struct soap *soap, const char *tag, struct bmd230__bmdRegisterNewGroupResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdRegisterNewGroupResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdRegisterNewGroupResponse, sizeof(struct bmd230__bmdRegisterNewGroupResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdRegisterNewGroupResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdRegisterNewGroupResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdRegisterNewGroupResponse, 0, sizeof(struct bmd230__bmdRegisterNewGroupResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdRegisterNewGroupResponse(struct soap *soap, const struct bmd230__bmdRegisterNewGroupResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdRegisterNewGroupResponse);
	if (soap_out_bmd230__bmdRegisterNewGroupResponse(soap, tag?tag:"bmd230:bmdRegisterNewGroupResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdRegisterNewGroupResponse * SOAP_FMAC4 soap_get_bmd230__bmdRegisterNewGroupResponse(struct soap *soap, struct bmd230__bmdRegisterNewGroupResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdRegisterNewGroupResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdDeleteRole(struct soap *soap, struct bmd230__bmdDeleteRole *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cert = NULL;
	soap_default_string(soap, &a->userRoleId);
	soap_default_string(soap, &a->userGroupId);
	soap_default_string(soap, &a->userClassId);
	soap_default_string(soap, &a->roleId);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdDeleteRole(struct soap *soap, const struct bmd230__bmdDeleteRole *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__base64Binary(soap, &a->cert);
	soap_serialize_string(soap, &a->userRoleId);
	soap_serialize_string(soap, &a->userGroupId);
	soap_serialize_string(soap, &a->userClassId);
	soap_serialize_string(soap, &a->roleId);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdDeleteRole(struct soap *soap, const char *tag, int id, const struct bmd230__bmdDeleteRole *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdDeleteRole), type))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "cert", -1, &a->cert, ""))
		return soap->error;
	if (soap_out_string(soap, "userRoleId", -1, &a->userRoleId, ""))
		return soap->error;
	if (soap_out_string(soap, "userGroupId", -1, &a->userGroupId, ""))
		return soap->error;
	if (soap_out_string(soap, "userClassId", -1, &a->userClassId, ""))
		return soap->error;
	if (soap_out_string(soap, "roleId", -1, &a->roleId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdDeleteRole * SOAP_FMAC4 soap_in_bmd230__bmdDeleteRole(struct soap *soap, const char *tag, struct bmd230__bmdDeleteRole *a, const char *type)
{
	size_t soap_flag_cert = 1;
	size_t soap_flag_userRoleId = 1;
	size_t soap_flag_userGroupId = 1;
	size_t soap_flag_userClassId = 1;
	size_t soap_flag_roleId = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdDeleteRole *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdDeleteRole, sizeof(struct bmd230__bmdDeleteRole), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdDeleteRole(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cert && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "cert", &a->cert, "xsd:base64Binary"))
				{	soap_flag_cert--;
					continue;
				}
			if (soap_flag_userRoleId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userRoleId", &a->userRoleId, "xsd:string"))
				{	soap_flag_userRoleId--;
					continue;
				}
			if (soap_flag_userGroupId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userGroupId", &a->userGroupId, "xsd:string"))
				{	soap_flag_userGroupId--;
					continue;
				}
			if (soap_flag_userClassId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userClassId", &a->userClassId, "xsd:string"))
				{	soap_flag_userClassId--;
					continue;
				}
			if (soap_flag_roleId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "roleId", &a->roleId, "xsd:string"))
				{	soap_flag_roleId--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdDeleteRole *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdDeleteRole, 0, sizeof(struct bmd230__bmdDeleteRole), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdDeleteRole(struct soap *soap, const struct bmd230__bmdDeleteRole *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdDeleteRole);
	if (soap_out_bmd230__bmdDeleteRole(soap, tag?tag:"bmd230:bmdDeleteRole", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdDeleteRole * SOAP_FMAC4 soap_get_bmd230__bmdDeleteRole(struct soap *soap, struct bmd230__bmdDeleteRole *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdDeleteRole(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdDeleteRoleResponse(struct soap *soap, struct bmd230__bmdDeleteRoleResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdDeleteRoleResponse(struct soap *soap, const struct bmd230__bmdDeleteRoleResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdDeleteRoleResponse(struct soap *soap, const char *tag, int id, const struct bmd230__bmdDeleteRoleResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdDeleteRoleResponse), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdDeleteRoleResponse * SOAP_FMAC4 soap_in_bmd230__bmdDeleteRoleResponse(struct soap *soap, const char *tag, struct bmd230__bmdDeleteRoleResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdDeleteRoleResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdDeleteRoleResponse, sizeof(struct bmd230__bmdDeleteRoleResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdDeleteRoleResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdDeleteRoleResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdDeleteRoleResponse, 0, sizeof(struct bmd230__bmdDeleteRoleResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdDeleteRoleResponse(struct soap *soap, const struct bmd230__bmdDeleteRoleResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdDeleteRoleResponse);
	if (soap_out_bmd230__bmdDeleteRoleResponse(soap, tag?tag:"bmd230:bmdDeleteRoleResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdDeleteRoleResponse * SOAP_FMAC4 soap_get_bmd230__bmdDeleteRoleResponse(struct soap *soap, struct bmd230__bmdDeleteRoleResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdDeleteRoleResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdGetRolesList(struct soap *soap, struct bmd230__bmdGetRolesList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cert = NULL;
	soap_default_string(soap, &a->userRoleId);
	soap_default_string(soap, &a->userGroupId);
	soap_default_string(soap, &a->userClassId);
	soap_default_string(soap, &a->roleId);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdGetRolesList(struct soap *soap, const struct bmd230__bmdGetRolesList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__base64Binary(soap, &a->cert);
	soap_serialize_string(soap, &a->userRoleId);
	soap_serialize_string(soap, &a->userGroupId);
	soap_serialize_string(soap, &a->userClassId);
	soap_serialize_string(soap, &a->roleId);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdGetRolesList(struct soap *soap, const char *tag, int id, const struct bmd230__bmdGetRolesList *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdGetRolesList), type))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "cert", -1, &a->cert, ""))
		return soap->error;
	if (soap_out_string(soap, "userRoleId", -1, &a->userRoleId, ""))
		return soap->error;
	if (soap_out_string(soap, "userGroupId", -1, &a->userGroupId, ""))
		return soap->error;
	if (soap_out_string(soap, "userClassId", -1, &a->userClassId, ""))
		return soap->error;
	if (soap_out_string(soap, "roleId", -1, &a->roleId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdGetRolesList * SOAP_FMAC4 soap_in_bmd230__bmdGetRolesList(struct soap *soap, const char *tag, struct bmd230__bmdGetRolesList *a, const char *type)
{
	size_t soap_flag_cert = 1;
	size_t soap_flag_userRoleId = 1;
	size_t soap_flag_userGroupId = 1;
	size_t soap_flag_userClassId = 1;
	size_t soap_flag_roleId = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdGetRolesList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdGetRolesList, sizeof(struct bmd230__bmdGetRolesList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdGetRolesList(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cert && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "cert", &a->cert, "xsd:base64Binary"))
				{	soap_flag_cert--;
					continue;
				}
			if (soap_flag_userRoleId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userRoleId", &a->userRoleId, "xsd:string"))
				{	soap_flag_userRoleId--;
					continue;
				}
			if (soap_flag_userGroupId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userGroupId", &a->userGroupId, "xsd:string"))
				{	soap_flag_userGroupId--;
					continue;
				}
			if (soap_flag_userClassId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userClassId", &a->userClassId, "xsd:string"))
				{	soap_flag_userClassId--;
					continue;
				}
			if (soap_flag_roleId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "roleId", &a->roleId, "xsd:string"))
				{	soap_flag_roleId--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdGetRolesList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdGetRolesList, 0, sizeof(struct bmd230__bmdGetRolesList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdGetRolesList(struct soap *soap, const struct bmd230__bmdGetRolesList *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdGetRolesList);
	if (soap_out_bmd230__bmdGetRolesList(soap, tag?tag:"bmd230:bmdGetRolesList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdGetRolesList * SOAP_FMAC4 soap_get_bmd230__bmdGetRolesList(struct soap *soap, struct bmd230__bmdGetRolesList *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdGetRolesList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdGetRolesListResponse(struct soap *soap, struct bmd230__bmdGetRolesListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdGetRolesListResponse(struct soap *soap, const struct bmd230__bmdGetRolesListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToPointerTobmd230__userRoleInfo(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdGetRolesListResponse(struct soap *soap, const char *tag, int id, const struct bmd230__bmdGetRolesListResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdGetRolesListResponse), type))
		return soap->error;
	if (soap_out_PointerToPointerTobmd230__userRoleInfo(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdGetRolesListResponse * SOAP_FMAC4 soap_in_bmd230__bmdGetRolesListResponse(struct soap *soap, const char *tag, struct bmd230__bmdGetRolesListResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdGetRolesListResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdGetRolesListResponse, sizeof(struct bmd230__bmdGetRolesListResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdGetRolesListResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToPointerTobmd230__userRoleInfo(soap, "result", &a->result, "bmd230:userRoleInfo"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdGetRolesListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdGetRolesListResponse, 0, sizeof(struct bmd230__bmdGetRolesListResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdGetRolesListResponse(struct soap *soap, const struct bmd230__bmdGetRolesListResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdGetRolesListResponse);
	if (soap_out_bmd230__bmdGetRolesListResponse(soap, tag?tag:"bmd230:bmdGetRolesListResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdGetRolesListResponse * SOAP_FMAC4 soap_get_bmd230__bmdGetRolesListResponse(struct soap *soap, struct bmd230__bmdGetRolesListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdGetRolesListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdUpdateRole(struct soap *soap, struct bmd230__bmdUpdateRole *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cert = NULL;
	soap_default_string(soap, &a->userRoleId);
	soap_default_string(soap, &a->userGroupId);
	soap_default_string(soap, &a->userClassId);
	soap_default_string(soap, &a->roleId);
	a->roleInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdUpdateRole(struct soap *soap, const struct bmd230__bmdUpdateRole *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__base64Binary(soap, &a->cert);
	soap_serialize_string(soap, &a->userRoleId);
	soap_serialize_string(soap, &a->userGroupId);
	soap_serialize_string(soap, &a->userClassId);
	soap_serialize_string(soap, &a->roleId);
	soap_serialize_PointerTobmd230__singleRoleInfo(soap, &a->roleInfo);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdUpdateRole(struct soap *soap, const char *tag, int id, const struct bmd230__bmdUpdateRole *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdUpdateRole), type))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "cert", -1, &a->cert, ""))
		return soap->error;
	if (soap_out_string(soap, "userRoleId", -1, &a->userRoleId, ""))
		return soap->error;
	if (soap_out_string(soap, "userGroupId", -1, &a->userGroupId, ""))
		return soap->error;
	if (soap_out_string(soap, "userClassId", -1, &a->userClassId, ""))
		return soap->error;
	if (soap_out_string(soap, "roleId", -1, &a->roleId, ""))
		return soap->error;
	if (soap_out_PointerTobmd230__singleRoleInfo(soap, "roleInfo", -1, &a->roleInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdUpdateRole * SOAP_FMAC4 soap_in_bmd230__bmdUpdateRole(struct soap *soap, const char *tag, struct bmd230__bmdUpdateRole *a, const char *type)
{
	size_t soap_flag_cert = 1;
	size_t soap_flag_userRoleId = 1;
	size_t soap_flag_userGroupId = 1;
	size_t soap_flag_userClassId = 1;
	size_t soap_flag_roleId = 1;
	size_t soap_flag_roleInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdUpdateRole *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdUpdateRole, sizeof(struct bmd230__bmdUpdateRole), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdUpdateRole(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cert && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "cert", &a->cert, "xsd:base64Binary"))
				{	soap_flag_cert--;
					continue;
				}
			if (soap_flag_userRoleId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userRoleId", &a->userRoleId, "xsd:string"))
				{	soap_flag_userRoleId--;
					continue;
				}
			if (soap_flag_userGroupId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userGroupId", &a->userGroupId, "xsd:string"))
				{	soap_flag_userGroupId--;
					continue;
				}
			if (soap_flag_userClassId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userClassId", &a->userClassId, "xsd:string"))
				{	soap_flag_userClassId--;
					continue;
				}
			if (soap_flag_roleId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "roleId", &a->roleId, "xsd:string"))
				{	soap_flag_roleId--;
					continue;
				}
			if (soap_flag_roleInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobmd230__singleRoleInfo(soap, "roleInfo", &a->roleInfo, "bmd230:singleRoleInfo"))
				{	soap_flag_roleInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdUpdateRole *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdUpdateRole, 0, sizeof(struct bmd230__bmdUpdateRole), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdUpdateRole(struct soap *soap, const struct bmd230__bmdUpdateRole *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdUpdateRole);
	if (soap_out_bmd230__bmdUpdateRole(soap, tag?tag:"bmd230:bmdUpdateRole", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdUpdateRole * SOAP_FMAC4 soap_get_bmd230__bmdUpdateRole(struct soap *soap, struct bmd230__bmdUpdateRole *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdUpdateRole(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdUpdateRoleResponse(struct soap *soap, struct bmd230__bmdUpdateRoleResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdUpdateRoleResponse(struct soap *soap, const struct bmd230__bmdUpdateRoleResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdUpdateRoleResponse(struct soap *soap, const char *tag, int id, const struct bmd230__bmdUpdateRoleResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdUpdateRoleResponse), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdUpdateRoleResponse * SOAP_FMAC4 soap_in_bmd230__bmdUpdateRoleResponse(struct soap *soap, const char *tag, struct bmd230__bmdUpdateRoleResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdUpdateRoleResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdUpdateRoleResponse, sizeof(struct bmd230__bmdUpdateRoleResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdUpdateRoleResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdUpdateRoleResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdUpdateRoleResponse, 0, sizeof(struct bmd230__bmdUpdateRoleResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdUpdateRoleResponse(struct soap *soap, const struct bmd230__bmdUpdateRoleResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdUpdateRoleResponse);
	if (soap_out_bmd230__bmdUpdateRoleResponse(soap, tag?tag:"bmd230:bmdUpdateRoleResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdUpdateRoleResponse * SOAP_FMAC4 soap_get_bmd230__bmdUpdateRoleResponse(struct soap *soap, struct bmd230__bmdUpdateRoleResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdUpdateRoleResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdRegisterNewRole(struct soap *soap, struct bmd230__bmdRegisterNewRole *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cert = NULL;
	soap_default_string(soap, &a->userRoleId);
	soap_default_string(soap, &a->userGroupId);
	soap_default_string(soap, &a->userClassId);
	a->roleInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdRegisterNewRole(struct soap *soap, const struct bmd230__bmdRegisterNewRole *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__base64Binary(soap, &a->cert);
	soap_serialize_string(soap, &a->userRoleId);
	soap_serialize_string(soap, &a->userGroupId);
	soap_serialize_string(soap, &a->userClassId);
	soap_serialize_PointerTobmd230__singleRoleInfo(soap, &a->roleInfo);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdRegisterNewRole(struct soap *soap, const char *tag, int id, const struct bmd230__bmdRegisterNewRole *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdRegisterNewRole), type))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "cert", -1, &a->cert, ""))
		return soap->error;
	if (soap_out_string(soap, "userRoleId", -1, &a->userRoleId, ""))
		return soap->error;
	if (soap_out_string(soap, "userGroupId", -1, &a->userGroupId, ""))
		return soap->error;
	if (soap_out_string(soap, "userClassId", -1, &a->userClassId, ""))
		return soap->error;
	if (soap_out_PointerTobmd230__singleRoleInfo(soap, "roleInfo", -1, &a->roleInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdRegisterNewRole * SOAP_FMAC4 soap_in_bmd230__bmdRegisterNewRole(struct soap *soap, const char *tag, struct bmd230__bmdRegisterNewRole *a, const char *type)
{
	size_t soap_flag_cert = 1;
	size_t soap_flag_userRoleId = 1;
	size_t soap_flag_userGroupId = 1;
	size_t soap_flag_userClassId = 1;
	size_t soap_flag_roleInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdRegisterNewRole *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdRegisterNewRole, sizeof(struct bmd230__bmdRegisterNewRole), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdRegisterNewRole(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cert && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "cert", &a->cert, "xsd:base64Binary"))
				{	soap_flag_cert--;
					continue;
				}
			if (soap_flag_userRoleId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userRoleId", &a->userRoleId, "xsd:string"))
				{	soap_flag_userRoleId--;
					continue;
				}
			if (soap_flag_userGroupId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userGroupId", &a->userGroupId, "xsd:string"))
				{	soap_flag_userGroupId--;
					continue;
				}
			if (soap_flag_userClassId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userClassId", &a->userClassId, "xsd:string"))
				{	soap_flag_userClassId--;
					continue;
				}
			if (soap_flag_roleInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobmd230__singleRoleInfo(soap, "roleInfo", &a->roleInfo, "bmd230:singleRoleInfo"))
				{	soap_flag_roleInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdRegisterNewRole *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdRegisterNewRole, 0, sizeof(struct bmd230__bmdRegisterNewRole), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdRegisterNewRole(struct soap *soap, const struct bmd230__bmdRegisterNewRole *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdRegisterNewRole);
	if (soap_out_bmd230__bmdRegisterNewRole(soap, tag?tag:"bmd230:bmdRegisterNewRole", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdRegisterNewRole * SOAP_FMAC4 soap_get_bmd230__bmdRegisterNewRole(struct soap *soap, struct bmd230__bmdRegisterNewRole *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdRegisterNewRole(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdRegisterNewRoleResponse(struct soap *soap, struct bmd230__bmdRegisterNewRoleResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdRegisterNewRoleResponse(struct soap *soap, const struct bmd230__bmdRegisterNewRoleResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdRegisterNewRoleResponse(struct soap *soap, const char *tag, int id, const struct bmd230__bmdRegisterNewRoleResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdRegisterNewRoleResponse), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdRegisterNewRoleResponse * SOAP_FMAC4 soap_in_bmd230__bmdRegisterNewRoleResponse(struct soap *soap, const char *tag, struct bmd230__bmdRegisterNewRoleResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdRegisterNewRoleResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdRegisterNewRoleResponse, sizeof(struct bmd230__bmdRegisterNewRoleResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdRegisterNewRoleResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdRegisterNewRoleResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdRegisterNewRoleResponse, 0, sizeof(struct bmd230__bmdRegisterNewRoleResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdRegisterNewRoleResponse(struct soap *soap, const struct bmd230__bmdRegisterNewRoleResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdRegisterNewRoleResponse);
	if (soap_out_bmd230__bmdRegisterNewRoleResponse(soap, tag?tag:"bmd230:bmdRegisterNewRoleResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdRegisterNewRoleResponse * SOAP_FMAC4 soap_get_bmd230__bmdRegisterNewRoleResponse(struct soap *soap, struct bmd230__bmdRegisterNewRoleResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdRegisterNewRoleResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdDisableIdentity(struct soap *soap, struct bmd230__bmdDisableIdentity *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cert = NULL;
	soap_default_string(soap, &a->userRoleId);
	soap_default_string(soap, &a->userGroupId);
	soap_default_string(soap, &a->userClassId);
	soap_default_string(soap, &a->identityId);
	soap_default_int(soap, &a->disable);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdDisableIdentity(struct soap *soap, const struct bmd230__bmdDisableIdentity *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__base64Binary(soap, &a->cert);
	soap_serialize_string(soap, &a->userRoleId);
	soap_serialize_string(soap, &a->userGroupId);
	soap_serialize_string(soap, &a->userClassId);
	soap_serialize_string(soap, &a->identityId);
	soap_embedded(soap, &a->disable, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdDisableIdentity(struct soap *soap, const char *tag, int id, const struct bmd230__bmdDisableIdentity *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdDisableIdentity), type))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "cert", -1, &a->cert, ""))
		return soap->error;
	if (soap_out_string(soap, "userRoleId", -1, &a->userRoleId, ""))
		return soap->error;
	if (soap_out_string(soap, "userGroupId", -1, &a->userGroupId, ""))
		return soap->error;
	if (soap_out_string(soap, "userClassId", -1, &a->userClassId, ""))
		return soap->error;
	if (soap_out_string(soap, "identityId", -1, &a->identityId, ""))
		return soap->error;
	if (soap_out_int(soap, "disable", -1, &a->disable, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdDisableIdentity * SOAP_FMAC4 soap_in_bmd230__bmdDisableIdentity(struct soap *soap, const char *tag, struct bmd230__bmdDisableIdentity *a, const char *type)
{
	size_t soap_flag_cert = 1;
	size_t soap_flag_userRoleId = 1;
	size_t soap_flag_userGroupId = 1;
	size_t soap_flag_userClassId = 1;
	size_t soap_flag_identityId = 1;
	size_t soap_flag_disable = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdDisableIdentity *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdDisableIdentity, sizeof(struct bmd230__bmdDisableIdentity), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdDisableIdentity(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cert && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "cert", &a->cert, "xsd:base64Binary"))
				{	soap_flag_cert--;
					continue;
				}
			if (soap_flag_userRoleId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userRoleId", &a->userRoleId, "xsd:string"))
				{	soap_flag_userRoleId--;
					continue;
				}
			if (soap_flag_userGroupId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userGroupId", &a->userGroupId, "xsd:string"))
				{	soap_flag_userGroupId--;
					continue;
				}
			if (soap_flag_userClassId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userClassId", &a->userClassId, "xsd:string"))
				{	soap_flag_userClassId--;
					continue;
				}
			if (soap_flag_identityId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "identityId", &a->identityId, "xsd:string"))
				{	soap_flag_identityId--;
					continue;
				}
			if (soap_flag_disable && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "disable", &a->disable, "xsd:int"))
				{	soap_flag_disable--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdDisableIdentity *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdDisableIdentity, 0, sizeof(struct bmd230__bmdDisableIdentity), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_disable > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdDisableIdentity(struct soap *soap, const struct bmd230__bmdDisableIdentity *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdDisableIdentity);
	if (soap_out_bmd230__bmdDisableIdentity(soap, tag?tag:"bmd230:bmdDisableIdentity", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdDisableIdentity * SOAP_FMAC4 soap_get_bmd230__bmdDisableIdentity(struct soap *soap, struct bmd230__bmdDisableIdentity *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdDisableIdentity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdDisableIdentityResponse(struct soap *soap, struct bmd230__bmdDisableIdentityResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdDisableIdentityResponse(struct soap *soap, const struct bmd230__bmdDisableIdentityResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdDisableIdentityResponse(struct soap *soap, const char *tag, int id, const struct bmd230__bmdDisableIdentityResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdDisableIdentityResponse), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdDisableIdentityResponse * SOAP_FMAC4 soap_in_bmd230__bmdDisableIdentityResponse(struct soap *soap, const char *tag, struct bmd230__bmdDisableIdentityResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdDisableIdentityResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdDisableIdentityResponse, sizeof(struct bmd230__bmdDisableIdentityResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdDisableIdentityResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdDisableIdentityResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdDisableIdentityResponse, 0, sizeof(struct bmd230__bmdDisableIdentityResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdDisableIdentityResponse(struct soap *soap, const struct bmd230__bmdDisableIdentityResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdDisableIdentityResponse);
	if (soap_out_bmd230__bmdDisableIdentityResponse(soap, tag?tag:"bmd230:bmdDisableIdentityResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdDisableIdentityResponse * SOAP_FMAC4 soap_get_bmd230__bmdDisableIdentityResponse(struct soap *soap, struct bmd230__bmdDisableIdentityResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdDisableIdentityResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdDisableUser(struct soap *soap, struct bmd230__bmdDisableUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cert = NULL;
	soap_default_string(soap, &a->userRoleId);
	soap_default_string(soap, &a->userGroupId);
	soap_default_string(soap, &a->userClassId);
	soap_default_string(soap, &a->userId);
	soap_default_int(soap, &a->enable);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdDisableUser(struct soap *soap, const struct bmd230__bmdDisableUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__base64Binary(soap, &a->cert);
	soap_serialize_string(soap, &a->userRoleId);
	soap_serialize_string(soap, &a->userGroupId);
	soap_serialize_string(soap, &a->userClassId);
	soap_serialize_string(soap, &a->userId);
	soap_embedded(soap, &a->enable, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdDisableUser(struct soap *soap, const char *tag, int id, const struct bmd230__bmdDisableUser *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdDisableUser), type))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "cert", -1, &a->cert, ""))
		return soap->error;
	if (soap_out_string(soap, "userRoleId", -1, &a->userRoleId, ""))
		return soap->error;
	if (soap_out_string(soap, "userGroupId", -1, &a->userGroupId, ""))
		return soap->error;
	if (soap_out_string(soap, "userClassId", -1, &a->userClassId, ""))
		return soap->error;
	if (soap_out_string(soap, "userId", -1, &a->userId, ""))
		return soap->error;
	if (soap_out_int(soap, "enable", -1, &a->enable, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdDisableUser * SOAP_FMAC4 soap_in_bmd230__bmdDisableUser(struct soap *soap, const char *tag, struct bmd230__bmdDisableUser *a, const char *type)
{
	size_t soap_flag_cert = 1;
	size_t soap_flag_userRoleId = 1;
	size_t soap_flag_userGroupId = 1;
	size_t soap_flag_userClassId = 1;
	size_t soap_flag_userId = 1;
	size_t soap_flag_enable = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdDisableUser *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdDisableUser, sizeof(struct bmd230__bmdDisableUser), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdDisableUser(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cert && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "cert", &a->cert, "xsd:base64Binary"))
				{	soap_flag_cert--;
					continue;
				}
			if (soap_flag_userRoleId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userRoleId", &a->userRoleId, "xsd:string"))
				{	soap_flag_userRoleId--;
					continue;
				}
			if (soap_flag_userGroupId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userGroupId", &a->userGroupId, "xsd:string"))
				{	soap_flag_userGroupId--;
					continue;
				}
			if (soap_flag_userClassId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userClassId", &a->userClassId, "xsd:string"))
				{	soap_flag_userClassId--;
					continue;
				}
			if (soap_flag_userId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userId", &a->userId, "xsd:string"))
				{	soap_flag_userId--;
					continue;
				}
			if (soap_flag_enable && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "enable", &a->enable, "xsd:int"))
				{	soap_flag_enable--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdDisableUser *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdDisableUser, 0, sizeof(struct bmd230__bmdDisableUser), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_enable > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdDisableUser(struct soap *soap, const struct bmd230__bmdDisableUser *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdDisableUser);
	if (soap_out_bmd230__bmdDisableUser(soap, tag?tag:"bmd230:bmdDisableUser", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdDisableUser * SOAP_FMAC4 soap_get_bmd230__bmdDisableUser(struct soap *soap, struct bmd230__bmdDisableUser *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdDisableUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdDisableUserResponse(struct soap *soap, struct bmd230__bmdDisableUserResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdDisableUserResponse(struct soap *soap, const struct bmd230__bmdDisableUserResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdDisableUserResponse(struct soap *soap, const char *tag, int id, const struct bmd230__bmdDisableUserResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdDisableUserResponse), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdDisableUserResponse * SOAP_FMAC4 soap_in_bmd230__bmdDisableUserResponse(struct soap *soap, const char *tag, struct bmd230__bmdDisableUserResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdDisableUserResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdDisableUserResponse, sizeof(struct bmd230__bmdDisableUserResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdDisableUserResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdDisableUserResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdDisableUserResponse, 0, sizeof(struct bmd230__bmdDisableUserResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdDisableUserResponse(struct soap *soap, const struct bmd230__bmdDisableUserResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdDisableUserResponse);
	if (soap_out_bmd230__bmdDisableUserResponse(soap, tag?tag:"bmd230:bmdDisableUserResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdDisableUserResponse * SOAP_FMAC4 soap_get_bmd230__bmdDisableUserResponse(struct soap *soap, struct bmd230__bmdDisableUserResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdDisableUserResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdDeleteUser(struct soap *soap, struct bmd230__bmdDeleteUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cert = NULL;
	soap_default_string(soap, &a->userRoleId);
	soap_default_string(soap, &a->userGroupId);
	soap_default_string(soap, &a->userClassId);
	soap_default_string(soap, &a->userId);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdDeleteUser(struct soap *soap, const struct bmd230__bmdDeleteUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__base64Binary(soap, &a->cert);
	soap_serialize_string(soap, &a->userRoleId);
	soap_serialize_string(soap, &a->userGroupId);
	soap_serialize_string(soap, &a->userClassId);
	soap_serialize_string(soap, &a->userId);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdDeleteUser(struct soap *soap, const char *tag, int id, const struct bmd230__bmdDeleteUser *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdDeleteUser), type))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "cert", -1, &a->cert, ""))
		return soap->error;
	if (soap_out_string(soap, "userRoleId", -1, &a->userRoleId, ""))
		return soap->error;
	if (soap_out_string(soap, "userGroupId", -1, &a->userGroupId, ""))
		return soap->error;
	if (soap_out_string(soap, "userClassId", -1, &a->userClassId, ""))
		return soap->error;
	if (soap_out_string(soap, "userId", -1, &a->userId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdDeleteUser * SOAP_FMAC4 soap_in_bmd230__bmdDeleteUser(struct soap *soap, const char *tag, struct bmd230__bmdDeleteUser *a, const char *type)
{
	size_t soap_flag_cert = 1;
	size_t soap_flag_userRoleId = 1;
	size_t soap_flag_userGroupId = 1;
	size_t soap_flag_userClassId = 1;
	size_t soap_flag_userId = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdDeleteUser *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdDeleteUser, sizeof(struct bmd230__bmdDeleteUser), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdDeleteUser(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cert && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "cert", &a->cert, "xsd:base64Binary"))
				{	soap_flag_cert--;
					continue;
				}
			if (soap_flag_userRoleId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userRoleId", &a->userRoleId, "xsd:string"))
				{	soap_flag_userRoleId--;
					continue;
				}
			if (soap_flag_userGroupId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userGroupId", &a->userGroupId, "xsd:string"))
				{	soap_flag_userGroupId--;
					continue;
				}
			if (soap_flag_userClassId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userClassId", &a->userClassId, "xsd:string"))
				{	soap_flag_userClassId--;
					continue;
				}
			if (soap_flag_userId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userId", &a->userId, "xsd:string"))
				{	soap_flag_userId--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdDeleteUser *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdDeleteUser, 0, sizeof(struct bmd230__bmdDeleteUser), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdDeleteUser(struct soap *soap, const struct bmd230__bmdDeleteUser *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdDeleteUser);
	if (soap_out_bmd230__bmdDeleteUser(soap, tag?tag:"bmd230:bmdDeleteUser", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdDeleteUser * SOAP_FMAC4 soap_get_bmd230__bmdDeleteUser(struct soap *soap, struct bmd230__bmdDeleteUser *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdDeleteUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdDeleteUserResponse(struct soap *soap, struct bmd230__bmdDeleteUserResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdDeleteUserResponse(struct soap *soap, const struct bmd230__bmdDeleteUserResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdDeleteUserResponse(struct soap *soap, const char *tag, int id, const struct bmd230__bmdDeleteUserResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdDeleteUserResponse), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdDeleteUserResponse * SOAP_FMAC4 soap_in_bmd230__bmdDeleteUserResponse(struct soap *soap, const char *tag, struct bmd230__bmdDeleteUserResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdDeleteUserResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdDeleteUserResponse, sizeof(struct bmd230__bmdDeleteUserResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdDeleteUserResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdDeleteUserResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdDeleteUserResponse, 0, sizeof(struct bmd230__bmdDeleteUserResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdDeleteUserResponse(struct soap *soap, const struct bmd230__bmdDeleteUserResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdDeleteUserResponse);
	if (soap_out_bmd230__bmdDeleteUserResponse(soap, tag?tag:"bmd230:bmdDeleteUserResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdDeleteUserResponse * SOAP_FMAC4 soap_get_bmd230__bmdDeleteUserResponse(struct soap *soap, struct bmd230__bmdDeleteUserResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdDeleteUserResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdGetUsersList(struct soap *soap, struct bmd230__bmdGetUsersList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cert = NULL;
	soap_default_string(soap, &a->userRoleId);
	soap_default_string(soap, &a->userGroupId);
	soap_default_string(soap, &a->userClassId);
	soap_default_string(soap, &a->userIdentityId);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdGetUsersList(struct soap *soap, const struct bmd230__bmdGetUsersList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__base64Binary(soap, &a->cert);
	soap_serialize_string(soap, &a->userRoleId);
	soap_serialize_string(soap, &a->userGroupId);
	soap_serialize_string(soap, &a->userClassId);
	soap_serialize_string(soap, &a->userIdentityId);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdGetUsersList(struct soap *soap, const char *tag, int id, const struct bmd230__bmdGetUsersList *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdGetUsersList), type))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "cert", -1, &a->cert, ""))
		return soap->error;
	if (soap_out_string(soap, "userRoleId", -1, &a->userRoleId, ""))
		return soap->error;
	if (soap_out_string(soap, "userGroupId", -1, &a->userGroupId, ""))
		return soap->error;
	if (soap_out_string(soap, "userClassId", -1, &a->userClassId, ""))
		return soap->error;
	if (soap_out_string(soap, "userIdentityId", -1, &a->userIdentityId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdGetUsersList * SOAP_FMAC4 soap_in_bmd230__bmdGetUsersList(struct soap *soap, const char *tag, struct bmd230__bmdGetUsersList *a, const char *type)
{
	size_t soap_flag_cert = 1;
	size_t soap_flag_userRoleId = 1;
	size_t soap_flag_userGroupId = 1;
	size_t soap_flag_userClassId = 1;
	size_t soap_flag_userIdentityId = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdGetUsersList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdGetUsersList, sizeof(struct bmd230__bmdGetUsersList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdGetUsersList(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cert && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "cert", &a->cert, "xsd:base64Binary"))
				{	soap_flag_cert--;
					continue;
				}
			if (soap_flag_userRoleId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userRoleId", &a->userRoleId, "xsd:string"))
				{	soap_flag_userRoleId--;
					continue;
				}
			if (soap_flag_userGroupId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userGroupId", &a->userGroupId, "xsd:string"))
				{	soap_flag_userGroupId--;
					continue;
				}
			if (soap_flag_userClassId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userClassId", &a->userClassId, "xsd:string"))
				{	soap_flag_userClassId--;
					continue;
				}
			if (soap_flag_userIdentityId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userIdentityId", &a->userIdentityId, "xsd:string"))
				{	soap_flag_userIdentityId--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdGetUsersList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdGetUsersList, 0, sizeof(struct bmd230__bmdGetUsersList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdGetUsersList(struct soap *soap, const struct bmd230__bmdGetUsersList *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdGetUsersList);
	if (soap_out_bmd230__bmdGetUsersList(soap, tag?tag:"bmd230:bmdGetUsersList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdGetUsersList * SOAP_FMAC4 soap_get_bmd230__bmdGetUsersList(struct soap *soap, struct bmd230__bmdGetUsersList *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdGetUsersList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdGetUsersListResponse(struct soap *soap, struct bmd230__bmdGetUsersListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdGetUsersListResponse(struct soap *soap, const struct bmd230__bmdGetUsersListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToPointerTobmd230__userListInfo(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdGetUsersListResponse(struct soap *soap, const char *tag, int id, const struct bmd230__bmdGetUsersListResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdGetUsersListResponse), type))
		return soap->error;
	if (soap_out_PointerToPointerTobmd230__userListInfo(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdGetUsersListResponse * SOAP_FMAC4 soap_in_bmd230__bmdGetUsersListResponse(struct soap *soap, const char *tag, struct bmd230__bmdGetUsersListResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdGetUsersListResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdGetUsersListResponse, sizeof(struct bmd230__bmdGetUsersListResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdGetUsersListResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToPointerTobmd230__userListInfo(soap, "result", &a->result, "bmd230:userListInfo"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdGetUsersListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdGetUsersListResponse, 0, sizeof(struct bmd230__bmdGetUsersListResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdGetUsersListResponse(struct soap *soap, const struct bmd230__bmdGetUsersListResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdGetUsersListResponse);
	if (soap_out_bmd230__bmdGetUsersListResponse(soap, tag?tag:"bmd230:bmdGetUsersListResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdGetUsersListResponse * SOAP_FMAC4 soap_get_bmd230__bmdGetUsersListResponse(struct soap *soap, struct bmd230__bmdGetUsersListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdGetUsersListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdUpdateUserRights(struct soap *soap, struct bmd230__bmdUpdateUserRights *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cert = NULL;
	soap_default_string(soap, &a->userRoleId);
	soap_default_string(soap, &a->userGroupId);
	soap_default_string(soap, &a->userClassId);
	soap_default_string(soap, &a->userId);
	a->userAttributes = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdUpdateUserRights(struct soap *soap, const struct bmd230__bmdUpdateUserRights *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__base64Binary(soap, &a->cert);
	soap_serialize_string(soap, &a->userRoleId);
	soap_serialize_string(soap, &a->userGroupId);
	soap_serialize_string(soap, &a->userClassId);
	soap_serialize_string(soap, &a->userId);
	soap_serialize_PointerTobmd230__singleUserInfo(soap, &a->userAttributes);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdUpdateUserRights(struct soap *soap, const char *tag, int id, const struct bmd230__bmdUpdateUserRights *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdUpdateUserRights), type))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "cert", -1, &a->cert, ""))
		return soap->error;
	if (soap_out_string(soap, "userRoleId", -1, &a->userRoleId, ""))
		return soap->error;
	if (soap_out_string(soap, "userGroupId", -1, &a->userGroupId, ""))
		return soap->error;
	if (soap_out_string(soap, "userClassId", -1, &a->userClassId, ""))
		return soap->error;
	if (soap_out_string(soap, "userId", -1, &a->userId, ""))
		return soap->error;
	if (soap_out_PointerTobmd230__singleUserInfo(soap, "userAttributes", -1, &a->userAttributes, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdUpdateUserRights * SOAP_FMAC4 soap_in_bmd230__bmdUpdateUserRights(struct soap *soap, const char *tag, struct bmd230__bmdUpdateUserRights *a, const char *type)
{
	size_t soap_flag_cert = 1;
	size_t soap_flag_userRoleId = 1;
	size_t soap_flag_userGroupId = 1;
	size_t soap_flag_userClassId = 1;
	size_t soap_flag_userId = 1;
	size_t soap_flag_userAttributes = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdUpdateUserRights *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdUpdateUserRights, sizeof(struct bmd230__bmdUpdateUserRights), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdUpdateUserRights(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cert && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "cert", &a->cert, "xsd:base64Binary"))
				{	soap_flag_cert--;
					continue;
				}
			if (soap_flag_userRoleId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userRoleId", &a->userRoleId, "xsd:string"))
				{	soap_flag_userRoleId--;
					continue;
				}
			if (soap_flag_userGroupId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userGroupId", &a->userGroupId, "xsd:string"))
				{	soap_flag_userGroupId--;
					continue;
				}
			if (soap_flag_userClassId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userClassId", &a->userClassId, "xsd:string"))
				{	soap_flag_userClassId--;
					continue;
				}
			if (soap_flag_userId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userId", &a->userId, "xsd:string"))
				{	soap_flag_userId--;
					continue;
				}
			if (soap_flag_userAttributes && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobmd230__singleUserInfo(soap, "userAttributes", &a->userAttributes, "bmd230:singleUserInfo"))
				{	soap_flag_userAttributes--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdUpdateUserRights *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdUpdateUserRights, 0, sizeof(struct bmd230__bmdUpdateUserRights), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdUpdateUserRights(struct soap *soap, const struct bmd230__bmdUpdateUserRights *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdUpdateUserRights);
	if (soap_out_bmd230__bmdUpdateUserRights(soap, tag?tag:"bmd230:bmdUpdateUserRights", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdUpdateUserRights * SOAP_FMAC4 soap_get_bmd230__bmdUpdateUserRights(struct soap *soap, struct bmd230__bmdUpdateUserRights *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdUpdateUserRights(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdUpdateUserRightsResponse(struct soap *soap, struct bmd230__bmdUpdateUserRightsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdUpdateUserRightsResponse(struct soap *soap, const struct bmd230__bmdUpdateUserRightsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdUpdateUserRightsResponse(struct soap *soap, const char *tag, int id, const struct bmd230__bmdUpdateUserRightsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdUpdateUserRightsResponse), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdUpdateUserRightsResponse * SOAP_FMAC4 soap_in_bmd230__bmdUpdateUserRightsResponse(struct soap *soap, const char *tag, struct bmd230__bmdUpdateUserRightsResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdUpdateUserRightsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdUpdateUserRightsResponse, sizeof(struct bmd230__bmdUpdateUserRightsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdUpdateUserRightsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdUpdateUserRightsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdUpdateUserRightsResponse, 0, sizeof(struct bmd230__bmdUpdateUserRightsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdUpdateUserRightsResponse(struct soap *soap, const struct bmd230__bmdUpdateUserRightsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdUpdateUserRightsResponse);
	if (soap_out_bmd230__bmdUpdateUserRightsResponse(soap, tag?tag:"bmd230:bmdUpdateUserRightsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdUpdateUserRightsResponse * SOAP_FMAC4 soap_get_bmd230__bmdUpdateUserRightsResponse(struct soap *soap, struct bmd230__bmdUpdateUserRightsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdUpdateUserRightsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdAddCertificateToIdentity(struct soap *soap, struct bmd230__bmdAddCertificateToIdentity *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cert = NULL;
	soap_default_string(soap, &a->userRoleId);
	soap_default_string(soap, &a->userGroupId);
	soap_default_string(soap, &a->userClassId);
	soap_default_string(soap, &a->identityId);
	a->userAttributes = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdAddCertificateToIdentity(struct soap *soap, const struct bmd230__bmdAddCertificateToIdentity *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__base64Binary(soap, &a->cert);
	soap_serialize_string(soap, &a->userRoleId);
	soap_serialize_string(soap, &a->userGroupId);
	soap_serialize_string(soap, &a->userClassId);
	soap_serialize_string(soap, &a->identityId);
	soap_serialize_PointerTobmd230__singleUserInfo(soap, &a->userAttributes);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdAddCertificateToIdentity(struct soap *soap, const char *tag, int id, const struct bmd230__bmdAddCertificateToIdentity *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdAddCertificateToIdentity), type))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "cert", -1, &a->cert, ""))
		return soap->error;
	if (soap_out_string(soap, "userRoleId", -1, &a->userRoleId, ""))
		return soap->error;
	if (soap_out_string(soap, "userGroupId", -1, &a->userGroupId, ""))
		return soap->error;
	if (soap_out_string(soap, "userClassId", -1, &a->userClassId, ""))
		return soap->error;
	if (soap_out_string(soap, "identityId", -1, &a->identityId, ""))
		return soap->error;
	if (soap_out_PointerTobmd230__singleUserInfo(soap, "userAttributes", -1, &a->userAttributes, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdAddCertificateToIdentity * SOAP_FMAC4 soap_in_bmd230__bmdAddCertificateToIdentity(struct soap *soap, const char *tag, struct bmd230__bmdAddCertificateToIdentity *a, const char *type)
{
	size_t soap_flag_cert = 1;
	size_t soap_flag_userRoleId = 1;
	size_t soap_flag_userGroupId = 1;
	size_t soap_flag_userClassId = 1;
	size_t soap_flag_identityId = 1;
	size_t soap_flag_userAttributes = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdAddCertificateToIdentity *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdAddCertificateToIdentity, sizeof(struct bmd230__bmdAddCertificateToIdentity), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdAddCertificateToIdentity(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cert && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "cert", &a->cert, "xsd:base64Binary"))
				{	soap_flag_cert--;
					continue;
				}
			if (soap_flag_userRoleId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userRoleId", &a->userRoleId, "xsd:string"))
				{	soap_flag_userRoleId--;
					continue;
				}
			if (soap_flag_userGroupId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userGroupId", &a->userGroupId, "xsd:string"))
				{	soap_flag_userGroupId--;
					continue;
				}
			if (soap_flag_userClassId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userClassId", &a->userClassId, "xsd:string"))
				{	soap_flag_userClassId--;
					continue;
				}
			if (soap_flag_identityId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "identityId", &a->identityId, "xsd:string"))
				{	soap_flag_identityId--;
					continue;
				}
			if (soap_flag_userAttributes && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobmd230__singleUserInfo(soap, "userAttributes", &a->userAttributes, "bmd230:singleUserInfo"))
				{	soap_flag_userAttributes--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdAddCertificateToIdentity *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdAddCertificateToIdentity, 0, sizeof(struct bmd230__bmdAddCertificateToIdentity), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdAddCertificateToIdentity(struct soap *soap, const struct bmd230__bmdAddCertificateToIdentity *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdAddCertificateToIdentity);
	if (soap_out_bmd230__bmdAddCertificateToIdentity(soap, tag?tag:"bmd230:bmdAddCertificateToIdentity", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdAddCertificateToIdentity * SOAP_FMAC4 soap_get_bmd230__bmdAddCertificateToIdentity(struct soap *soap, struct bmd230__bmdAddCertificateToIdentity *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdAddCertificateToIdentity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdAddCertificateToIdentityResponse(struct soap *soap, struct bmd230__bmdAddCertificateToIdentityResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdAddCertificateToIdentityResponse(struct soap *soap, const struct bmd230__bmdAddCertificateToIdentityResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdAddCertificateToIdentityResponse(struct soap *soap, const char *tag, int id, const struct bmd230__bmdAddCertificateToIdentityResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdAddCertificateToIdentityResponse), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdAddCertificateToIdentityResponse * SOAP_FMAC4 soap_in_bmd230__bmdAddCertificateToIdentityResponse(struct soap *soap, const char *tag, struct bmd230__bmdAddCertificateToIdentityResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdAddCertificateToIdentityResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdAddCertificateToIdentityResponse, sizeof(struct bmd230__bmdAddCertificateToIdentityResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdAddCertificateToIdentityResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdAddCertificateToIdentityResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdAddCertificateToIdentityResponse, 0, sizeof(struct bmd230__bmdAddCertificateToIdentityResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdAddCertificateToIdentityResponse(struct soap *soap, const struct bmd230__bmdAddCertificateToIdentityResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdAddCertificateToIdentityResponse);
	if (soap_out_bmd230__bmdAddCertificateToIdentityResponse(soap, tag?tag:"bmd230:bmdAddCertificateToIdentityResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdAddCertificateToIdentityResponse * SOAP_FMAC4 soap_get_bmd230__bmdAddCertificateToIdentityResponse(struct soap *soap, struct bmd230__bmdAddCertificateToIdentityResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdAddCertificateToIdentityResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdRegisterNewUser(struct soap *soap, struct bmd230__bmdRegisterNewUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cert = NULL;
	soap_default_string(soap, &a->userRoleId);
	soap_default_string(soap, &a->userGroupId);
	soap_default_string(soap, &a->userClassId);
	a->userAttributes = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdRegisterNewUser(struct soap *soap, const struct bmd230__bmdRegisterNewUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__base64Binary(soap, &a->cert);
	soap_serialize_string(soap, &a->userRoleId);
	soap_serialize_string(soap, &a->userGroupId);
	soap_serialize_string(soap, &a->userClassId);
	soap_serialize_PointerTobmd230__singleUserInfo(soap, &a->userAttributes);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdRegisterNewUser(struct soap *soap, const char *tag, int id, const struct bmd230__bmdRegisterNewUser *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdRegisterNewUser), type))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "cert", -1, &a->cert, ""))
		return soap->error;
	if (soap_out_string(soap, "userRoleId", -1, &a->userRoleId, ""))
		return soap->error;
	if (soap_out_string(soap, "userGroupId", -1, &a->userGroupId, ""))
		return soap->error;
	if (soap_out_string(soap, "userClassId", -1, &a->userClassId, ""))
		return soap->error;
	if (soap_out_PointerTobmd230__singleUserInfo(soap, "userAttributes", -1, &a->userAttributes, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdRegisterNewUser * SOAP_FMAC4 soap_in_bmd230__bmdRegisterNewUser(struct soap *soap, const char *tag, struct bmd230__bmdRegisterNewUser *a, const char *type)
{
	size_t soap_flag_cert = 1;
	size_t soap_flag_userRoleId = 1;
	size_t soap_flag_userGroupId = 1;
	size_t soap_flag_userClassId = 1;
	size_t soap_flag_userAttributes = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdRegisterNewUser *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdRegisterNewUser, sizeof(struct bmd230__bmdRegisterNewUser), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdRegisterNewUser(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cert && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "cert", &a->cert, "xsd:base64Binary"))
				{	soap_flag_cert--;
					continue;
				}
			if (soap_flag_userRoleId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userRoleId", &a->userRoleId, "xsd:string"))
				{	soap_flag_userRoleId--;
					continue;
				}
			if (soap_flag_userGroupId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userGroupId", &a->userGroupId, "xsd:string"))
				{	soap_flag_userGroupId--;
					continue;
				}
			if (soap_flag_userClassId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userClassId", &a->userClassId, "xsd:string"))
				{	soap_flag_userClassId--;
					continue;
				}
			if (soap_flag_userAttributes && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobmd230__singleUserInfo(soap, "userAttributes", &a->userAttributes, "bmd230:singleUserInfo"))
				{	soap_flag_userAttributes--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdRegisterNewUser *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdRegisterNewUser, 0, sizeof(struct bmd230__bmdRegisterNewUser), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdRegisterNewUser(struct soap *soap, const struct bmd230__bmdRegisterNewUser *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdRegisterNewUser);
	if (soap_out_bmd230__bmdRegisterNewUser(soap, tag?tag:"bmd230:bmdRegisterNewUser", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdRegisterNewUser * SOAP_FMAC4 soap_get_bmd230__bmdRegisterNewUser(struct soap *soap, struct bmd230__bmdRegisterNewUser *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdRegisterNewUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdRegisterNewUserResponse(struct soap *soap, struct bmd230__bmdRegisterNewUserResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdRegisterNewUserResponse(struct soap *soap, const struct bmd230__bmdRegisterNewUserResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToPointerTobmd230__userRegistrationResult(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdRegisterNewUserResponse(struct soap *soap, const char *tag, int id, const struct bmd230__bmdRegisterNewUserResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdRegisterNewUserResponse), type))
		return soap->error;
	if (soap_out_PointerToPointerTobmd230__userRegistrationResult(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdRegisterNewUserResponse * SOAP_FMAC4 soap_in_bmd230__bmdRegisterNewUserResponse(struct soap *soap, const char *tag, struct bmd230__bmdRegisterNewUserResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdRegisterNewUserResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdRegisterNewUserResponse, sizeof(struct bmd230__bmdRegisterNewUserResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdRegisterNewUserResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToPointerTobmd230__userRegistrationResult(soap, "result", &a->result, "bmd230:userRegistrationResult"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdRegisterNewUserResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdRegisterNewUserResponse, 0, sizeof(struct bmd230__bmdRegisterNewUserResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdRegisterNewUserResponse(struct soap *soap, const struct bmd230__bmdRegisterNewUserResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdRegisterNewUserResponse);
	if (soap_out_bmd230__bmdRegisterNewUserResponse(soap, tag?tag:"bmd230:bmdRegisterNewUserResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdRegisterNewUserResponse * SOAP_FMAC4 soap_get_bmd230__bmdRegisterNewUserResponse(struct soap *soap, struct bmd230__bmdRegisterNewUserResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdRegisterNewUserResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdSearchUnreceived(struct soap *soap, struct bmd230__bmdSearchUnreceived *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cert = NULL;
	soap_default_string(soap, &a->userRoleId);
	soap_default_string(soap, &a->userGroupId);
	soap_default_string(soap, &a->userClassId);
	soap_default_int(soap, &a->offset);
	soap_default_int(soap, &a->limit);
	a->mtds = NULL;
	a->formMtds = NULL;
	a->sortInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdSearchUnreceived(struct soap *soap, const struct bmd230__bmdSearchUnreceived *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__base64Binary(soap, &a->cert);
	soap_serialize_string(soap, &a->userRoleId);
	soap_serialize_string(soap, &a->userGroupId);
	soap_serialize_string(soap, &a->userClassId);
	soap_embedded(soap, &a->offset, SOAP_TYPE_int);
	soap_embedded(soap, &a->limit, SOAP_TYPE_int);
	soap_serialize_PointerTobmd230__mtdsSearchValues(soap, &a->mtds);
	soap_serialize_PointerTobmd230__mtdsValues(soap, &a->formMtds);
	soap_serialize_PointerTobmd230__searchSortInfoList(soap, &a->sortInfo);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdSearchUnreceived(struct soap *soap, const char *tag, int id, const struct bmd230__bmdSearchUnreceived *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdSearchUnreceived), type))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "cert", -1, &a->cert, ""))
		return soap->error;
	if (soap_out_string(soap, "userRoleId", -1, &a->userRoleId, ""))
		return soap->error;
	if (soap_out_string(soap, "userGroupId", -1, &a->userGroupId, ""))
		return soap->error;
	if (soap_out_string(soap, "userClassId", -1, &a->userClassId, ""))
		return soap->error;
	if (soap_out_int(soap, "offset", -1, &a->offset, ""))
		return soap->error;
	if (soap_out_int(soap, "limit", -1, &a->limit, ""))
		return soap->error;
	if (soap_out_PointerTobmd230__mtdsSearchValues(soap, "mtds", -1, &a->mtds, ""))
		return soap->error;
	if (soap_out_PointerTobmd230__mtdsValues(soap, "formMtds", -1, &a->formMtds, ""))
		return soap->error;
	if (soap_out_PointerTobmd230__searchSortInfoList(soap, "sortInfo", -1, &a->sortInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdSearchUnreceived * SOAP_FMAC4 soap_in_bmd230__bmdSearchUnreceived(struct soap *soap, const char *tag, struct bmd230__bmdSearchUnreceived *a, const char *type)
{
	size_t soap_flag_cert = 1;
	size_t soap_flag_userRoleId = 1;
	size_t soap_flag_userGroupId = 1;
	size_t soap_flag_userClassId = 1;
	size_t soap_flag_offset = 1;
	size_t soap_flag_limit = 1;
	size_t soap_flag_mtds = 1;
	size_t soap_flag_formMtds = 1;
	size_t soap_flag_sortInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdSearchUnreceived *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdSearchUnreceived, sizeof(struct bmd230__bmdSearchUnreceived), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdSearchUnreceived(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cert && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "cert", &a->cert, "xsd:base64Binary"))
				{	soap_flag_cert--;
					continue;
				}
			if (soap_flag_userRoleId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userRoleId", &a->userRoleId, "xsd:string"))
				{	soap_flag_userRoleId--;
					continue;
				}
			if (soap_flag_userGroupId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userGroupId", &a->userGroupId, "xsd:string"))
				{	soap_flag_userGroupId--;
					continue;
				}
			if (soap_flag_userClassId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userClassId", &a->userClassId, "xsd:string"))
				{	soap_flag_userClassId--;
					continue;
				}
			if (soap_flag_offset && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "offset", &a->offset, "xsd:int"))
				{	soap_flag_offset--;
					continue;
				}
			if (soap_flag_limit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "limit", &a->limit, "xsd:int"))
				{	soap_flag_limit--;
					continue;
				}
			if (soap_flag_mtds && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobmd230__mtdsSearchValues(soap, "mtds", &a->mtds, "bmd230:mtdsSearchValues"))
				{	soap_flag_mtds--;
					continue;
				}
			if (soap_flag_formMtds && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobmd230__mtdsValues(soap, "formMtds", &a->formMtds, "bmd230:mtdsValues"))
				{	soap_flag_formMtds--;
					continue;
				}
			if (soap_flag_sortInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobmd230__searchSortInfoList(soap, "sortInfo", &a->sortInfo, "bmd230:searchSortInfoList"))
				{	soap_flag_sortInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdSearchUnreceived *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdSearchUnreceived, 0, sizeof(struct bmd230__bmdSearchUnreceived), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_offset > 0 || soap_flag_limit > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdSearchUnreceived(struct soap *soap, const struct bmd230__bmdSearchUnreceived *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdSearchUnreceived);
	if (soap_out_bmd230__bmdSearchUnreceived(soap, tag?tag:"bmd230:bmdSearchUnreceived", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdSearchUnreceived * SOAP_FMAC4 soap_get_bmd230__bmdSearchUnreceived(struct soap *soap, struct bmd230__bmdSearchUnreceived *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdSearchUnreceived(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdSearchUnreceivedResponse(struct soap *soap, struct bmd230__bmdSearchUnreceivedResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->searchResults = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdSearchUnreceivedResponse(struct soap *soap, const struct bmd230__bmdSearchUnreceivedResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToPointerTobmd230__searchResults(soap, &a->searchResults);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdSearchUnreceivedResponse(struct soap *soap, const char *tag, int id, const struct bmd230__bmdSearchUnreceivedResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdSearchUnreceivedResponse), type))
		return soap->error;
	if (soap_out_PointerToPointerTobmd230__searchResults(soap, "searchResults", -1, &a->searchResults, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdSearchUnreceivedResponse * SOAP_FMAC4 soap_in_bmd230__bmdSearchUnreceivedResponse(struct soap *soap, const char *tag, struct bmd230__bmdSearchUnreceivedResponse *a, const char *type)
{
	size_t soap_flag_searchResults = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdSearchUnreceivedResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdSearchUnreceivedResponse, sizeof(struct bmd230__bmdSearchUnreceivedResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdSearchUnreceivedResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_searchResults && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToPointerTobmd230__searchResults(soap, "searchResults", &a->searchResults, "bmd230:searchResults"))
				{	soap_flag_searchResults--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdSearchUnreceivedResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdSearchUnreceivedResponse, 0, sizeof(struct bmd230__bmdSearchUnreceivedResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdSearchUnreceivedResponse(struct soap *soap, const struct bmd230__bmdSearchUnreceivedResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdSearchUnreceivedResponse);
	if (soap_out_bmd230__bmdSearchUnreceivedResponse(soap, tag?tag:"bmd230:bmdSearchUnreceivedResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdSearchUnreceivedResponse * SOAP_FMAC4 soap_get_bmd230__bmdSearchUnreceivedResponse(struct soap *soap, struct bmd230__bmdSearchUnreceivedResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdSearchUnreceivedResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdHistory(struct soap *soap, struct bmd230__bmdHistory *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cert = NULL;
	soap_default_string(soap, &a->userRoleId);
	soap_default_string(soap, &a->userGroupId);
	soap_default_string(soap, &a->userClassId);
	soap_default_long(soap, &a->id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdHistory(struct soap *soap, const struct bmd230__bmdHistory *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__base64Binary(soap, &a->cert);
	soap_serialize_string(soap, &a->userRoleId);
	soap_serialize_string(soap, &a->userGroupId);
	soap_serialize_string(soap, &a->userClassId);
	soap_embedded(soap, &a->id, SOAP_TYPE_long);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdHistory(struct soap *soap, const char *tag, int id, const struct bmd230__bmdHistory *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdHistory), type))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "cert", -1, &a->cert, ""))
		return soap->error;
	if (soap_out_string(soap, "userRoleId", -1, &a->userRoleId, ""))
		return soap->error;
	if (soap_out_string(soap, "userGroupId", -1, &a->userGroupId, ""))
		return soap->error;
	if (soap_out_string(soap, "userClassId", -1, &a->userClassId, ""))
		return soap->error;
	if (soap_out_long(soap, "id", -1, &a->id, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdHistory * SOAP_FMAC4 soap_in_bmd230__bmdHistory(struct soap *soap, const char *tag, struct bmd230__bmdHistory *a, const char *type)
{
	size_t soap_flag_cert = 1;
	size_t soap_flag_userRoleId = 1;
	size_t soap_flag_userGroupId = 1;
	size_t soap_flag_userClassId = 1;
	size_t soap_flag_id = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdHistory *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdHistory, sizeof(struct bmd230__bmdHistory), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdHistory(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cert && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "cert", &a->cert, "xsd:base64Binary"))
				{	soap_flag_cert--;
					continue;
				}
			if (soap_flag_userRoleId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userRoleId", &a->userRoleId, "xsd:string"))
				{	soap_flag_userRoleId--;
					continue;
				}
			if (soap_flag_userGroupId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userGroupId", &a->userGroupId, "xsd:string"))
				{	soap_flag_userGroupId--;
					continue;
				}
			if (soap_flag_userClassId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userClassId", &a->userClassId, "xsd:string"))
				{	soap_flag_userClassId--;
					continue;
				}
			if (soap_flag_id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_long(soap, "id", &a->id, "xsd:long"))
				{	soap_flag_id--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdHistory *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdHistory, 0, sizeof(struct bmd230__bmdHistory), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdHistory(struct soap *soap, const struct bmd230__bmdHistory *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdHistory);
	if (soap_out_bmd230__bmdHistory(soap, tag?tag:"bmd230:bmdHistory", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdHistory * SOAP_FMAC4 soap_get_bmd230__bmdHistory(struct soap *soap, struct bmd230__bmdHistory *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdHistory(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdHistoryResponse(struct soap *soap, struct bmd230__bmdHistoryResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->historyResults = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdHistoryResponse(struct soap *soap, const struct bmd230__bmdHistoryResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToPointerTobmd230__historyResults(soap, &a->historyResults);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdHistoryResponse(struct soap *soap, const char *tag, int id, const struct bmd230__bmdHistoryResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdHistoryResponse), type))
		return soap->error;
	if (soap_out_PointerToPointerTobmd230__historyResults(soap, "historyResults", -1, &a->historyResults, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdHistoryResponse * SOAP_FMAC4 soap_in_bmd230__bmdHistoryResponse(struct soap *soap, const char *tag, struct bmd230__bmdHistoryResponse *a, const char *type)
{
	size_t soap_flag_historyResults = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdHistoryResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdHistoryResponse, sizeof(struct bmd230__bmdHistoryResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdHistoryResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_historyResults && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToPointerTobmd230__historyResults(soap, "historyResults", &a->historyResults, "bmd230:historyResults"))
				{	soap_flag_historyResults--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdHistoryResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdHistoryResponse, 0, sizeof(struct bmd230__bmdHistoryResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdHistoryResponse(struct soap *soap, const struct bmd230__bmdHistoryResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdHistoryResponse);
	if (soap_out_bmd230__bmdHistoryResponse(soap, tag?tag:"bmd230:bmdHistoryResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdHistoryResponse * SOAP_FMAC4 soap_get_bmd230__bmdHistoryResponse(struct soap *soap, struct bmd230__bmdHistoryResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdHistoryResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdAdvancedCountFiles(struct soap *soap, struct bmd230__bmdAdvancedCountFiles *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cert = NULL;
	soap_default_string(soap, &a->userRoleId);
	soap_default_string(soap, &a->userGroupId);
	soap_default_string(soap, &a->userClassId);
	a->mtds = NULL;
	soap_default_string(soap, &a->ownerRange);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdAdvancedCountFiles(struct soap *soap, const struct bmd230__bmdAdvancedCountFiles *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__base64Binary(soap, &a->cert);
	soap_serialize_string(soap, &a->userRoleId);
	soap_serialize_string(soap, &a->userGroupId);
	soap_serialize_string(soap, &a->userClassId);
	soap_serialize_PointerTobmd230__mtdsSearchValues(soap, &a->mtds);
	soap_serialize_string(soap, &a->ownerRange);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdAdvancedCountFiles(struct soap *soap, const char *tag, int id, const struct bmd230__bmdAdvancedCountFiles *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdAdvancedCountFiles), type))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "cert", -1, &a->cert, ""))
		return soap->error;
	if (soap_out_string(soap, "userRoleId", -1, &a->userRoleId, ""))
		return soap->error;
	if (soap_out_string(soap, "userGroupId", -1, &a->userGroupId, ""))
		return soap->error;
	if (soap_out_string(soap, "userClassId", -1, &a->userClassId, ""))
		return soap->error;
	if (soap_out_PointerTobmd230__mtdsSearchValues(soap, "mtds", -1, &a->mtds, ""))
		return soap->error;
	if (soap_out_string(soap, "ownerRange", -1, &a->ownerRange, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdAdvancedCountFiles * SOAP_FMAC4 soap_in_bmd230__bmdAdvancedCountFiles(struct soap *soap, const char *tag, struct bmd230__bmdAdvancedCountFiles *a, const char *type)
{
	size_t soap_flag_cert = 1;
	size_t soap_flag_userRoleId = 1;
	size_t soap_flag_userGroupId = 1;
	size_t soap_flag_userClassId = 1;
	size_t soap_flag_mtds = 1;
	size_t soap_flag_ownerRange = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdAdvancedCountFiles *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdAdvancedCountFiles, sizeof(struct bmd230__bmdAdvancedCountFiles), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdAdvancedCountFiles(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cert && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "cert", &a->cert, "xsd:base64Binary"))
				{	soap_flag_cert--;
					continue;
				}
			if (soap_flag_userRoleId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userRoleId", &a->userRoleId, "xsd:string"))
				{	soap_flag_userRoleId--;
					continue;
				}
			if (soap_flag_userGroupId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userGroupId", &a->userGroupId, "xsd:string"))
				{	soap_flag_userGroupId--;
					continue;
				}
			if (soap_flag_userClassId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userClassId", &a->userClassId, "xsd:string"))
				{	soap_flag_userClassId--;
					continue;
				}
			if (soap_flag_mtds && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobmd230__mtdsSearchValues(soap, "mtds", &a->mtds, "bmd230:mtdsSearchValues"))
				{	soap_flag_mtds--;
					continue;
				}
			if (soap_flag_ownerRange && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ownerRange", &a->ownerRange, "xsd:string"))
				{	soap_flag_ownerRange--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdAdvancedCountFiles *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdAdvancedCountFiles, 0, sizeof(struct bmd230__bmdAdvancedCountFiles), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdAdvancedCountFiles(struct soap *soap, const struct bmd230__bmdAdvancedCountFiles *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdAdvancedCountFiles);
	if (soap_out_bmd230__bmdAdvancedCountFiles(soap, tag?tag:"bmd230:bmdAdvancedCountFiles", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdAdvancedCountFiles * SOAP_FMAC4 soap_get_bmd230__bmdAdvancedCountFiles(struct soap *soap, struct bmd230__bmdAdvancedCountFiles *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdAdvancedCountFiles(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdAdvancedCountFilesResponse(struct soap *soap, struct bmd230__bmdAdvancedCountFilesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdAdvancedCountFilesResponse(struct soap *soap, const struct bmd230__bmdAdvancedCountFilesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTolong(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdAdvancedCountFilesResponse(struct soap *soap, const char *tag, int id, const struct bmd230__bmdAdvancedCountFilesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdAdvancedCountFilesResponse), type))
		return soap->error;
	if (soap_out_PointerTolong(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdAdvancedCountFilesResponse * SOAP_FMAC4 soap_in_bmd230__bmdAdvancedCountFilesResponse(struct soap *soap, const char *tag, struct bmd230__bmdAdvancedCountFilesResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdAdvancedCountFilesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdAdvancedCountFilesResponse, sizeof(struct bmd230__bmdAdvancedCountFilesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdAdvancedCountFilesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTolong(soap, "result", &a->result, "xsd:long"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdAdvancedCountFilesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdAdvancedCountFilesResponse, 0, sizeof(struct bmd230__bmdAdvancedCountFilesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdAdvancedCountFilesResponse(struct soap *soap, const struct bmd230__bmdAdvancedCountFilesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdAdvancedCountFilesResponse);
	if (soap_out_bmd230__bmdAdvancedCountFilesResponse(soap, tag?tag:"bmd230:bmdAdvancedCountFilesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdAdvancedCountFilesResponse * SOAP_FMAC4 soap_get_bmd230__bmdAdvancedCountFilesResponse(struct soap *soap, struct bmd230__bmdAdvancedCountFilesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdAdvancedCountFilesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdAdvancedSearchFiles(struct soap *soap, struct bmd230__bmdAdvancedSearchFiles *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cert = NULL;
	soap_default_string(soap, &a->userRoleId);
	soap_default_string(soap, &a->userGroupId);
	soap_default_string(soap, &a->userClassId);
	a->mtds = NULL;
	a->formMtds = NULL;
	soap_default_int(soap, &a->offset);
	soap_default_int(soap, &a->limit);
	soap_default_string(soap, &a->range);
	soap_default_string(soap, &a->ownerRange);
	a->sortInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdAdvancedSearchFiles(struct soap *soap, const struct bmd230__bmdAdvancedSearchFiles *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__base64Binary(soap, &a->cert);
	soap_serialize_string(soap, &a->userRoleId);
	soap_serialize_string(soap, &a->userGroupId);
	soap_serialize_string(soap, &a->userClassId);
	soap_serialize_PointerTobmd230__mtdsSearchValues(soap, &a->mtds);
	soap_serialize_PointerTobmd230__mtdsValues(soap, &a->formMtds);
	soap_embedded(soap, &a->offset, SOAP_TYPE_int);
	soap_embedded(soap, &a->limit, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->range);
	soap_serialize_string(soap, &a->ownerRange);
	soap_serialize_PointerTobmd230__searchSortInfoList(soap, &a->sortInfo);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdAdvancedSearchFiles(struct soap *soap, const char *tag, int id, const struct bmd230__bmdAdvancedSearchFiles *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdAdvancedSearchFiles), type))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "cert", -1, &a->cert, ""))
		return soap->error;
	if (soap_out_string(soap, "userRoleId", -1, &a->userRoleId, ""))
		return soap->error;
	if (soap_out_string(soap, "userGroupId", -1, &a->userGroupId, ""))
		return soap->error;
	if (soap_out_string(soap, "userClassId", -1, &a->userClassId, ""))
		return soap->error;
	if (soap_out_PointerTobmd230__mtdsSearchValues(soap, "mtds", -1, &a->mtds, ""))
		return soap->error;
	if (soap_out_PointerTobmd230__mtdsValues(soap, "formMtds", -1, &a->formMtds, ""))
		return soap->error;
	if (soap_out_int(soap, "offset", -1, &a->offset, ""))
		return soap->error;
	if (soap_out_int(soap, "limit", -1, &a->limit, ""))
		return soap->error;
	if (soap_out_string(soap, "range", -1, &a->range, ""))
		return soap->error;
	if (soap_out_string(soap, "ownerRange", -1, &a->ownerRange, ""))
		return soap->error;
	if (soap_out_PointerTobmd230__searchSortInfoList(soap, "sortInfo", -1, &a->sortInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdAdvancedSearchFiles * SOAP_FMAC4 soap_in_bmd230__bmdAdvancedSearchFiles(struct soap *soap, const char *tag, struct bmd230__bmdAdvancedSearchFiles *a, const char *type)
{
	size_t soap_flag_cert = 1;
	size_t soap_flag_userRoleId = 1;
	size_t soap_flag_userGroupId = 1;
	size_t soap_flag_userClassId = 1;
	size_t soap_flag_mtds = 1;
	size_t soap_flag_formMtds = 1;
	size_t soap_flag_offset = 1;
	size_t soap_flag_limit = 1;
	size_t soap_flag_range = 1;
	size_t soap_flag_ownerRange = 1;
	size_t soap_flag_sortInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdAdvancedSearchFiles *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdAdvancedSearchFiles, sizeof(struct bmd230__bmdAdvancedSearchFiles), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdAdvancedSearchFiles(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cert && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "cert", &a->cert, "xsd:base64Binary"))
				{	soap_flag_cert--;
					continue;
				}
			if (soap_flag_userRoleId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userRoleId", &a->userRoleId, "xsd:string"))
				{	soap_flag_userRoleId--;
					continue;
				}
			if (soap_flag_userGroupId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userGroupId", &a->userGroupId, "xsd:string"))
				{	soap_flag_userGroupId--;
					continue;
				}
			if (soap_flag_userClassId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userClassId", &a->userClassId, "xsd:string"))
				{	soap_flag_userClassId--;
					continue;
				}
			if (soap_flag_mtds && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobmd230__mtdsSearchValues(soap, "mtds", &a->mtds, "bmd230:mtdsSearchValues"))
				{	soap_flag_mtds--;
					continue;
				}
			if (soap_flag_formMtds && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobmd230__mtdsValues(soap, "formMtds", &a->formMtds, "bmd230:mtdsValues"))
				{	soap_flag_formMtds--;
					continue;
				}
			if (soap_flag_offset && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "offset", &a->offset, "xsd:int"))
				{	soap_flag_offset--;
					continue;
				}
			if (soap_flag_limit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "limit", &a->limit, "xsd:int"))
				{	soap_flag_limit--;
					continue;
				}
			if (soap_flag_range && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "range", &a->range, "xsd:string"))
				{	soap_flag_range--;
					continue;
				}
			if (soap_flag_ownerRange && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ownerRange", &a->ownerRange, "xsd:string"))
				{	soap_flag_ownerRange--;
					continue;
				}
			if (soap_flag_sortInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobmd230__searchSortInfoList(soap, "sortInfo", &a->sortInfo, "bmd230:searchSortInfoList"))
				{	soap_flag_sortInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdAdvancedSearchFiles *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdAdvancedSearchFiles, 0, sizeof(struct bmd230__bmdAdvancedSearchFiles), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_offset > 0 || soap_flag_limit > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdAdvancedSearchFiles(struct soap *soap, const struct bmd230__bmdAdvancedSearchFiles *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdAdvancedSearchFiles);
	if (soap_out_bmd230__bmdAdvancedSearchFiles(soap, tag?tag:"bmd230:bmdAdvancedSearchFiles", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdAdvancedSearchFiles * SOAP_FMAC4 soap_get_bmd230__bmdAdvancedSearchFiles(struct soap *soap, struct bmd230__bmdAdvancedSearchFiles *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdAdvancedSearchFiles(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdAdvancedSearchFilesResponse(struct soap *soap, struct bmd230__bmdAdvancedSearchFilesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->searchResults = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdAdvancedSearchFilesResponse(struct soap *soap, const struct bmd230__bmdAdvancedSearchFilesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToPointerTobmd230__searchResults(soap, &a->searchResults);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdAdvancedSearchFilesResponse(struct soap *soap, const char *tag, int id, const struct bmd230__bmdAdvancedSearchFilesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdAdvancedSearchFilesResponse), type))
		return soap->error;
	if (soap_out_PointerToPointerTobmd230__searchResults(soap, "searchResults", -1, &a->searchResults, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdAdvancedSearchFilesResponse * SOAP_FMAC4 soap_in_bmd230__bmdAdvancedSearchFilesResponse(struct soap *soap, const char *tag, struct bmd230__bmdAdvancedSearchFilesResponse *a, const char *type)
{
	size_t soap_flag_searchResults = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdAdvancedSearchFilesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdAdvancedSearchFilesResponse, sizeof(struct bmd230__bmdAdvancedSearchFilesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdAdvancedSearchFilesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_searchResults && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToPointerTobmd230__searchResults(soap, "searchResults", &a->searchResults, "bmd230:searchResults"))
				{	soap_flag_searchResults--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdAdvancedSearchFilesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdAdvancedSearchFilesResponse, 0, sizeof(struct bmd230__bmdAdvancedSearchFilesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdAdvancedSearchFilesResponse(struct soap *soap, const struct bmd230__bmdAdvancedSearchFilesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdAdvancedSearchFilesResponse);
	if (soap_out_bmd230__bmdAdvancedSearchFilesResponse(soap, tag?tag:"bmd230:bmdAdvancedSearchFilesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdAdvancedSearchFilesResponse * SOAP_FMAC4 soap_get_bmd230__bmdAdvancedSearchFilesResponse(struct soap *soap, struct bmd230__bmdAdvancedSearchFilesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdAdvancedSearchFilesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdSearchFilesCSV(struct soap *soap, struct bmd230__bmdSearchFilesCSV *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cert = NULL;
	soap_default_string(soap, &a->userRoleId);
	soap_default_string(soap, &a->userGroupId);
	soap_default_string(soap, &a->userClassId);
	a->mtds = NULL;
	a->formMtds = NULL;
	soap_default_int(soap, &a->offset);
	soap_default_int(soap, &a->limit);
	soap_default_string(soap, &a->logical);
	soap_default_string(soap, &a->oper);
	soap_default_string(soap, &a->ownerRange);
	a->sortInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdSearchFilesCSV(struct soap *soap, const struct bmd230__bmdSearchFilesCSV *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__base64Binary(soap, &a->cert);
	soap_serialize_string(soap, &a->userRoleId);
	soap_serialize_string(soap, &a->userGroupId);
	soap_serialize_string(soap, &a->userClassId);
	soap_serialize_PointerTobmd230__mtdsValues(soap, &a->mtds);
	soap_serialize_PointerTobmd230__mtdsValues(soap, &a->formMtds);
	soap_embedded(soap, &a->offset, SOAP_TYPE_int);
	soap_embedded(soap, &a->limit, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->logical);
	soap_serialize_string(soap, &a->oper);
	soap_serialize_string(soap, &a->ownerRange);
	soap_serialize_PointerTobmd230__searchSortInfoList(soap, &a->sortInfo);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdSearchFilesCSV(struct soap *soap, const char *tag, int id, const struct bmd230__bmdSearchFilesCSV *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdSearchFilesCSV), type))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "cert", -1, &a->cert, ""))
		return soap->error;
	if (soap_out_string(soap, "userRoleId", -1, &a->userRoleId, ""))
		return soap->error;
	if (soap_out_string(soap, "userGroupId", -1, &a->userGroupId, ""))
		return soap->error;
	if (soap_out_string(soap, "userClassId", -1, &a->userClassId, ""))
		return soap->error;
	if (soap_out_PointerTobmd230__mtdsValues(soap, "mtds", -1, &a->mtds, ""))
		return soap->error;
	if (soap_out_PointerTobmd230__mtdsValues(soap, "formMtds", -1, &a->formMtds, ""))
		return soap->error;
	if (soap_out_int(soap, "offset", -1, &a->offset, ""))
		return soap->error;
	if (soap_out_int(soap, "limit", -1, &a->limit, ""))
		return soap->error;
	if (soap_out_string(soap, "logical", -1, &a->logical, ""))
		return soap->error;
	if (soap_out_string(soap, "oper", -1, &a->oper, ""))
		return soap->error;
	if (soap_out_string(soap, "ownerRange", -1, &a->ownerRange, ""))
		return soap->error;
	if (soap_out_PointerTobmd230__searchSortInfoList(soap, "sortInfo", -1, &a->sortInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdSearchFilesCSV * SOAP_FMAC4 soap_in_bmd230__bmdSearchFilesCSV(struct soap *soap, const char *tag, struct bmd230__bmdSearchFilesCSV *a, const char *type)
{
	size_t soap_flag_cert = 1;
	size_t soap_flag_userRoleId = 1;
	size_t soap_flag_userGroupId = 1;
	size_t soap_flag_userClassId = 1;
	size_t soap_flag_mtds = 1;
	size_t soap_flag_formMtds = 1;
	size_t soap_flag_offset = 1;
	size_t soap_flag_limit = 1;
	size_t soap_flag_logical = 1;
	size_t soap_flag_oper = 1;
	size_t soap_flag_ownerRange = 1;
	size_t soap_flag_sortInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdSearchFilesCSV *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdSearchFilesCSV, sizeof(struct bmd230__bmdSearchFilesCSV), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdSearchFilesCSV(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cert && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "cert", &a->cert, "xsd:base64Binary"))
				{	soap_flag_cert--;
					continue;
				}
			if (soap_flag_userRoleId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userRoleId", &a->userRoleId, "xsd:string"))
				{	soap_flag_userRoleId--;
					continue;
				}
			if (soap_flag_userGroupId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userGroupId", &a->userGroupId, "xsd:string"))
				{	soap_flag_userGroupId--;
					continue;
				}
			if (soap_flag_userClassId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userClassId", &a->userClassId, "xsd:string"))
				{	soap_flag_userClassId--;
					continue;
				}
			if (soap_flag_mtds && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobmd230__mtdsValues(soap, "mtds", &a->mtds, "bmd230:mtdsValues"))
				{	soap_flag_mtds--;
					continue;
				}
			if (soap_flag_formMtds && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobmd230__mtdsValues(soap, "formMtds", &a->formMtds, "bmd230:mtdsValues"))
				{	soap_flag_formMtds--;
					continue;
				}
			if (soap_flag_offset && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "offset", &a->offset, "xsd:int"))
				{	soap_flag_offset--;
					continue;
				}
			if (soap_flag_limit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "limit", &a->limit, "xsd:int"))
				{	soap_flag_limit--;
					continue;
				}
			if (soap_flag_logical && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "logical", &a->logical, "xsd:string"))
				{	soap_flag_logical--;
					continue;
				}
			if (soap_flag_oper && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "oper", &a->oper, "xsd:string"))
				{	soap_flag_oper--;
					continue;
				}
			if (soap_flag_ownerRange && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ownerRange", &a->ownerRange, "xsd:string"))
				{	soap_flag_ownerRange--;
					continue;
				}
			if (soap_flag_sortInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobmd230__searchSortInfoList(soap, "sortInfo", &a->sortInfo, "bmd230:searchSortInfoList"))
				{	soap_flag_sortInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdSearchFilesCSV *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdSearchFilesCSV, 0, sizeof(struct bmd230__bmdSearchFilesCSV), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_offset > 0 || soap_flag_limit > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdSearchFilesCSV(struct soap *soap, const struct bmd230__bmdSearchFilesCSV *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdSearchFilesCSV);
	if (soap_out_bmd230__bmdSearchFilesCSV(soap, tag?tag:"bmd230:bmdSearchFilesCSV", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdSearchFilesCSV * SOAP_FMAC4 soap_get_bmd230__bmdSearchFilesCSV(struct soap *soap, struct bmd230__bmdSearchFilesCSV *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdSearchFilesCSV(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdSearchFilesCSVResponse(struct soap *soap, struct bmd230__bmdSearchFilesCSVResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->output = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdSearchFilesCSVResponse(struct soap *soap, const struct bmd230__bmdSearchFilesCSVResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToPointerTobmd230__fileInfo(soap, &a->output);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdSearchFilesCSVResponse(struct soap *soap, const char *tag, int id, const struct bmd230__bmdSearchFilesCSVResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdSearchFilesCSVResponse), type))
		return soap->error;
	if (soap_out_PointerToPointerTobmd230__fileInfo(soap, "output", -1, &a->output, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdSearchFilesCSVResponse * SOAP_FMAC4 soap_in_bmd230__bmdSearchFilesCSVResponse(struct soap *soap, const char *tag, struct bmd230__bmdSearchFilesCSVResponse *a, const char *type)
{
	size_t soap_flag_output = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdSearchFilesCSVResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdSearchFilesCSVResponse, sizeof(struct bmd230__bmdSearchFilesCSVResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdSearchFilesCSVResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_output && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToPointerTobmd230__fileInfo(soap, "output", &a->output, "bmd230:fileInfo"))
				{	soap_flag_output--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdSearchFilesCSVResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdSearchFilesCSVResponse, 0, sizeof(struct bmd230__bmdSearchFilesCSVResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdSearchFilesCSVResponse(struct soap *soap, const struct bmd230__bmdSearchFilesCSVResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdSearchFilesCSVResponse);
	if (soap_out_bmd230__bmdSearchFilesCSVResponse(soap, tag?tag:"bmd230:bmdSearchFilesCSVResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdSearchFilesCSVResponse * SOAP_FMAC4 soap_get_bmd230__bmdSearchFilesCSVResponse(struct soap *soap, struct bmd230__bmdSearchFilesCSVResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdSearchFilesCSVResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdSearchFiles(struct soap *soap, struct bmd230__bmdSearchFiles *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cert = NULL;
	soap_default_string(soap, &a->userRoleId);
	soap_default_string(soap, &a->userGroupId);
	soap_default_string(soap, &a->userClassId);
	a->mtds = NULL;
	a->formMtds = NULL;
	soap_default_int(soap, &a->offset);
	soap_default_int(soap, &a->limit);
	soap_default_string(soap, &a->logical);
	soap_default_string(soap, &a->oper);
	soap_default_string(soap, &a->range);
	soap_default_string(soap, &a->ownerRange);
	a->sortInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdSearchFiles(struct soap *soap, const struct bmd230__bmdSearchFiles *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__base64Binary(soap, &a->cert);
	soap_serialize_string(soap, &a->userRoleId);
	soap_serialize_string(soap, &a->userGroupId);
	soap_serialize_string(soap, &a->userClassId);
	soap_serialize_PointerTobmd230__mtdsValues(soap, &a->mtds);
	soap_serialize_PointerTobmd230__mtdsValues(soap, &a->formMtds);
	soap_embedded(soap, &a->offset, SOAP_TYPE_int);
	soap_embedded(soap, &a->limit, SOAP_TYPE_int);
	soap_serialize_string(soap, &a->logical);
	soap_serialize_string(soap, &a->oper);
	soap_serialize_string(soap, &a->range);
	soap_serialize_string(soap, &a->ownerRange);
	soap_serialize_PointerTobmd230__searchSortInfoList(soap, &a->sortInfo);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdSearchFiles(struct soap *soap, const char *tag, int id, const struct bmd230__bmdSearchFiles *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdSearchFiles), type))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "cert", -1, &a->cert, ""))
		return soap->error;
	if (soap_out_string(soap, "userRoleId", -1, &a->userRoleId, ""))
		return soap->error;
	if (soap_out_string(soap, "userGroupId", -1, &a->userGroupId, ""))
		return soap->error;
	if (soap_out_string(soap, "userClassId", -1, &a->userClassId, ""))
		return soap->error;
	if (soap_out_PointerTobmd230__mtdsValues(soap, "mtds", -1, &a->mtds, ""))
		return soap->error;
	if (soap_out_PointerTobmd230__mtdsValues(soap, "formMtds", -1, &a->formMtds, ""))
		return soap->error;
	if (soap_out_int(soap, "offset", -1, &a->offset, ""))
		return soap->error;
	if (soap_out_int(soap, "limit", -1, &a->limit, ""))
		return soap->error;
	if (soap_out_string(soap, "logical", -1, &a->logical, ""))
		return soap->error;
	if (soap_out_string(soap, "oper", -1, &a->oper, ""))
		return soap->error;
	if (soap_out_string(soap, "range", -1, &a->range, ""))
		return soap->error;
	if (soap_out_string(soap, "ownerRange", -1, &a->ownerRange, ""))
		return soap->error;
	if (soap_out_PointerTobmd230__searchSortInfoList(soap, "sortInfo", -1, &a->sortInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdSearchFiles * SOAP_FMAC4 soap_in_bmd230__bmdSearchFiles(struct soap *soap, const char *tag, struct bmd230__bmdSearchFiles *a, const char *type)
{
	size_t soap_flag_cert = 1;
	size_t soap_flag_userRoleId = 1;
	size_t soap_flag_userGroupId = 1;
	size_t soap_flag_userClassId = 1;
	size_t soap_flag_mtds = 1;
	size_t soap_flag_formMtds = 1;
	size_t soap_flag_offset = 1;
	size_t soap_flag_limit = 1;
	size_t soap_flag_logical = 1;
	size_t soap_flag_oper = 1;
	size_t soap_flag_range = 1;
	size_t soap_flag_ownerRange = 1;
	size_t soap_flag_sortInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdSearchFiles *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdSearchFiles, sizeof(struct bmd230__bmdSearchFiles), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdSearchFiles(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cert && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "cert", &a->cert, "xsd:base64Binary"))
				{	soap_flag_cert--;
					continue;
				}
			if (soap_flag_userRoleId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userRoleId", &a->userRoleId, "xsd:string"))
				{	soap_flag_userRoleId--;
					continue;
				}
			if (soap_flag_userGroupId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userGroupId", &a->userGroupId, "xsd:string"))
				{	soap_flag_userGroupId--;
					continue;
				}
			if (soap_flag_userClassId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userClassId", &a->userClassId, "xsd:string"))
				{	soap_flag_userClassId--;
					continue;
				}
			if (soap_flag_mtds && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobmd230__mtdsValues(soap, "mtds", &a->mtds, "bmd230:mtdsValues"))
				{	soap_flag_mtds--;
					continue;
				}
			if (soap_flag_formMtds && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobmd230__mtdsValues(soap, "formMtds", &a->formMtds, "bmd230:mtdsValues"))
				{	soap_flag_formMtds--;
					continue;
				}
			if (soap_flag_offset && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "offset", &a->offset, "xsd:int"))
				{	soap_flag_offset--;
					continue;
				}
			if (soap_flag_limit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "limit", &a->limit, "xsd:int"))
				{	soap_flag_limit--;
					continue;
				}
			if (soap_flag_logical && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "logical", &a->logical, "xsd:string"))
				{	soap_flag_logical--;
					continue;
				}
			if (soap_flag_oper && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "oper", &a->oper, "xsd:string"))
				{	soap_flag_oper--;
					continue;
				}
			if (soap_flag_range && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "range", &a->range, "xsd:string"))
				{	soap_flag_range--;
					continue;
				}
			if (soap_flag_ownerRange && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ownerRange", &a->ownerRange, "xsd:string"))
				{	soap_flag_ownerRange--;
					continue;
				}
			if (soap_flag_sortInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobmd230__searchSortInfoList(soap, "sortInfo", &a->sortInfo, "bmd230:searchSortInfoList"))
				{	soap_flag_sortInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdSearchFiles *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdSearchFiles, 0, sizeof(struct bmd230__bmdSearchFiles), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_offset > 0 || soap_flag_limit > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdSearchFiles(struct soap *soap, const struct bmd230__bmdSearchFiles *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdSearchFiles);
	if (soap_out_bmd230__bmdSearchFiles(soap, tag?tag:"bmd230:bmdSearchFiles", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdSearchFiles * SOAP_FMAC4 soap_get_bmd230__bmdSearchFiles(struct soap *soap, struct bmd230__bmdSearchFiles *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdSearchFiles(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdSearchFilesResponse(struct soap *soap, struct bmd230__bmdSearchFilesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->searchResults = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdSearchFilesResponse(struct soap *soap, const struct bmd230__bmdSearchFilesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToPointerTobmd230__searchResults(soap, &a->searchResults);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdSearchFilesResponse(struct soap *soap, const char *tag, int id, const struct bmd230__bmdSearchFilesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdSearchFilesResponse), type))
		return soap->error;
	if (soap_out_PointerToPointerTobmd230__searchResults(soap, "searchResults", -1, &a->searchResults, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdSearchFilesResponse * SOAP_FMAC4 soap_in_bmd230__bmdSearchFilesResponse(struct soap *soap, const char *tag, struct bmd230__bmdSearchFilesResponse *a, const char *type)
{
	size_t soap_flag_searchResults = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdSearchFilesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdSearchFilesResponse, sizeof(struct bmd230__bmdSearchFilesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdSearchFilesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_searchResults && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToPointerTobmd230__searchResults(soap, "searchResults", &a->searchResults, "bmd230:searchResults"))
				{	soap_flag_searchResults--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdSearchFilesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdSearchFilesResponse, 0, sizeof(struct bmd230__bmdSearchFilesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdSearchFilesResponse(struct soap *soap, const struct bmd230__bmdSearchFilesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdSearchFilesResponse);
	if (soap_out_bmd230__bmdSearchFilesResponse(soap, tag?tag:"bmd230:bmdSearchFilesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdSearchFilesResponse * SOAP_FMAC4 soap_get_bmd230__bmdSearchFilesResponse(struct soap *soap, struct bmd230__bmdSearchFilesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdSearchFilesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdLogin(struct soap *soap, struct bmd230__bmdLogin *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cert = NULL;
	soap_default_string(soap, &a->userRoleId);
	soap_default_string(soap, &a->userGroupId);
	soap_default_string(soap, &a->userClassId);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdLogin(struct soap *soap, const struct bmd230__bmdLogin *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__base64Binary(soap, &a->cert);
	soap_serialize_string(soap, &a->userRoleId);
	soap_serialize_string(soap, &a->userGroupId);
	soap_serialize_string(soap, &a->userClassId);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdLogin(struct soap *soap, const char *tag, int id, const struct bmd230__bmdLogin *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdLogin), type))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "cert", -1, &a->cert, ""))
		return soap->error;
	if (soap_out_string(soap, "userRoleId", -1, &a->userRoleId, ""))
		return soap->error;
	if (soap_out_string(soap, "userGroupId", -1, &a->userGroupId, ""))
		return soap->error;
	if (soap_out_string(soap, "userClassId", -1, &a->userClassId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdLogin * SOAP_FMAC4 soap_in_bmd230__bmdLogin(struct soap *soap, const char *tag, struct bmd230__bmdLogin *a, const char *type)
{
	size_t soap_flag_cert = 1;
	size_t soap_flag_userRoleId = 1;
	size_t soap_flag_userGroupId = 1;
	size_t soap_flag_userClassId = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdLogin *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdLogin, sizeof(struct bmd230__bmdLogin), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdLogin(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cert && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "cert", &a->cert, "xsd:base64Binary"))
				{	soap_flag_cert--;
					continue;
				}
			if (soap_flag_userRoleId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userRoleId", &a->userRoleId, "xsd:string"))
				{	soap_flag_userRoleId--;
					continue;
				}
			if (soap_flag_userGroupId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userGroupId", &a->userGroupId, "xsd:string"))
				{	soap_flag_userGroupId--;
					continue;
				}
			if (soap_flag_userClassId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userClassId", &a->userClassId, "xsd:string"))
				{	soap_flag_userClassId--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdLogin *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdLogin, 0, sizeof(struct bmd230__bmdLogin), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdLogin(struct soap *soap, const struct bmd230__bmdLogin *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdLogin);
	if (soap_out_bmd230__bmdLogin(soap, tag?tag:"bmd230:bmdLogin", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdLogin * SOAP_FMAC4 soap_get_bmd230__bmdLogin(struct soap *soap, struct bmd230__bmdLogin *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdLogin(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdLoginResponse(struct soap *soap, struct bmd230__bmdLoginResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->loginResponse = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdLoginResponse(struct soap *soap, const struct bmd230__bmdLoginResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToPointerTobmd230__loginResponse(soap, &a->loginResponse);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdLoginResponse(struct soap *soap, const char *tag, int id, const struct bmd230__bmdLoginResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdLoginResponse), type))
		return soap->error;
	if (soap_out_PointerToPointerTobmd230__loginResponse(soap, "loginResponse", -1, &a->loginResponse, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdLoginResponse * SOAP_FMAC4 soap_in_bmd230__bmdLoginResponse(struct soap *soap, const char *tag, struct bmd230__bmdLoginResponse *a, const char *type)
{
	size_t soap_flag_loginResponse = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdLoginResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdLoginResponse, sizeof(struct bmd230__bmdLoginResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdLoginResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_loginResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToPointerTobmd230__loginResponse(soap, "loginResponse", &a->loginResponse, "bmd230:loginResponse"))
				{	soap_flag_loginResponse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdLoginResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdLoginResponse, 0, sizeof(struct bmd230__bmdLoginResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdLoginResponse(struct soap *soap, const struct bmd230__bmdLoginResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdLoginResponse);
	if (soap_out_bmd230__bmdLoginResponse(soap, tag?tag:"bmd230:bmdLoginResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdLoginResponse * SOAP_FMAC4 soap_get_bmd230__bmdLoginResponse(struct soap *soap, struct bmd230__bmdLoginResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdLoginResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdAddSignature(struct soap *soap, struct bmd230__bmdAddSignature *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cert = NULL;
	soap_default_string(soap, &a->userRoleId);
	soap_default_string(soap, &a->userGroupId);
	soap_default_string(soap, &a->userClassId);
	a->signatureInput = NULL;
	soap_default_long(soap, &a->destFileId);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdAddSignature(struct soap *soap, const struct bmd230__bmdAddSignature *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__base64Binary(soap, &a->cert);
	soap_serialize_string(soap, &a->userRoleId);
	soap_serialize_string(soap, &a->userGroupId);
	soap_serialize_string(soap, &a->userClassId);
	soap_serialize_PointerToxsd__base64Binary(soap, &a->signatureInput);
	soap_embedded(soap, &a->destFileId, SOAP_TYPE_long);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdAddSignature(struct soap *soap, const char *tag, int id, const struct bmd230__bmdAddSignature *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdAddSignature), type))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "cert", -1, &a->cert, ""))
		return soap->error;
	if (soap_out_string(soap, "userRoleId", -1, &a->userRoleId, ""))
		return soap->error;
	if (soap_out_string(soap, "userGroupId", -1, &a->userGroupId, ""))
		return soap->error;
	if (soap_out_string(soap, "userClassId", -1, &a->userClassId, ""))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "signatureInput", -1, &a->signatureInput, ""))
		return soap->error;
	if (soap_out_long(soap, "destFileId", -1, &a->destFileId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdAddSignature * SOAP_FMAC4 soap_in_bmd230__bmdAddSignature(struct soap *soap, const char *tag, struct bmd230__bmdAddSignature *a, const char *type)
{
	size_t soap_flag_cert = 1;
	size_t soap_flag_userRoleId = 1;
	size_t soap_flag_userGroupId = 1;
	size_t soap_flag_userClassId = 1;
	size_t soap_flag_signatureInput = 1;
	size_t soap_flag_destFileId = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdAddSignature *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdAddSignature, sizeof(struct bmd230__bmdAddSignature), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdAddSignature(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cert && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "cert", &a->cert, "xsd:base64Binary"))
				{	soap_flag_cert--;
					continue;
				}
			if (soap_flag_userRoleId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userRoleId", &a->userRoleId, "xsd:string"))
				{	soap_flag_userRoleId--;
					continue;
				}
			if (soap_flag_userGroupId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userGroupId", &a->userGroupId, "xsd:string"))
				{	soap_flag_userGroupId--;
					continue;
				}
			if (soap_flag_userClassId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userClassId", &a->userClassId, "xsd:string"))
				{	soap_flag_userClassId--;
					continue;
				}
			if (soap_flag_signatureInput && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "signatureInput", &a->signatureInput, "xsd:base64Binary"))
				{	soap_flag_signatureInput--;
					continue;
				}
			if (soap_flag_destFileId && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_long(soap, "destFileId", &a->destFileId, "xsd:long"))
				{	soap_flag_destFileId--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdAddSignature *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdAddSignature, 0, sizeof(struct bmd230__bmdAddSignature), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_destFileId > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdAddSignature(struct soap *soap, const struct bmd230__bmdAddSignature *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdAddSignature);
	if (soap_out_bmd230__bmdAddSignature(soap, tag?tag:"bmd230:bmdAddSignature", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdAddSignature * SOAP_FMAC4 soap_get_bmd230__bmdAddSignature(struct soap *soap, struct bmd230__bmdAddSignature *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdAddSignature(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdAddSignatureResponse(struct soap *soap, struct bmd230__bmdAddSignatureResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdAddSignatureResponse(struct soap *soap, const struct bmd230__bmdAddSignatureResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTolong(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdAddSignatureResponse(struct soap *soap, const char *tag, int id, const struct bmd230__bmdAddSignatureResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdAddSignatureResponse), type))
		return soap->error;
	if (soap_out_PointerTolong(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdAddSignatureResponse * SOAP_FMAC4 soap_in_bmd230__bmdAddSignatureResponse(struct soap *soap, const char *tag, struct bmd230__bmdAddSignatureResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdAddSignatureResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdAddSignatureResponse, sizeof(struct bmd230__bmdAddSignatureResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdAddSignatureResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTolong(soap, "result", &a->result, "xsd:long"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdAddSignatureResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdAddSignatureResponse, 0, sizeof(struct bmd230__bmdAddSignatureResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdAddSignatureResponse(struct soap *soap, const struct bmd230__bmdAddSignatureResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdAddSignatureResponse);
	if (soap_out_bmd230__bmdAddSignatureResponse(soap, tag?tag:"bmd230:bmdAddSignatureResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdAddSignatureResponse * SOAP_FMAC4 soap_get_bmd230__bmdAddSignatureResponse(struct soap *soap, struct bmd230__bmdAddSignatureResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdAddSignatureResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdUpdateDefaultMetadataValue(struct soap *soap, struct bmd230__bmdUpdateDefaultMetadataValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cert = NULL;
	soap_default_string(soap, &a->userRoleId);
	soap_default_string(soap, &a->userGroupId);
	soap_default_string(soap, &a->userClassId);
	a->mtds = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdUpdateDefaultMetadataValue(struct soap *soap, const struct bmd230__bmdUpdateDefaultMetadataValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__base64Binary(soap, &a->cert);
	soap_serialize_string(soap, &a->userRoleId);
	soap_serialize_string(soap, &a->userGroupId);
	soap_serialize_string(soap, &a->userClassId);
	soap_serialize_PointerTobmd230__mtdsValues(soap, &a->mtds);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdUpdateDefaultMetadataValue(struct soap *soap, const char *tag, int id, const struct bmd230__bmdUpdateDefaultMetadataValue *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdUpdateDefaultMetadataValue), type))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "cert", -1, &a->cert, ""))
		return soap->error;
	if (soap_out_string(soap, "userRoleId", -1, &a->userRoleId, ""))
		return soap->error;
	if (soap_out_string(soap, "userGroupId", -1, &a->userGroupId, ""))
		return soap->error;
	if (soap_out_string(soap, "userClassId", -1, &a->userClassId, ""))
		return soap->error;
	if (soap_out_PointerTobmd230__mtdsValues(soap, "mtds", -1, &a->mtds, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdUpdateDefaultMetadataValue * SOAP_FMAC4 soap_in_bmd230__bmdUpdateDefaultMetadataValue(struct soap *soap, const char *tag, struct bmd230__bmdUpdateDefaultMetadataValue *a, const char *type)
{
	size_t soap_flag_cert = 1;
	size_t soap_flag_userRoleId = 1;
	size_t soap_flag_userGroupId = 1;
	size_t soap_flag_userClassId = 1;
	size_t soap_flag_mtds = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdUpdateDefaultMetadataValue *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdUpdateDefaultMetadataValue, sizeof(struct bmd230__bmdUpdateDefaultMetadataValue), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdUpdateDefaultMetadataValue(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cert && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "cert", &a->cert, "xsd:base64Binary"))
				{	soap_flag_cert--;
					continue;
				}
			if (soap_flag_userRoleId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userRoleId", &a->userRoleId, "xsd:string"))
				{	soap_flag_userRoleId--;
					continue;
				}
			if (soap_flag_userGroupId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userGroupId", &a->userGroupId, "xsd:string"))
				{	soap_flag_userGroupId--;
					continue;
				}
			if (soap_flag_userClassId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userClassId", &a->userClassId, "xsd:string"))
				{	soap_flag_userClassId--;
					continue;
				}
			if (soap_flag_mtds && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobmd230__mtdsValues(soap, "mtds", &a->mtds, "bmd230:mtdsValues"))
				{	soap_flag_mtds--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdUpdateDefaultMetadataValue *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdUpdateDefaultMetadataValue, 0, sizeof(struct bmd230__bmdUpdateDefaultMetadataValue), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdUpdateDefaultMetadataValue(struct soap *soap, const struct bmd230__bmdUpdateDefaultMetadataValue *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdUpdateDefaultMetadataValue);
	if (soap_out_bmd230__bmdUpdateDefaultMetadataValue(soap, tag?tag:"bmd230:bmdUpdateDefaultMetadataValue", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdUpdateDefaultMetadataValue * SOAP_FMAC4 soap_get_bmd230__bmdUpdateDefaultMetadataValue(struct soap *soap, struct bmd230__bmdUpdateDefaultMetadataValue *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdUpdateDefaultMetadataValue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdUpdateDefaultMetadataValueResponse(struct soap *soap, struct bmd230__bmdUpdateDefaultMetadataValueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdUpdateDefaultMetadataValueResponse(struct soap *soap, const struct bmd230__bmdUpdateDefaultMetadataValueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdUpdateDefaultMetadataValueResponse(struct soap *soap, const char *tag, int id, const struct bmd230__bmdUpdateDefaultMetadataValueResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdUpdateDefaultMetadataValueResponse), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdUpdateDefaultMetadataValueResponse * SOAP_FMAC4 soap_in_bmd230__bmdUpdateDefaultMetadataValueResponse(struct soap *soap, const char *tag, struct bmd230__bmdUpdateDefaultMetadataValueResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdUpdateDefaultMetadataValueResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdUpdateDefaultMetadataValueResponse, sizeof(struct bmd230__bmdUpdateDefaultMetadataValueResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdUpdateDefaultMetadataValueResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdUpdateDefaultMetadataValueResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdUpdateDefaultMetadataValueResponse, 0, sizeof(struct bmd230__bmdUpdateDefaultMetadataValueResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdUpdateDefaultMetadataValueResponse(struct soap *soap, const struct bmd230__bmdUpdateDefaultMetadataValueResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdUpdateDefaultMetadataValueResponse);
	if (soap_out_bmd230__bmdUpdateDefaultMetadataValueResponse(soap, tag?tag:"bmd230:bmdUpdateDefaultMetadataValueResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdUpdateDefaultMetadataValueResponse * SOAP_FMAC4 soap_get_bmd230__bmdUpdateDefaultMetadataValueResponse(struct soap *soap, struct bmd230__bmdUpdateDefaultMetadataValueResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdUpdateDefaultMetadataValueResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdUpdateSystemMetadata(struct soap *soap, struct bmd230__bmdUpdateSystemMetadata *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cert = NULL;
	soap_default_string(soap, &a->userRoleId);
	soap_default_string(soap, &a->userGroupId);
	soap_default_string(soap, &a->userClassId);
	soap_default_long(soap, &a->id);
	a->mtds = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdUpdateSystemMetadata(struct soap *soap, const struct bmd230__bmdUpdateSystemMetadata *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__base64Binary(soap, &a->cert);
	soap_serialize_string(soap, &a->userRoleId);
	soap_serialize_string(soap, &a->userGroupId);
	soap_serialize_string(soap, &a->userClassId);
	soap_embedded(soap, &a->id, SOAP_TYPE_long);
	soap_serialize_PointerTobmd230__mtdsValues(soap, &a->mtds);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdUpdateSystemMetadata(struct soap *soap, const char *tag, int id, const struct bmd230__bmdUpdateSystemMetadata *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdUpdateSystemMetadata), type))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "cert", -1, &a->cert, ""))
		return soap->error;
	if (soap_out_string(soap, "userRoleId", -1, &a->userRoleId, ""))
		return soap->error;
	if (soap_out_string(soap, "userGroupId", -1, &a->userGroupId, ""))
		return soap->error;
	if (soap_out_string(soap, "userClassId", -1, &a->userClassId, ""))
		return soap->error;
	if (soap_out_long(soap, "id", -1, &a->id, ""))
		return soap->error;
	if (soap_out_PointerTobmd230__mtdsValues(soap, "mtds", -1, &a->mtds, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdUpdateSystemMetadata * SOAP_FMAC4 soap_in_bmd230__bmdUpdateSystemMetadata(struct soap *soap, const char *tag, struct bmd230__bmdUpdateSystemMetadata *a, const char *type)
{
	size_t soap_flag_cert = 1;
	size_t soap_flag_userRoleId = 1;
	size_t soap_flag_userGroupId = 1;
	size_t soap_flag_userClassId = 1;
	size_t soap_flag_id = 1;
	size_t soap_flag_mtds = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdUpdateSystemMetadata *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdUpdateSystemMetadata, sizeof(struct bmd230__bmdUpdateSystemMetadata), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdUpdateSystemMetadata(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cert && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "cert", &a->cert, "xsd:base64Binary"))
				{	soap_flag_cert--;
					continue;
				}
			if (soap_flag_userRoleId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userRoleId", &a->userRoleId, "xsd:string"))
				{	soap_flag_userRoleId--;
					continue;
				}
			if (soap_flag_userGroupId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userGroupId", &a->userGroupId, "xsd:string"))
				{	soap_flag_userGroupId--;
					continue;
				}
			if (soap_flag_userClassId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userClassId", &a->userClassId, "xsd:string"))
				{	soap_flag_userClassId--;
					continue;
				}
			if (soap_flag_id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_long(soap, "id", &a->id, "xsd:long"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_mtds && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobmd230__mtdsValues(soap, "mtds", &a->mtds, "bmd230:mtdsValues"))
				{	soap_flag_mtds--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdUpdateSystemMetadata *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdUpdateSystemMetadata, 0, sizeof(struct bmd230__bmdUpdateSystemMetadata), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdUpdateSystemMetadata(struct soap *soap, const struct bmd230__bmdUpdateSystemMetadata *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdUpdateSystemMetadata);
	if (soap_out_bmd230__bmdUpdateSystemMetadata(soap, tag?tag:"bmd230:bmdUpdateSystemMetadata", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdUpdateSystemMetadata * SOAP_FMAC4 soap_get_bmd230__bmdUpdateSystemMetadata(struct soap *soap, struct bmd230__bmdUpdateSystemMetadata *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdUpdateSystemMetadata(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdUpdateSystemMetadataResponse(struct soap *soap, struct bmd230__bmdUpdateSystemMetadataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdUpdateSystemMetadataResponse(struct soap *soap, const struct bmd230__bmdUpdateSystemMetadataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTolong(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdUpdateSystemMetadataResponse(struct soap *soap, const char *tag, int id, const struct bmd230__bmdUpdateSystemMetadataResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdUpdateSystemMetadataResponse), type))
		return soap->error;
	if (soap_out_PointerTolong(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdUpdateSystemMetadataResponse * SOAP_FMAC4 soap_in_bmd230__bmdUpdateSystemMetadataResponse(struct soap *soap, const char *tag, struct bmd230__bmdUpdateSystemMetadataResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdUpdateSystemMetadataResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdUpdateSystemMetadataResponse, sizeof(struct bmd230__bmdUpdateSystemMetadataResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdUpdateSystemMetadataResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTolong(soap, "result", &a->result, "xsd:long"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdUpdateSystemMetadataResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdUpdateSystemMetadataResponse, 0, sizeof(struct bmd230__bmdUpdateSystemMetadataResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdUpdateSystemMetadataResponse(struct soap *soap, const struct bmd230__bmdUpdateSystemMetadataResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdUpdateSystemMetadataResponse);
	if (soap_out_bmd230__bmdUpdateSystemMetadataResponse(soap, tag?tag:"bmd230:bmdUpdateSystemMetadataResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdUpdateSystemMetadataResponse * SOAP_FMAC4 soap_get_bmd230__bmdUpdateSystemMetadataResponse(struct soap *soap, struct bmd230__bmdUpdateSystemMetadataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdUpdateSystemMetadataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdUpdateMetadata(struct soap *soap, struct bmd230__bmdUpdateMetadata *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cert = NULL;
	soap_default_string(soap, &a->userRoleId);
	soap_default_string(soap, &a->userGroupId);
	soap_default_string(soap, &a->userClassId);
	soap_default_long(soap, &a->id);
	a->mtds = NULL;
	soap_default_string(soap, &a->updateReason);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdUpdateMetadata(struct soap *soap, const struct bmd230__bmdUpdateMetadata *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__base64Binary(soap, &a->cert);
	soap_serialize_string(soap, &a->userRoleId);
	soap_serialize_string(soap, &a->userGroupId);
	soap_serialize_string(soap, &a->userClassId);
	soap_embedded(soap, &a->id, SOAP_TYPE_long);
	soap_serialize_PointerTobmd230__mtdsValues(soap, &a->mtds);
	soap_serialize_string(soap, &a->updateReason);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdUpdateMetadata(struct soap *soap, const char *tag, int id, const struct bmd230__bmdUpdateMetadata *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdUpdateMetadata), type))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "cert", -1, &a->cert, ""))
		return soap->error;
	if (soap_out_string(soap, "userRoleId", -1, &a->userRoleId, ""))
		return soap->error;
	if (soap_out_string(soap, "userGroupId", -1, &a->userGroupId, ""))
		return soap->error;
	if (soap_out_string(soap, "userClassId", -1, &a->userClassId, ""))
		return soap->error;
	if (soap_out_long(soap, "id", -1, &a->id, ""))
		return soap->error;
	if (soap_out_PointerTobmd230__mtdsValues(soap, "mtds", -1, &a->mtds, ""))
		return soap->error;
	if (soap_out_string(soap, "updateReason", -1, &a->updateReason, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdUpdateMetadata * SOAP_FMAC4 soap_in_bmd230__bmdUpdateMetadata(struct soap *soap, const char *tag, struct bmd230__bmdUpdateMetadata *a, const char *type)
{
	size_t soap_flag_cert = 1;
	size_t soap_flag_userRoleId = 1;
	size_t soap_flag_userGroupId = 1;
	size_t soap_flag_userClassId = 1;
	size_t soap_flag_id = 1;
	size_t soap_flag_mtds = 1;
	size_t soap_flag_updateReason = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdUpdateMetadata *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdUpdateMetadata, sizeof(struct bmd230__bmdUpdateMetadata), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdUpdateMetadata(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cert && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "cert", &a->cert, "xsd:base64Binary"))
				{	soap_flag_cert--;
					continue;
				}
			if (soap_flag_userRoleId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userRoleId", &a->userRoleId, "xsd:string"))
				{	soap_flag_userRoleId--;
					continue;
				}
			if (soap_flag_userGroupId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userGroupId", &a->userGroupId, "xsd:string"))
				{	soap_flag_userGroupId--;
					continue;
				}
			if (soap_flag_userClassId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userClassId", &a->userClassId, "xsd:string"))
				{	soap_flag_userClassId--;
					continue;
				}
			if (soap_flag_id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_long(soap, "id", &a->id, "xsd:long"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_mtds && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobmd230__mtdsValues(soap, "mtds", &a->mtds, "bmd230:mtdsValues"))
				{	soap_flag_mtds--;
					continue;
				}
			if (soap_flag_updateReason && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "updateReason", &a->updateReason, "xsd:string"))
				{	soap_flag_updateReason--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdUpdateMetadata *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdUpdateMetadata, 0, sizeof(struct bmd230__bmdUpdateMetadata), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdUpdateMetadata(struct soap *soap, const struct bmd230__bmdUpdateMetadata *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdUpdateMetadata);
	if (soap_out_bmd230__bmdUpdateMetadata(soap, tag?tag:"bmd230:bmdUpdateMetadata", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdUpdateMetadata * SOAP_FMAC4 soap_get_bmd230__bmdUpdateMetadata(struct soap *soap, struct bmd230__bmdUpdateMetadata *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdUpdateMetadata(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdUpdateMetadataResponse(struct soap *soap, struct bmd230__bmdUpdateMetadataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdUpdateMetadataResponse(struct soap *soap, const struct bmd230__bmdUpdateMetadataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdUpdateMetadataResponse(struct soap *soap, const char *tag, int id, const struct bmd230__bmdUpdateMetadataResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdUpdateMetadataResponse), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdUpdateMetadataResponse * SOAP_FMAC4 soap_in_bmd230__bmdUpdateMetadataResponse(struct soap *soap, const char *tag, struct bmd230__bmdUpdateMetadataResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdUpdateMetadataResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdUpdateMetadataResponse, sizeof(struct bmd230__bmdUpdateMetadataResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdUpdateMetadataResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdUpdateMetadataResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdUpdateMetadataResponse, 0, sizeof(struct bmd230__bmdUpdateMetadataResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdUpdateMetadataResponse(struct soap *soap, const struct bmd230__bmdUpdateMetadataResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdUpdateMetadataResponse);
	if (soap_out_bmd230__bmdUpdateMetadataResponse(soap, tag?tag:"bmd230:bmdUpdateMetadataResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdUpdateMetadataResponse * SOAP_FMAC4 soap_get_bmd230__bmdUpdateMetadataResponse(struct soap *soap, struct bmd230__bmdUpdateMetadataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdUpdateMetadataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdDeleteDirByID(struct soap *soap, struct bmd230__bmdDeleteDirByID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cert = NULL;
	soap_default_string(soap, &a->userRoleId);
	soap_default_string(soap, &a->userGroupId);
	soap_default_string(soap, &a->userClassId);
	soap_default_long(soap, &a->id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdDeleteDirByID(struct soap *soap, const struct bmd230__bmdDeleteDirByID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__base64Binary(soap, &a->cert);
	soap_serialize_string(soap, &a->userRoleId);
	soap_serialize_string(soap, &a->userGroupId);
	soap_serialize_string(soap, &a->userClassId);
	soap_embedded(soap, &a->id, SOAP_TYPE_long);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdDeleteDirByID(struct soap *soap, const char *tag, int id, const struct bmd230__bmdDeleteDirByID *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdDeleteDirByID), type))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "cert", -1, &a->cert, ""))
		return soap->error;
	if (soap_out_string(soap, "userRoleId", -1, &a->userRoleId, ""))
		return soap->error;
	if (soap_out_string(soap, "userGroupId", -1, &a->userGroupId, ""))
		return soap->error;
	if (soap_out_string(soap, "userClassId", -1, &a->userClassId, ""))
		return soap->error;
	if (soap_out_long(soap, "id", -1, &a->id, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdDeleteDirByID * SOAP_FMAC4 soap_in_bmd230__bmdDeleteDirByID(struct soap *soap, const char *tag, struct bmd230__bmdDeleteDirByID *a, const char *type)
{
	size_t soap_flag_cert = 1;
	size_t soap_flag_userRoleId = 1;
	size_t soap_flag_userGroupId = 1;
	size_t soap_flag_userClassId = 1;
	size_t soap_flag_id = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdDeleteDirByID *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdDeleteDirByID, sizeof(struct bmd230__bmdDeleteDirByID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdDeleteDirByID(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cert && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "cert", &a->cert, "xsd:base64Binary"))
				{	soap_flag_cert--;
					continue;
				}
			if (soap_flag_userRoleId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userRoleId", &a->userRoleId, "xsd:string"))
				{	soap_flag_userRoleId--;
					continue;
				}
			if (soap_flag_userGroupId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userGroupId", &a->userGroupId, "xsd:string"))
				{	soap_flag_userGroupId--;
					continue;
				}
			if (soap_flag_userClassId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userClassId", &a->userClassId, "xsd:string"))
				{	soap_flag_userClassId--;
					continue;
				}
			if (soap_flag_id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_long(soap, "id", &a->id, "xsd:long"))
				{	soap_flag_id--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdDeleteDirByID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdDeleteDirByID, 0, sizeof(struct bmd230__bmdDeleteDirByID), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdDeleteDirByID(struct soap *soap, const struct bmd230__bmdDeleteDirByID *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdDeleteDirByID);
	if (soap_out_bmd230__bmdDeleteDirByID(soap, tag?tag:"bmd230:bmdDeleteDirByID", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdDeleteDirByID * SOAP_FMAC4 soap_get_bmd230__bmdDeleteDirByID(struct soap *soap, struct bmd230__bmdDeleteDirByID *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdDeleteDirByID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdDeleteDirByIDResponse(struct soap *soap, struct bmd230__bmdDeleteDirByIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdDeleteDirByIDResponse(struct soap *soap, const struct bmd230__bmdDeleteDirByIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdDeleteDirByIDResponse(struct soap *soap, const char *tag, int id, const struct bmd230__bmdDeleteDirByIDResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdDeleteDirByIDResponse), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdDeleteDirByIDResponse * SOAP_FMAC4 soap_in_bmd230__bmdDeleteDirByIDResponse(struct soap *soap, const char *tag, struct bmd230__bmdDeleteDirByIDResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdDeleteDirByIDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdDeleteDirByIDResponse, sizeof(struct bmd230__bmdDeleteDirByIDResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdDeleteDirByIDResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdDeleteDirByIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdDeleteDirByIDResponse, 0, sizeof(struct bmd230__bmdDeleteDirByIDResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdDeleteDirByIDResponse(struct soap *soap, const struct bmd230__bmdDeleteDirByIDResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdDeleteDirByIDResponse);
	if (soap_out_bmd230__bmdDeleteDirByIDResponse(soap, tag?tag:"bmd230:bmdDeleteDirByIDResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdDeleteDirByIDResponse * SOAP_FMAC4 soap_get_bmd230__bmdDeleteDirByIDResponse(struct soap *soap, struct bmd230__bmdDeleteDirByIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdDeleteDirByIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdDeleteFileByID(struct soap *soap, struct bmd230__bmdDeleteFileByID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cert = NULL;
	soap_default_string(soap, &a->userRoleId);
	soap_default_string(soap, &a->userGroupId);
	soap_default_string(soap, &a->userClassId);
	soap_default_long(soap, &a->id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdDeleteFileByID(struct soap *soap, const struct bmd230__bmdDeleteFileByID *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__base64Binary(soap, &a->cert);
	soap_serialize_string(soap, &a->userRoleId);
	soap_serialize_string(soap, &a->userGroupId);
	soap_serialize_string(soap, &a->userClassId);
	soap_embedded(soap, &a->id, SOAP_TYPE_long);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdDeleteFileByID(struct soap *soap, const char *tag, int id, const struct bmd230__bmdDeleteFileByID *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdDeleteFileByID), type))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "cert", -1, &a->cert, ""))
		return soap->error;
	if (soap_out_string(soap, "userRoleId", -1, &a->userRoleId, ""))
		return soap->error;
	if (soap_out_string(soap, "userGroupId", -1, &a->userGroupId, ""))
		return soap->error;
	if (soap_out_string(soap, "userClassId", -1, &a->userClassId, ""))
		return soap->error;
	if (soap_out_long(soap, "id", -1, &a->id, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdDeleteFileByID * SOAP_FMAC4 soap_in_bmd230__bmdDeleteFileByID(struct soap *soap, const char *tag, struct bmd230__bmdDeleteFileByID *a, const char *type)
{
	size_t soap_flag_cert = 1;
	size_t soap_flag_userRoleId = 1;
	size_t soap_flag_userGroupId = 1;
	size_t soap_flag_userClassId = 1;
	size_t soap_flag_id = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdDeleteFileByID *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdDeleteFileByID, sizeof(struct bmd230__bmdDeleteFileByID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdDeleteFileByID(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cert && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "cert", &a->cert, "xsd:base64Binary"))
				{	soap_flag_cert--;
					continue;
				}
			if (soap_flag_userRoleId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userRoleId", &a->userRoleId, "xsd:string"))
				{	soap_flag_userRoleId--;
					continue;
				}
			if (soap_flag_userGroupId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userGroupId", &a->userGroupId, "xsd:string"))
				{	soap_flag_userGroupId--;
					continue;
				}
			if (soap_flag_userClassId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userClassId", &a->userClassId, "xsd:string"))
				{	soap_flag_userClassId--;
					continue;
				}
			if (soap_flag_id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_long(soap, "id", &a->id, "xsd:long"))
				{	soap_flag_id--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdDeleteFileByID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdDeleteFileByID, 0, sizeof(struct bmd230__bmdDeleteFileByID), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdDeleteFileByID(struct soap *soap, const struct bmd230__bmdDeleteFileByID *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdDeleteFileByID);
	if (soap_out_bmd230__bmdDeleteFileByID(soap, tag?tag:"bmd230:bmdDeleteFileByID", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdDeleteFileByID * SOAP_FMAC4 soap_get_bmd230__bmdDeleteFileByID(struct soap *soap, struct bmd230__bmdDeleteFileByID *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdDeleteFileByID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdDeleteFileByIDResponse(struct soap *soap, struct bmd230__bmdDeleteFileByIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdDeleteFileByIDResponse(struct soap *soap, const struct bmd230__bmdDeleteFileByIDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdDeleteFileByIDResponse(struct soap *soap, const char *tag, int id, const struct bmd230__bmdDeleteFileByIDResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdDeleteFileByIDResponse), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdDeleteFileByIDResponse * SOAP_FMAC4 soap_in_bmd230__bmdDeleteFileByIDResponse(struct soap *soap, const char *tag, struct bmd230__bmdDeleteFileByIDResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdDeleteFileByIDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdDeleteFileByIDResponse, sizeof(struct bmd230__bmdDeleteFileByIDResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdDeleteFileByIDResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdDeleteFileByIDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdDeleteFileByIDResponse, 0, sizeof(struct bmd230__bmdDeleteFileByIDResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdDeleteFileByIDResponse(struct soap *soap, const struct bmd230__bmdDeleteFileByIDResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdDeleteFileByIDResponse);
	if (soap_out_bmd230__bmdDeleteFileByIDResponse(soap, tag?tag:"bmd230:bmdDeleteFileByIDResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdDeleteFileByIDResponse * SOAP_FMAC4 soap_get_bmd230__bmdDeleteFileByIDResponse(struct soap *soap, struct bmd230__bmdDeleteFileByIDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdDeleteFileByIDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdUpdateFileVersion(struct soap *soap, struct bmd230__bmdUpdateFileVersion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cert = NULL;
	soap_default_string(soap, &a->userRoleId);
	soap_default_string(soap, &a->userGroupId);
	soap_default_string(soap, &a->userClassId);
	soap_default_string(soap, &a->fileId);
	a->input = NULL;
	soap_default_trans_t(soap, &a->type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdUpdateFileVersion(struct soap *soap, const struct bmd230__bmdUpdateFileVersion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__base64Binary(soap, &a->cert);
	soap_serialize_string(soap, &a->userRoleId);
	soap_serialize_string(soap, &a->userGroupId);
	soap_serialize_string(soap, &a->userClassId);
	soap_serialize_string(soap, &a->fileId);
	soap_serialize_PointerTobmd230__fileInfo(soap, &a->input);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdUpdateFileVersion(struct soap *soap, const char *tag, int id, const struct bmd230__bmdUpdateFileVersion *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdUpdateFileVersion), type))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "cert", -1, &a->cert, ""))
		return soap->error;
	if (soap_out_string(soap, "userRoleId", -1, &a->userRoleId, ""))
		return soap->error;
	if (soap_out_string(soap, "userGroupId", -1, &a->userGroupId, ""))
		return soap->error;
	if (soap_out_string(soap, "userClassId", -1, &a->userClassId, ""))
		return soap->error;
	if (soap_out_string(soap, "fileId", -1, &a->fileId, ""))
		return soap->error;
	if (soap_out_PointerTobmd230__fileInfo(soap, "input", -1, &a->input, ""))
		return soap->error;
	if (soap_out_trans_t(soap, "type", -1, &a->type, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdUpdateFileVersion * SOAP_FMAC4 soap_in_bmd230__bmdUpdateFileVersion(struct soap *soap, const char *tag, struct bmd230__bmdUpdateFileVersion *a, const char *type)
{
	size_t soap_flag_cert = 1;
	size_t soap_flag_userRoleId = 1;
	size_t soap_flag_userGroupId = 1;
	size_t soap_flag_userClassId = 1;
	size_t soap_flag_fileId = 1;
	size_t soap_flag_input = 1;
	size_t soap_flag_type = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdUpdateFileVersion *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdUpdateFileVersion, sizeof(struct bmd230__bmdUpdateFileVersion), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdUpdateFileVersion(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cert && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "cert", &a->cert, "xsd:base64Binary"))
				{	soap_flag_cert--;
					continue;
				}
			if (soap_flag_userRoleId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userRoleId", &a->userRoleId, "xsd:string"))
				{	soap_flag_userRoleId--;
					continue;
				}
			if (soap_flag_userGroupId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userGroupId", &a->userGroupId, "xsd:string"))
				{	soap_flag_userGroupId--;
					continue;
				}
			if (soap_flag_userClassId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userClassId", &a->userClassId, "xsd:string"))
				{	soap_flag_userClassId--;
					continue;
				}
			if (soap_flag_fileId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "fileId", &a->fileId, "xsd:string"))
				{	soap_flag_fileId--;
					continue;
				}
			if (soap_flag_input && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobmd230__fileInfo(soap, "input", &a->input, "bmd230:fileInfo"))
				{	soap_flag_input--;
					continue;
				}
			if (soap_flag_type && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_trans_t(soap, "type", &a->type, "trans-t"))
				{	soap_flag_type--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdUpdateFileVersion *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdUpdateFileVersion, 0, sizeof(struct bmd230__bmdUpdateFileVersion), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_type > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdUpdateFileVersion(struct soap *soap, const struct bmd230__bmdUpdateFileVersion *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdUpdateFileVersion);
	if (soap_out_bmd230__bmdUpdateFileVersion(soap, tag?tag:"bmd230:bmdUpdateFileVersion", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdUpdateFileVersion * SOAP_FMAC4 soap_get_bmd230__bmdUpdateFileVersion(struct soap *soap, struct bmd230__bmdUpdateFileVersion *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdUpdateFileVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdUpdateFileVersionResponse(struct soap *soap, struct bmd230__bmdUpdateFileVersionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->updatedFileId = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdUpdateFileVersionResponse(struct soap *soap, const struct bmd230__bmdUpdateFileVersionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTolong(soap, &a->updatedFileId);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdUpdateFileVersionResponse(struct soap *soap, const char *tag, int id, const struct bmd230__bmdUpdateFileVersionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdUpdateFileVersionResponse), type))
		return soap->error;
	if (soap_out_PointerTolong(soap, "updatedFileId", -1, &a->updatedFileId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdUpdateFileVersionResponse * SOAP_FMAC4 soap_in_bmd230__bmdUpdateFileVersionResponse(struct soap *soap, const char *tag, struct bmd230__bmdUpdateFileVersionResponse *a, const char *type)
{
	size_t soap_flag_updatedFileId = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdUpdateFileVersionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdUpdateFileVersionResponse, sizeof(struct bmd230__bmdUpdateFileVersionResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdUpdateFileVersionResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_updatedFileId && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTolong(soap, "updatedFileId", &a->updatedFileId, "xsd:long"))
				{	soap_flag_updatedFileId--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdUpdateFileVersionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdUpdateFileVersionResponse, 0, sizeof(struct bmd230__bmdUpdateFileVersionResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdUpdateFileVersionResponse(struct soap *soap, const struct bmd230__bmdUpdateFileVersionResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdUpdateFileVersionResponse);
	if (soap_out_bmd230__bmdUpdateFileVersionResponse(soap, tag?tag:"bmd230:bmdUpdateFileVersionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdUpdateFileVersionResponse * SOAP_FMAC4 soap_get_bmd230__bmdUpdateFileVersionResponse(struct soap *soap, struct bmd230__bmdUpdateFileVersionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdUpdateFileVersionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdInsertFileList(struct soap *soap, struct bmd230__bmdInsertFileList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cert = NULL;
	soap_default_string(soap, &a->userRoleId);
	soap_default_string(soap, &a->userGroupId);
	soap_default_string(soap, &a->userClassId);
	a->input = NULL;
	soap_default_string(soap, &a->transactionId);
	soap_default_trans_t(soap, &a->type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdInsertFileList(struct soap *soap, const struct bmd230__bmdInsertFileList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__base64Binary(soap, &a->cert);
	soap_serialize_string(soap, &a->userRoleId);
	soap_serialize_string(soap, &a->userGroupId);
	soap_serialize_string(soap, &a->userClassId);
	soap_serialize_PointerTobmd230__fileComplexList(soap, &a->input);
	soap_serialize_string(soap, &a->transactionId);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdInsertFileList(struct soap *soap, const char *tag, int id, const struct bmd230__bmdInsertFileList *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdInsertFileList), type))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "cert", -1, &a->cert, ""))
		return soap->error;
	if (soap_out_string(soap, "userRoleId", -1, &a->userRoleId, ""))
		return soap->error;
	if (soap_out_string(soap, "userGroupId", -1, &a->userGroupId, ""))
		return soap->error;
	if (soap_out_string(soap, "userClassId", -1, &a->userClassId, ""))
		return soap->error;
	if (soap_out_PointerTobmd230__fileComplexList(soap, "input", -1, &a->input, ""))
		return soap->error;
	if (soap_out_string(soap, "transactionId", -1, &a->transactionId, ""))
		return soap->error;
	if (soap_out_trans_t(soap, "type", -1, &a->type, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdInsertFileList * SOAP_FMAC4 soap_in_bmd230__bmdInsertFileList(struct soap *soap, const char *tag, struct bmd230__bmdInsertFileList *a, const char *type)
{
	size_t soap_flag_cert = 1;
	size_t soap_flag_userRoleId = 1;
	size_t soap_flag_userGroupId = 1;
	size_t soap_flag_userClassId = 1;
	size_t soap_flag_input = 1;
	size_t soap_flag_transactionId = 1;
	size_t soap_flag_type = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdInsertFileList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdInsertFileList, sizeof(struct bmd230__bmdInsertFileList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdInsertFileList(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cert && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "cert", &a->cert, "xsd:base64Binary"))
				{	soap_flag_cert--;
					continue;
				}
			if (soap_flag_userRoleId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userRoleId", &a->userRoleId, "xsd:string"))
				{	soap_flag_userRoleId--;
					continue;
				}
			if (soap_flag_userGroupId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userGroupId", &a->userGroupId, "xsd:string"))
				{	soap_flag_userGroupId--;
					continue;
				}
			if (soap_flag_userClassId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userClassId", &a->userClassId, "xsd:string"))
				{	soap_flag_userClassId--;
					continue;
				}
			if (soap_flag_input && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobmd230__fileComplexList(soap, "input", &a->input, "bmd230:fileComplexList"))
				{	soap_flag_input--;
					continue;
				}
			if (soap_flag_transactionId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "transactionId", &a->transactionId, "xsd:string"))
				{	soap_flag_transactionId--;
					continue;
				}
			if (soap_flag_type && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_trans_t(soap, "type", &a->type, "trans-t"))
				{	soap_flag_type--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdInsertFileList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdInsertFileList, 0, sizeof(struct bmd230__bmdInsertFileList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_type > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdInsertFileList(struct soap *soap, const struct bmd230__bmdInsertFileList *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdInsertFileList);
	if (soap_out_bmd230__bmdInsertFileList(soap, tag?tag:"bmd230:bmdInsertFileList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdInsertFileList * SOAP_FMAC4 soap_get_bmd230__bmdInsertFileList(struct soap *soap, struct bmd230__bmdInsertFileList *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdInsertFileList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdInsertFileListResponse(struct soap *soap, struct bmd230__bmdInsertFileListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ids = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdInsertFileListResponse(struct soap *soap, const struct bmd230__bmdInsertFileListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToPointerTobmd230__idList(soap, &a->ids);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdInsertFileListResponse(struct soap *soap, const char *tag, int id, const struct bmd230__bmdInsertFileListResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdInsertFileListResponse), type))
		return soap->error;
	if (soap_out_PointerToPointerTobmd230__idList(soap, "ids", -1, &a->ids, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdInsertFileListResponse * SOAP_FMAC4 soap_in_bmd230__bmdInsertFileListResponse(struct soap *soap, const char *tag, struct bmd230__bmdInsertFileListResponse *a, const char *type)
{
	size_t soap_flag_ids = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdInsertFileListResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdInsertFileListResponse, sizeof(struct bmd230__bmdInsertFileListResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdInsertFileListResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ids && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToPointerTobmd230__idList(soap, "ids", &a->ids, "bmd230:idList"))
				{	soap_flag_ids--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdInsertFileListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdInsertFileListResponse, 0, sizeof(struct bmd230__bmdInsertFileListResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdInsertFileListResponse(struct soap *soap, const struct bmd230__bmdInsertFileListResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdInsertFileListResponse);
	if (soap_out_bmd230__bmdInsertFileListResponse(soap, tag?tag:"bmd230:bmdInsertFileListResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdInsertFileListResponse * SOAP_FMAC4 soap_get_bmd230__bmdInsertFileListResponse(struct soap *soap, struct bmd230__bmdInsertFileListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdInsertFileListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdInsertSignedFile(struct soap *soap, struct bmd230__bmdInsertSignedFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cert = NULL;
	soap_default_string(soap, &a->userRoleId);
	soap_default_string(soap, &a->userGroupId);
	soap_default_string(soap, &a->userClassId);
	a->mtds = NULL;
	a->input = NULL;
	a->binarySignature = NULL;
	soap_default_string(soap, &a->signatureType);
	soap_default_string(soap, &a->transactionId);
	soap_default_trans_t(soap, &a->type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdInsertSignedFile(struct soap *soap, const struct bmd230__bmdInsertSignedFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__base64Binary(soap, &a->cert);
	soap_serialize_string(soap, &a->userRoleId);
	soap_serialize_string(soap, &a->userGroupId);
	soap_serialize_string(soap, &a->userClassId);
	soap_serialize_PointerTobmd230__mtdsValues(soap, &a->mtds);
	soap_serialize_PointerTobmd230__fileInfo(soap, &a->input);
	soap_serialize_PointerTobmd230__myBinaryDataType(soap, &a->binarySignature);
	soap_serialize_string(soap, &a->signatureType);
	soap_serialize_string(soap, &a->transactionId);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdInsertSignedFile(struct soap *soap, const char *tag, int id, const struct bmd230__bmdInsertSignedFile *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdInsertSignedFile), type))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "cert", -1, &a->cert, ""))
		return soap->error;
	if (soap_out_string(soap, "userRoleId", -1, &a->userRoleId, ""))
		return soap->error;
	if (soap_out_string(soap, "userGroupId", -1, &a->userGroupId, ""))
		return soap->error;
	if (soap_out_string(soap, "userClassId", -1, &a->userClassId, ""))
		return soap->error;
	if (soap_out_PointerTobmd230__mtdsValues(soap, "mtds", -1, &a->mtds, ""))
		return soap->error;
	if (soap_out_PointerTobmd230__fileInfo(soap, "input", -1, &a->input, ""))
		return soap->error;
	if (soap_out_PointerTobmd230__myBinaryDataType(soap, "binarySignature", -1, &a->binarySignature, ""))
		return soap->error;
	if (soap_out_string(soap, "signatureType", -1, &a->signatureType, ""))
		return soap->error;
	if (soap_out_string(soap, "transactionId", -1, &a->transactionId, ""))
		return soap->error;
	if (soap_out_trans_t(soap, "type", -1, &a->type, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdInsertSignedFile * SOAP_FMAC4 soap_in_bmd230__bmdInsertSignedFile(struct soap *soap, const char *tag, struct bmd230__bmdInsertSignedFile *a, const char *type)
{
	size_t soap_flag_cert = 1;
	size_t soap_flag_userRoleId = 1;
	size_t soap_flag_userGroupId = 1;
	size_t soap_flag_userClassId = 1;
	size_t soap_flag_mtds = 1;
	size_t soap_flag_input = 1;
	size_t soap_flag_binarySignature = 1;
	size_t soap_flag_signatureType = 1;
	size_t soap_flag_transactionId = 1;
	size_t soap_flag_type = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdInsertSignedFile *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdInsertSignedFile, sizeof(struct bmd230__bmdInsertSignedFile), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdInsertSignedFile(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cert && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "cert", &a->cert, "xsd:base64Binary"))
				{	soap_flag_cert--;
					continue;
				}
			if (soap_flag_userRoleId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userRoleId", &a->userRoleId, "xsd:string"))
				{	soap_flag_userRoleId--;
					continue;
				}
			if (soap_flag_userGroupId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userGroupId", &a->userGroupId, "xsd:string"))
				{	soap_flag_userGroupId--;
					continue;
				}
			if (soap_flag_userClassId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userClassId", &a->userClassId, "xsd:string"))
				{	soap_flag_userClassId--;
					continue;
				}
			if (soap_flag_mtds && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobmd230__mtdsValues(soap, "mtds", &a->mtds, "bmd230:mtdsValues"))
				{	soap_flag_mtds--;
					continue;
				}
			if (soap_flag_input && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobmd230__fileInfo(soap, "input", &a->input, "bmd230:fileInfo"))
				{	soap_flag_input--;
					continue;
				}
			if (soap_flag_binarySignature && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobmd230__myBinaryDataType(soap, "binarySignature", &a->binarySignature, "bmd230:myBinaryDataType"))
				{	soap_flag_binarySignature--;
					continue;
				}
			if (soap_flag_signatureType && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "signatureType", &a->signatureType, "xsd:string"))
				{	soap_flag_signatureType--;
					continue;
				}
			if (soap_flag_transactionId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "transactionId", &a->transactionId, "xsd:string"))
				{	soap_flag_transactionId--;
					continue;
				}
			if (soap_flag_type && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_trans_t(soap, "type", &a->type, "trans-t"))
				{	soap_flag_type--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdInsertSignedFile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdInsertSignedFile, 0, sizeof(struct bmd230__bmdInsertSignedFile), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_type > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdInsertSignedFile(struct soap *soap, const struct bmd230__bmdInsertSignedFile *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdInsertSignedFile);
	if (soap_out_bmd230__bmdInsertSignedFile(soap, tag?tag:"bmd230:bmdInsertSignedFile", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdInsertSignedFile * SOAP_FMAC4 soap_get_bmd230__bmdInsertSignedFile(struct soap *soap, struct bmd230__bmdInsertSignedFile *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdInsertSignedFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdInsertSignedFileResponse(struct soap *soap, struct bmd230__bmdInsertSignedFileResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->id = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdInsertSignedFileResponse(struct soap *soap, const struct bmd230__bmdInsertSignedFileResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTolong(soap, &a->id);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdInsertSignedFileResponse(struct soap *soap, const char *tag, int id, const struct bmd230__bmdInsertSignedFileResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdInsertSignedFileResponse), type))
		return soap->error;
	if (soap_out_PointerTolong(soap, "id", -1, &a->id, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdInsertSignedFileResponse * SOAP_FMAC4 soap_in_bmd230__bmdInsertSignedFileResponse(struct soap *soap, const char *tag, struct bmd230__bmdInsertSignedFileResponse *a, const char *type)
{
	size_t soap_flag_id = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdInsertSignedFileResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdInsertSignedFileResponse, sizeof(struct bmd230__bmdInsertSignedFileResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdInsertSignedFileResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTolong(soap, "id", &a->id, "xsd:long"))
				{	soap_flag_id--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdInsertSignedFileResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdInsertSignedFileResponse, 0, sizeof(struct bmd230__bmdInsertSignedFileResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdInsertSignedFileResponse(struct soap *soap, const struct bmd230__bmdInsertSignedFileResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdInsertSignedFileResponse);
	if (soap_out_bmd230__bmdInsertSignedFileResponse(soap, tag?tag:"bmd230:bmdInsertSignedFileResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdInsertSignedFileResponse * SOAP_FMAC4 soap_get_bmd230__bmdInsertSignedFileResponse(struct soap *soap, struct bmd230__bmdInsertSignedFileResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdInsertSignedFileResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdInsertFile(struct soap *soap, struct bmd230__bmdInsertFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cert = NULL;
	soap_default_string(soap, &a->userRoleId);
	soap_default_string(soap, &a->userGroupId);
	soap_default_string(soap, &a->userClassId);
	a->mtds = NULL;
	a->input = NULL;
	soap_default_string(soap, &a->transactionId);
	soap_default_trans_t(soap, &a->type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdInsertFile(struct soap *soap, const struct bmd230__bmdInsertFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__base64Binary(soap, &a->cert);
	soap_serialize_string(soap, &a->userRoleId);
	soap_serialize_string(soap, &a->userGroupId);
	soap_serialize_string(soap, &a->userClassId);
	soap_serialize_PointerTobmd230__mtdsValues(soap, &a->mtds);
	soap_serialize_PointerTobmd230__fileInfo(soap, &a->input);
	soap_serialize_string(soap, &a->transactionId);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdInsertFile(struct soap *soap, const char *tag, int id, const struct bmd230__bmdInsertFile *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdInsertFile), type))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "cert", -1, &a->cert, ""))
		return soap->error;
	if (soap_out_string(soap, "userRoleId", -1, &a->userRoleId, ""))
		return soap->error;
	if (soap_out_string(soap, "userGroupId", -1, &a->userGroupId, ""))
		return soap->error;
	if (soap_out_string(soap, "userClassId", -1, &a->userClassId, ""))
		return soap->error;
	if (soap_out_PointerTobmd230__mtdsValues(soap, "mtds", -1, &a->mtds, ""))
		return soap->error;
	if (soap_out_PointerTobmd230__fileInfo(soap, "input", -1, &a->input, ""))
		return soap->error;
	if (soap_out_string(soap, "transactionId", -1, &a->transactionId, ""))
		return soap->error;
	if (soap_out_trans_t(soap, "type", -1, &a->type, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdInsertFile * SOAP_FMAC4 soap_in_bmd230__bmdInsertFile(struct soap *soap, const char *tag, struct bmd230__bmdInsertFile *a, const char *type)
{
	size_t soap_flag_cert = 1;
	size_t soap_flag_userRoleId = 1;
	size_t soap_flag_userGroupId = 1;
	size_t soap_flag_userClassId = 1;
	size_t soap_flag_mtds = 1;
	size_t soap_flag_input = 1;
	size_t soap_flag_transactionId = 1;
	size_t soap_flag_type = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdInsertFile *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdInsertFile, sizeof(struct bmd230__bmdInsertFile), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdInsertFile(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cert && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "cert", &a->cert, "xsd:base64Binary"))
				{	soap_flag_cert--;
					continue;
				}
			if (soap_flag_userRoleId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userRoleId", &a->userRoleId, "xsd:string"))
				{	soap_flag_userRoleId--;
					continue;
				}
			if (soap_flag_userGroupId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userGroupId", &a->userGroupId, "xsd:string"))
				{	soap_flag_userGroupId--;
					continue;
				}
			if (soap_flag_userClassId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userClassId", &a->userClassId, "xsd:string"))
				{	soap_flag_userClassId--;
					continue;
				}
			if (soap_flag_mtds && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobmd230__mtdsValues(soap, "mtds", &a->mtds, "bmd230:mtdsValues"))
				{	soap_flag_mtds--;
					continue;
				}
			if (soap_flag_input && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobmd230__fileInfo(soap, "input", &a->input, "bmd230:fileInfo"))
				{	soap_flag_input--;
					continue;
				}
			if (soap_flag_transactionId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "transactionId", &a->transactionId, "xsd:string"))
				{	soap_flag_transactionId--;
					continue;
				}
			if (soap_flag_type && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_trans_t(soap, "type", &a->type, "trans-t"))
				{	soap_flag_type--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdInsertFile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdInsertFile, 0, sizeof(struct bmd230__bmdInsertFile), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_type > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdInsertFile(struct soap *soap, const struct bmd230__bmdInsertFile *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdInsertFile);
	if (soap_out_bmd230__bmdInsertFile(soap, tag?tag:"bmd230:bmdInsertFile", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdInsertFile * SOAP_FMAC4 soap_get_bmd230__bmdInsertFile(struct soap *soap, struct bmd230__bmdInsertFile *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdInsertFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdInsertFileResponse(struct soap *soap, struct bmd230__bmdInsertFileResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->id = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdInsertFileResponse(struct soap *soap, const struct bmd230__bmdInsertFileResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTolong(soap, &a->id);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdInsertFileResponse(struct soap *soap, const char *tag, int id, const struct bmd230__bmdInsertFileResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdInsertFileResponse), type))
		return soap->error;
	if (soap_out_PointerTolong(soap, "id", -1, &a->id, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdInsertFileResponse * SOAP_FMAC4 soap_in_bmd230__bmdInsertFileResponse(struct soap *soap, const char *tag, struct bmd230__bmdInsertFileResponse *a, const char *type)
{
	size_t soap_flag_id = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdInsertFileResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdInsertFileResponse, sizeof(struct bmd230__bmdInsertFileResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdInsertFileResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTolong(soap, "id", &a->id, "xsd:long"))
				{	soap_flag_id--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdInsertFileResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdInsertFileResponse, 0, sizeof(struct bmd230__bmdInsertFileResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdInsertFileResponse(struct soap *soap, const struct bmd230__bmdInsertFileResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdInsertFileResponse);
	if (soap_out_bmd230__bmdInsertFileResponse(soap, tag?tag:"bmd230:bmdInsertFileResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdInsertFileResponse * SOAP_FMAC4 soap_get_bmd230__bmdInsertFileResponse(struct soap *soap, struct bmd230__bmdInsertFileResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdInsertFileResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__testConnection(struct soap *soap, struct bmd230__testConnection *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__testConnection(struct soap *soap, const struct bmd230__testConnection *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__testConnection(struct soap *soap, const char *tag, int id, const struct bmd230__testConnection *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__testConnection), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__testConnection * SOAP_FMAC4 soap_in_bmd230__testConnection(struct soap *soap, const char *tag, struct bmd230__testConnection *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__testConnection *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__testConnection, sizeof(struct bmd230__testConnection), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__testConnection(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__testConnection *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__testConnection, 0, sizeof(struct bmd230__testConnection), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__testConnection(struct soap *soap, const struct bmd230__testConnection *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__testConnection);
	if (soap_out_bmd230__testConnection(soap, tag?tag:"bmd230:testConnection", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__testConnection * SOAP_FMAC4 soap_get_bmd230__testConnection(struct soap *soap, struct bmd230__testConnection *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__testConnection(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__testConnectionResponse(struct soap *soap, struct bmd230__testConnectionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__testConnectionResponse(struct soap *soap, const struct bmd230__testConnectionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__testConnectionResponse(struct soap *soap, const char *tag, int id, const struct bmd230__testConnectionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__testConnectionResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "result", -1, &a->result, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__testConnectionResponse * SOAP_FMAC4 soap_in_bmd230__testConnectionResponse(struct soap *soap, const char *tag, struct bmd230__testConnectionResponse *a, const char *type)
{
	size_t soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__testConnectionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__testConnectionResponse, sizeof(struct bmd230__testConnectionResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__testConnectionResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, "result", &a->result, "xsd:string"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__testConnectionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__testConnectionResponse, 0, sizeof(struct bmd230__testConnectionResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__testConnectionResponse(struct soap *soap, const struct bmd230__testConnectionResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__testConnectionResponse);
	if (soap_out_bmd230__testConnectionResponse(soap, tag?tag:"bmd230:testConnectionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__testConnectionResponse * SOAP_FMAC4 soap_get_bmd230__testConnectionResponse(struct soap *soap, struct bmd230__testConnectionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__testConnectionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__ActionsHistoryList(struct soap *soap, struct bmd230__ActionsHistoryList *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__ActionsHistoryList(struct soap *soap, struct bmd230__ActionsHistoryList const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_bmd230__ActionsHistoryList))
		for (i = 0; i < a->__size; i++)
		{	soap_embedded(soap, a->__ptr + i, SOAP_TYPE_bmd230__ActionsHistoryElement);
			soap_serialize_bmd230__ActionsHistoryElement(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__ActionsHistoryList(struct soap *soap, const char *tag, int id, const struct bmd230__ActionsHistoryList *a, const char *type)
{
	int i, n = a->__size;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_bmd230__ActionsHistoryList);
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap_out_bmd230__ActionsHistoryElement(soap, "item", -1, &a->__ptr[i], "");
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__ActionsHistoryList * SOAP_FMAC4 soap_in_bmd230__ActionsHistoryList(struct soap *soap, const char *tag, struct bmd230__ActionsHistoryList *a, const char *type)
{	int i, j;
	struct bmd230__ActionsHistoryElement *p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_array(soap, "bmd230:ActionsHistoryElement") && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct bmd230__ActionsHistoryList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__ActionsHistoryList, sizeof(struct bmd230__ActionsHistoryList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__ActionsHistoryList(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct bmd230__ActionsHistoryElement *)soap_malloc(soap, sizeof(struct bmd230__ActionsHistoryElement) * a->__size);
			for (i = 0; i < a->__size; i++)
				soap_default_bmd230__ActionsHistoryElement(soap, a->__ptr+i);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_bmd230__ActionsHistoryElement(soap, NULL, a->__ptr + i, "bmd230:ActionsHistoryElement"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct bmd230__ActionsHistoryElement *)soap_push_block(soap, NULL, sizeof(struct bmd230__ActionsHistoryElement));
				if (!p)
					return NULL;
				soap_default_bmd230__ActionsHistoryElement(soap, p);
				if (!soap_in_bmd230__ActionsHistoryElement(soap, NULL, p, "bmd230:ActionsHistoryElement"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct bmd230__ActionsHistoryElement *)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__ActionsHistoryList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__ActionsHistoryList, 0, sizeof(struct bmd230__ActionsHistoryList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__ActionsHistoryList(struct soap *soap, const struct bmd230__ActionsHistoryList *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_bmd230__ActionsHistoryList);
	if (soap_out_bmd230__ActionsHistoryList(soap, tag?tag:"bmd230:ActionsHistoryList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__ActionsHistoryList * SOAP_FMAC4 soap_get_bmd230__ActionsHistoryList(struct soap *soap, struct bmd230__ActionsHistoryList *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__ActionsHistoryList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__ActionsHistoryElement(struct soap *soap, struct bmd230__ActionsHistoryElement *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->objectId);
	soap_default_xsd__string(soap, &a->objectType);
	soap_default_xsd__string(soap, &a->executorIdentityName);
	soap_default_xsd__string(soap, &a->executorClassName);
	soap_default_xsd__string(soap, &a->actionName);
	soap_default_xsd__string(soap, &a->actionDate);
	soap_default_xsd__string(soap, &a->actionStatus);
	soap_default_xsd__string(soap, &a->actionStatusMessage);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__ActionsHistoryElement(struct soap *soap, const struct bmd230__ActionsHistoryElement *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__string(soap, &a->objectId);
	soap_serialize_xsd__string(soap, &a->objectType);
	soap_serialize_xsd__string(soap, &a->executorIdentityName);
	soap_serialize_xsd__string(soap, &a->executorClassName);
	soap_serialize_xsd__string(soap, &a->actionName);
	soap_serialize_xsd__string(soap, &a->actionDate);
	soap_serialize_xsd__string(soap, &a->actionStatus);
	soap_serialize_xsd__string(soap, &a->actionStatusMessage);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__ActionsHistoryElement(struct soap *soap, const char *tag, int id, const struct bmd230__ActionsHistoryElement *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__ActionsHistoryElement), type))
		return soap->error;
	if (soap_out_xsd__string(soap, "objectId", -1, &a->objectId, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "objectType", -1, &a->objectType, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "executorIdentityName", -1, &a->executorIdentityName, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "executorClassName", -1, &a->executorClassName, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "actionName", -1, &a->actionName, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "actionDate", -1, &a->actionDate, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "actionStatus", -1, &a->actionStatus, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "actionStatusMessage", -1, &a->actionStatusMessage, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__ActionsHistoryElement * SOAP_FMAC4 soap_in_bmd230__ActionsHistoryElement(struct soap *soap, const char *tag, struct bmd230__ActionsHistoryElement *a, const char *type)
{
	size_t soap_flag_objectId = 1;
	size_t soap_flag_objectType = 1;
	size_t soap_flag_executorIdentityName = 1;
	size_t soap_flag_executorClassName = 1;
	size_t soap_flag_actionName = 1;
	size_t soap_flag_actionDate = 1;
	size_t soap_flag_actionStatus = 1;
	size_t soap_flag_actionStatusMessage = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__ActionsHistoryElement *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__ActionsHistoryElement, sizeof(struct bmd230__ActionsHistoryElement), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__ActionsHistoryElement(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_objectId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "objectId", &a->objectId, "xsd:string"))
				{	soap_flag_objectId--;
					continue;
				}
			if (soap_flag_objectType && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "objectType", &a->objectType, "xsd:string"))
				{	soap_flag_objectType--;
					continue;
				}
			if (soap_flag_executorIdentityName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "executorIdentityName", &a->executorIdentityName, "xsd:string"))
				{	soap_flag_executorIdentityName--;
					continue;
				}
			if (soap_flag_executorClassName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "executorClassName", &a->executorClassName, "xsd:string"))
				{	soap_flag_executorClassName--;
					continue;
				}
			if (soap_flag_actionName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "actionName", &a->actionName, "xsd:string"))
				{	soap_flag_actionName--;
					continue;
				}
			if (soap_flag_actionDate && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "actionDate", &a->actionDate, "xsd:string"))
				{	soap_flag_actionDate--;
					continue;
				}
			if (soap_flag_actionStatus && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "actionStatus", &a->actionStatus, "xsd:string"))
				{	soap_flag_actionStatus--;
					continue;
				}
			if (soap_flag_actionStatusMessage && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "actionStatusMessage", &a->actionStatusMessage, "xsd:string"))
				{	soap_flag_actionStatusMessage--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__ActionsHistoryElement *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__ActionsHistoryElement, 0, sizeof(struct bmd230__ActionsHistoryElement), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__ActionsHistoryElement(struct soap *soap, const struct bmd230__ActionsHistoryElement *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__ActionsHistoryElement);
	if (soap_out_bmd230__ActionsHistoryElement(soap, tag?tag:"bmd230:ActionsHistoryElement", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__ActionsHistoryElement * SOAP_FMAC4 soap_get_bmd230__ActionsHistoryElement(struct soap *soap, struct bmd230__ActionsHistoryElement *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__ActionsHistoryElement(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__GetVersionsHistoryResultList(struct soap *soap, struct bmd230__GetVersionsHistoryResultList *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__GetVersionsHistoryResultList(struct soap *soap, struct bmd230__GetVersionsHistoryResultList const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_bmd230__GetVersionsHistoryResultList))
		for (i = 0; i < a->__size; i++)
		{	soap_embedded(soap, a->__ptr + i, SOAP_TYPE_bmd230__GetVersionsHistoryResult);
			soap_serialize_bmd230__GetVersionsHistoryResult(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__GetVersionsHistoryResultList(struct soap *soap, const char *tag, int id, const struct bmd230__GetVersionsHistoryResultList *a, const char *type)
{
	int i, n = a->__size;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_bmd230__GetVersionsHistoryResultList);
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap_out_bmd230__GetVersionsHistoryResult(soap, "item", -1, &a->__ptr[i], "");
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__GetVersionsHistoryResultList * SOAP_FMAC4 soap_in_bmd230__GetVersionsHistoryResultList(struct soap *soap, const char *tag, struct bmd230__GetVersionsHistoryResultList *a, const char *type)
{	int i, j;
	struct bmd230__GetVersionsHistoryResult *p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_array(soap, "bmd230:GetVersionsHistoryResult") && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct bmd230__GetVersionsHistoryResultList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__GetVersionsHistoryResultList, sizeof(struct bmd230__GetVersionsHistoryResultList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__GetVersionsHistoryResultList(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct bmd230__GetVersionsHistoryResult *)soap_malloc(soap, sizeof(struct bmd230__GetVersionsHistoryResult) * a->__size);
			for (i = 0; i < a->__size; i++)
				soap_default_bmd230__GetVersionsHistoryResult(soap, a->__ptr+i);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_bmd230__GetVersionsHistoryResult(soap, NULL, a->__ptr + i, "bmd230:GetVersionsHistoryResult"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct bmd230__GetVersionsHistoryResult *)soap_push_block(soap, NULL, sizeof(struct bmd230__GetVersionsHistoryResult));
				if (!p)
					return NULL;
				soap_default_bmd230__GetVersionsHistoryResult(soap, p);
				if (!soap_in_bmd230__GetVersionsHistoryResult(soap, NULL, p, "bmd230:GetVersionsHistoryResult"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct bmd230__GetVersionsHistoryResult *)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__GetVersionsHistoryResultList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__GetVersionsHistoryResultList, 0, sizeof(struct bmd230__GetVersionsHistoryResultList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__GetVersionsHistoryResultList(struct soap *soap, const struct bmd230__GetVersionsHistoryResultList *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_bmd230__GetVersionsHistoryResultList);
	if (soap_out_bmd230__GetVersionsHistoryResultList(soap, tag?tag:"bmd230:GetVersionsHistoryResultList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__GetVersionsHistoryResultList * SOAP_FMAC4 soap_get_bmd230__GetVersionsHistoryResultList(struct soap *soap, struct bmd230__GetVersionsHistoryResultList *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__GetVersionsHistoryResultList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__GetVersionsHistoryResult(struct soap *soap, struct bmd230__GetVersionsHistoryResult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->versionsInfoList = NULL;
	soap_default_long(soap, &a->errorCode);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__GetVersionsHistoryResult(struct soap *soap, const struct bmd230__GetVersionsHistoryResult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTobmd230__FileVersionInfoList(soap, &a->versionsInfoList);
	soap_embedded(soap, &a->errorCode, SOAP_TYPE_long);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__GetVersionsHistoryResult(struct soap *soap, const char *tag, int id, const struct bmd230__GetVersionsHistoryResult *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__GetVersionsHistoryResult), type))
		return soap->error;
	if (soap_out_PointerTobmd230__FileVersionInfoList(soap, "versionsInfoList", -1, &a->versionsInfoList, ""))
		return soap->error;
	if (soap_out_long(soap, "errorCode", -1, &a->errorCode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__GetVersionsHistoryResult * SOAP_FMAC4 soap_in_bmd230__GetVersionsHistoryResult(struct soap *soap, const char *tag, struct bmd230__GetVersionsHistoryResult *a, const char *type)
{
	size_t soap_flag_versionsInfoList = 1;
	size_t soap_flag_errorCode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__GetVersionsHistoryResult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__GetVersionsHistoryResult, sizeof(struct bmd230__GetVersionsHistoryResult), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__GetVersionsHistoryResult(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_versionsInfoList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobmd230__FileVersionInfoList(soap, "versionsInfoList", &a->versionsInfoList, "bmd230:FileVersionInfoList"))
				{	soap_flag_versionsInfoList--;
					continue;
				}
			if (soap_flag_errorCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_long(soap, "errorCode", &a->errorCode, "xsd:long"))
				{	soap_flag_errorCode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__GetVersionsHistoryResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__GetVersionsHistoryResult, 0, sizeof(struct bmd230__GetVersionsHistoryResult), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_errorCode > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__GetVersionsHistoryResult(struct soap *soap, const struct bmd230__GetVersionsHistoryResult *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__GetVersionsHistoryResult);
	if (soap_out_bmd230__GetVersionsHistoryResult(soap, tag?tag:"bmd230:GetVersionsHistoryResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__GetVersionsHistoryResult * SOAP_FMAC4 soap_get_bmd230__GetVersionsHistoryResult(struct soap *soap, struct bmd230__GetVersionsHistoryResult *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__GetVersionsHistoryResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__FileVersionInfoList(struct soap *soap, struct bmd230__FileVersionInfoList *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__FileVersionInfoList(struct soap *soap, struct bmd230__FileVersionInfoList const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_bmd230__FileVersionInfoList))
		for (i = 0; i < a->__size; i++)
		{	soap_embedded(soap, a->__ptr + i, SOAP_TYPE_bmd230__FileVersionInfo);
			soap_serialize_bmd230__FileVersionInfo(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__FileVersionInfoList(struct soap *soap, const char *tag, int id, const struct bmd230__FileVersionInfoList *a, const char *type)
{
	int i, n = a->__size;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_bmd230__FileVersionInfoList);
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap_out_bmd230__FileVersionInfo(soap, "item", -1, &a->__ptr[i], "");
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__FileVersionInfoList * SOAP_FMAC4 soap_in_bmd230__FileVersionInfoList(struct soap *soap, const char *tag, struct bmd230__FileVersionInfoList *a, const char *type)
{	int i, j;
	struct bmd230__FileVersionInfo *p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_array(soap, "bmd230:FileVersionInfo") && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct bmd230__FileVersionInfoList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__FileVersionInfoList, sizeof(struct bmd230__FileVersionInfoList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__FileVersionInfoList(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct bmd230__FileVersionInfo *)soap_malloc(soap, sizeof(struct bmd230__FileVersionInfo) * a->__size);
			for (i = 0; i < a->__size; i++)
				soap_default_bmd230__FileVersionInfo(soap, a->__ptr+i);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_bmd230__FileVersionInfo(soap, NULL, a->__ptr + i, "bmd230:FileVersionInfo"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct bmd230__FileVersionInfo *)soap_push_block(soap, NULL, sizeof(struct bmd230__FileVersionInfo));
				if (!p)
					return NULL;
				soap_default_bmd230__FileVersionInfo(soap, p);
				if (!soap_in_bmd230__FileVersionInfo(soap, NULL, p, "bmd230:FileVersionInfo"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct bmd230__FileVersionInfo *)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__FileVersionInfoList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__FileVersionInfoList, 0, sizeof(struct bmd230__FileVersionInfoList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__FileVersionInfoList(struct soap *soap, const struct bmd230__FileVersionInfoList *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_bmd230__FileVersionInfoList);
	if (soap_out_bmd230__FileVersionInfoList(soap, tag?tag:"bmd230:FileVersionInfoList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__FileVersionInfoList * SOAP_FMAC4 soap_get_bmd230__FileVersionInfoList(struct soap *soap, struct bmd230__FileVersionInfoList *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__FileVersionInfoList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__FileVersionInfo(struct soap *soap, struct bmd230__FileVersionInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_long(soap, &a->id);
	soap_default_xsd__string(soap, &a->insertDate);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__FileVersionInfo(struct soap *soap, const struct bmd230__FileVersionInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->id, SOAP_TYPE_long);
	soap_serialize_xsd__string(soap, &a->insertDate);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__FileVersionInfo(struct soap *soap, const char *tag, int id, const struct bmd230__FileVersionInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__FileVersionInfo), type))
		return soap->error;
	if (soap_out_long(soap, "id", -1, &a->id, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "insertDate", -1, &a->insertDate, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__FileVersionInfo * SOAP_FMAC4 soap_in_bmd230__FileVersionInfo(struct soap *soap, const char *tag, struct bmd230__FileVersionInfo *a, const char *type)
{
	size_t soap_flag_id = 1;
	size_t soap_flag_insertDate = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__FileVersionInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__FileVersionInfo, sizeof(struct bmd230__FileVersionInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__FileVersionInfo(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_long(soap, "id", &a->id, "xsd:long"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_insertDate && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "insertDate", &a->insertDate, "xsd:string"))
				{	soap_flag_insertDate--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__FileVersionInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__FileVersionInfo, 0, sizeof(struct bmd230__FileVersionInfo), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__FileVersionInfo(struct soap *soap, const struct bmd230__FileVersionInfo *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__FileVersionInfo);
	if (soap_out_bmd230__FileVersionInfo(soap, tag?tag:"bmd230:FileVersionInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__FileVersionInfo * SOAP_FMAC4 soap_get_bmd230__FileVersionInfo(struct soap *soap, struct bmd230__FileVersionInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__FileVersionInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__accessObjectList(struct soap *soap, struct bmd230__accessObjectList *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__accessObjectList(struct soap *soap, struct bmd230__accessObjectList const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_bmd230__accessObjectList))
		for (i = 0; i < a->__size; i++)
		{	soap_embedded(soap, a->__ptr + i, SOAP_TYPE_bmd230__accessObject);
			soap_serialize_bmd230__accessObject(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__accessObjectList(struct soap *soap, const char *tag, int id, const struct bmd230__accessObjectList *a, const char *type)
{
	int i, n = a->__size;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_bmd230__accessObjectList);
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap_out_bmd230__accessObject(soap, "item", -1, &a->__ptr[i], "");
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__accessObjectList * SOAP_FMAC4 soap_in_bmd230__accessObjectList(struct soap *soap, const char *tag, struct bmd230__accessObjectList *a, const char *type)
{	int i, j;
	struct bmd230__accessObject *p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_array(soap, "bmd230:accessObject") && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct bmd230__accessObjectList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__accessObjectList, sizeof(struct bmd230__accessObjectList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__accessObjectList(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct bmd230__accessObject *)soap_malloc(soap, sizeof(struct bmd230__accessObject) * a->__size);
			for (i = 0; i < a->__size; i++)
				soap_default_bmd230__accessObject(soap, a->__ptr+i);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_bmd230__accessObject(soap, NULL, a->__ptr + i, "bmd230:accessObject"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct bmd230__accessObject *)soap_push_block(soap, NULL, sizeof(struct bmd230__accessObject));
				if (!p)
					return NULL;
				soap_default_bmd230__accessObject(soap, p);
				if (!soap_in_bmd230__accessObject(soap, NULL, p, "bmd230:accessObject"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct bmd230__accessObject *)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__accessObjectList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__accessObjectList, 0, sizeof(struct bmd230__accessObjectList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__accessObjectList(struct soap *soap, const struct bmd230__accessObjectList *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_bmd230__accessObjectList);
	if (soap_out_bmd230__accessObjectList(soap, tag?tag:"bmd230:accessObjectList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__accessObjectList * SOAP_FMAC4 soap_get_bmd230__accessObjectList(struct soap *soap, struct bmd230__accessObjectList *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__accessObjectList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__accessObject(struct soap *soap, struct bmd230__accessObject *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->id);
	soap_default_xsd__string(soap, &a->ownerGroupId);
	soap_default_xsd__string(soap, &a->fileType);
	soap_default_xsd__string(soap, &a->ownerIdentityId);
	soap_default_xsd__string(soap, &a->creatorIdentityId);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__accessObject(struct soap *soap, const struct bmd230__accessObject *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__string(soap, &a->id);
	soap_serialize_xsd__string(soap, &a->ownerGroupId);
	soap_serialize_xsd__string(soap, &a->fileType);
	soap_serialize_xsd__string(soap, &a->ownerIdentityId);
	soap_serialize_xsd__string(soap, &a->creatorIdentityId);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__accessObject(struct soap *soap, const char *tag, int id, const struct bmd230__accessObject *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__accessObject), type))
		return soap->error;
	if (soap_out_xsd__string(soap, "id", -1, &a->id, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "ownerGroupId", -1, &a->ownerGroupId, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "fileType", -1, &a->fileType, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "ownerIdentityId", -1, &a->ownerIdentityId, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "creatorIdentityId", -1, &a->creatorIdentityId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__accessObject * SOAP_FMAC4 soap_in_bmd230__accessObject(struct soap *soap, const char *tag, struct bmd230__accessObject *a, const char *type)
{
	size_t soap_flag_id = 1;
	size_t soap_flag_ownerGroupId = 1;
	size_t soap_flag_fileType = 1;
	size_t soap_flag_ownerIdentityId = 1;
	size_t soap_flag_creatorIdentityId = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__accessObject *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__accessObject, sizeof(struct bmd230__accessObject), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__accessObject(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "id", &a->id, "xsd:string"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_ownerGroupId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "ownerGroupId", &a->ownerGroupId, "xsd:string"))
				{	soap_flag_ownerGroupId--;
					continue;
				}
			if (soap_flag_fileType && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "fileType", &a->fileType, "xsd:string"))
				{	soap_flag_fileType--;
					continue;
				}
			if (soap_flag_ownerIdentityId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "ownerIdentityId", &a->ownerIdentityId, "xsd:string"))
				{	soap_flag_ownerIdentityId--;
					continue;
				}
			if (soap_flag_creatorIdentityId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "creatorIdentityId", &a->creatorIdentityId, "xsd:string"))
				{	soap_flag_creatorIdentityId--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__accessObject *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__accessObject, 0, sizeof(struct bmd230__accessObject), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__accessObject(struct soap *soap, const struct bmd230__accessObject *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__accessObject);
	if (soap_out_bmd230__accessObject(soap, tag?tag:"bmd230:accessObject", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__accessObject * SOAP_FMAC4 soap_get_bmd230__accessObject(struct soap *soap, struct bmd230__accessObject *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__accessObject(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__archPackOut(struct soap *soap, struct bmd230__archPackOut *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->file = NULL;
	soap_default_xsd__string(soap, &a->filename);
	soap_default_string(soap, &a->tmpLocation);
	soap_default_string(soap, &a->pathDestZip);
	soap_default_string(soap, &a->currDir);
	soap_default_long(soap, &a->pos);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__archPackOut(struct soap *soap, const struct bmd230__archPackOut *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__base64Binary(soap, &a->file);
	soap_serialize_xsd__string(soap, &a->filename);
	soap_serialize_string(soap, &a->tmpLocation);
	soap_serialize_string(soap, &a->pathDestZip);
	soap_serialize_string(soap, &a->currDir);
	soap_embedded(soap, &a->pos, SOAP_TYPE_long);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__archPackOut(struct soap *soap, const char *tag, int id, const struct bmd230__archPackOut *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__archPackOut), type))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "file", -1, &a->file, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "filename", -1, &a->filename, ""))
		return soap->error;
	if (soap_out_string(soap, "tmpLocation", -1, &a->tmpLocation, ""))
		return soap->error;
	if (soap_out_string(soap, "pathDestZip", -1, &a->pathDestZip, ""))
		return soap->error;
	if (soap_out_string(soap, "currDir", -1, &a->currDir, ""))
		return soap->error;
	if (soap_out_long(soap, "pos", -1, &a->pos, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__archPackOut * SOAP_FMAC4 soap_in_bmd230__archPackOut(struct soap *soap, const char *tag, struct bmd230__archPackOut *a, const char *type)
{
	size_t soap_flag_file = 1;
	size_t soap_flag_filename = 1;
	size_t soap_flag_tmpLocation = 1;
	size_t soap_flag_pathDestZip = 1;
	size_t soap_flag_currDir = 1;
	size_t soap_flag_pos = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__archPackOut *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__archPackOut, sizeof(struct bmd230__archPackOut), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__archPackOut(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_file && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "file", &a->file, "xsd:base64Binary"))
				{	soap_flag_file--;
					continue;
				}
			if (soap_flag_filename && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "filename", &a->filename, "xsd:string"))
				{	soap_flag_filename--;
					continue;
				}
			if (soap_flag_tmpLocation && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tmpLocation", &a->tmpLocation, "xsd:string"))
				{	soap_flag_tmpLocation--;
					continue;
				}
			if (soap_flag_pathDestZip && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "pathDestZip", &a->pathDestZip, "xsd:string"))
				{	soap_flag_pathDestZip--;
					continue;
				}
			if (soap_flag_currDir && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "currDir", &a->currDir, "xsd:string"))
				{	soap_flag_currDir--;
					continue;
				}
			if (soap_flag_pos && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_long(soap, "pos", &a->pos, "xsd:long"))
				{	soap_flag_pos--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__archPackOut *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__archPackOut, 0, sizeof(struct bmd230__archPackOut), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_pos > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__archPackOut(struct soap *soap, const struct bmd230__archPackOut *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__archPackOut);
	if (soap_out_bmd230__archPackOut(soap, tag?tag:"bmd230:archPackOut", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__archPackOut * SOAP_FMAC4 soap_get_bmd230__archPackOut(struct soap *soap, struct bmd230__archPackOut *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__archPackOut(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__deleteCascadeLinksList(struct soap *soap, struct bmd230__deleteCascadeLinksList *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__deleteCascadeLinksList(struct soap *soap, struct bmd230__deleteCascadeLinksList const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_bmd230__deleteCascadeLinksList))
		for (i = 0; i < a->__size; i++)
		{	soap_embedded(soap, a->__ptr + i, SOAP_TYPE_bmd230__deleteCascadeLinksElement);
			soap_serialize_bmd230__deleteCascadeLinksElement(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__deleteCascadeLinksList(struct soap *soap, const char *tag, int id, const struct bmd230__deleteCascadeLinksList *a, const char *type)
{
	int i, n = a->__size;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_bmd230__deleteCascadeLinksList);
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap_out_bmd230__deleteCascadeLinksElement(soap, "item", -1, &a->__ptr[i], "");
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__deleteCascadeLinksList * SOAP_FMAC4 soap_in_bmd230__deleteCascadeLinksList(struct soap *soap, const char *tag, struct bmd230__deleteCascadeLinksList *a, const char *type)
{	int i, j;
	struct bmd230__deleteCascadeLinksElement *p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_array(soap, "bmd230:deleteCascadeLinksElement") && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct bmd230__deleteCascadeLinksList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__deleteCascadeLinksList, sizeof(struct bmd230__deleteCascadeLinksList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__deleteCascadeLinksList(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct bmd230__deleteCascadeLinksElement *)soap_malloc(soap, sizeof(struct bmd230__deleteCascadeLinksElement) * a->__size);
			for (i = 0; i < a->__size; i++)
				soap_default_bmd230__deleteCascadeLinksElement(soap, a->__ptr+i);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_bmd230__deleteCascadeLinksElement(soap, NULL, a->__ptr + i, "bmd230:deleteCascadeLinksElement"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct bmd230__deleteCascadeLinksElement *)soap_push_block(soap, NULL, sizeof(struct bmd230__deleteCascadeLinksElement));
				if (!p)
					return NULL;
				soap_default_bmd230__deleteCascadeLinksElement(soap, p);
				if (!soap_in_bmd230__deleteCascadeLinksElement(soap, NULL, p, "bmd230:deleteCascadeLinksElement"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct bmd230__deleteCascadeLinksElement *)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__deleteCascadeLinksList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__deleteCascadeLinksList, 0, sizeof(struct bmd230__deleteCascadeLinksList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__deleteCascadeLinksList(struct soap *soap, const struct bmd230__deleteCascadeLinksList *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_bmd230__deleteCascadeLinksList);
	if (soap_out_bmd230__deleteCascadeLinksList(soap, tag?tag:"bmd230:deleteCascadeLinksList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__deleteCascadeLinksList * SOAP_FMAC4 soap_get_bmd230__deleteCascadeLinksList(struct soap *soap, struct bmd230__deleteCascadeLinksList *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__deleteCascadeLinksList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__deleteCascadeLinksElement(struct soap *soap, struct bmd230__deleteCascadeLinksElement *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->fileId);
	soap_default_string(soap, &a->ownerIdentityId);
	soap_default_string(soap, &a->ownerCertificateId);
	soap_default_long(soap, &a->correspondingFilesMaxLevel);
	soap_default_visibilityType_t(soap, &a->visible);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__deleteCascadeLinksElement(struct soap *soap, const struct bmd230__deleteCascadeLinksElement *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->fileId);
	soap_serialize_string(soap, &a->ownerIdentityId);
	soap_serialize_string(soap, &a->ownerCertificateId);
	soap_embedded(soap, &a->correspondingFilesMaxLevel, SOAP_TYPE_long);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__deleteCascadeLinksElement(struct soap *soap, const char *tag, int id, const struct bmd230__deleteCascadeLinksElement *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__deleteCascadeLinksElement), type))
		return soap->error;
	if (soap_out_string(soap, "fileId", -1, &a->fileId, ""))
		return soap->error;
	if (soap_out_string(soap, "ownerIdentityId", -1, &a->ownerIdentityId, ""))
		return soap->error;
	if (soap_out_string(soap, "ownerCertificateId", -1, &a->ownerCertificateId, ""))
		return soap->error;
	if (soap_out_long(soap, "correspondingFilesMaxLevel", -1, &a->correspondingFilesMaxLevel, ""))
		return soap->error;
	if (soap_out_visibilityType_t(soap, "visible", -1, &a->visible, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__deleteCascadeLinksElement * SOAP_FMAC4 soap_in_bmd230__deleteCascadeLinksElement(struct soap *soap, const char *tag, struct bmd230__deleteCascadeLinksElement *a, const char *type)
{
	size_t soap_flag_fileId = 1;
	size_t soap_flag_ownerIdentityId = 1;
	size_t soap_flag_ownerCertificateId = 1;
	size_t soap_flag_correspondingFilesMaxLevel = 1;
	size_t soap_flag_visible = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__deleteCascadeLinksElement *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__deleteCascadeLinksElement, sizeof(struct bmd230__deleteCascadeLinksElement), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__deleteCascadeLinksElement(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fileId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "fileId", &a->fileId, "xsd:string"))
				{	soap_flag_fileId--;
					continue;
				}
			if (soap_flag_ownerIdentityId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ownerIdentityId", &a->ownerIdentityId, "xsd:string"))
				{	soap_flag_ownerIdentityId--;
					continue;
				}
			if (soap_flag_ownerCertificateId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ownerCertificateId", &a->ownerCertificateId, "xsd:string"))
				{	soap_flag_ownerCertificateId--;
					continue;
				}
			if (soap_flag_correspondingFilesMaxLevel && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_long(soap, "correspondingFilesMaxLevel", &a->correspondingFilesMaxLevel, "xsd:long"))
				{	soap_flag_correspondingFilesMaxLevel--;
					continue;
				}
			if (soap_flag_visible && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_visibilityType_t(soap, "visible", &a->visible, "visibilityType-t"))
				{	soap_flag_visible--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__deleteCascadeLinksElement *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__deleteCascadeLinksElement, 0, sizeof(struct bmd230__deleteCascadeLinksElement), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_correspondingFilesMaxLevel > 0 || soap_flag_visible > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__deleteCascadeLinksElement(struct soap *soap, const struct bmd230__deleteCascadeLinksElement *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__deleteCascadeLinksElement);
	if (soap_out_bmd230__deleteCascadeLinksElement(soap, tag?tag:"bmd230:deleteCascadeLinksElement", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__deleteCascadeLinksElement * SOAP_FMAC4 soap_get_bmd230__deleteCascadeLinksElement(struct soap *soap, struct bmd230__deleteCascadeLinksElement *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__deleteCascadeLinksElement(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__manyCascadeLinksResult(struct soap *soap, struct bmd230__manyCascadeLinksResult *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__manyCascadeLinksResult(struct soap *soap, struct bmd230__manyCascadeLinksResult const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_bmd230__manyCascadeLinksResult))
		for (i = 0; i < a->__size; i++)
		{	soap_embedded(soap, a->__ptr + i, SOAP_TYPE_bmd230__manyCascadeLinksElement);
			soap_serialize_bmd230__manyCascadeLinksElement(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__manyCascadeLinksResult(struct soap *soap, const char *tag, int id, const struct bmd230__manyCascadeLinksResult *a, const char *type)
{
	int i, n = a->__size;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_bmd230__manyCascadeLinksResult);
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap_out_bmd230__manyCascadeLinksElement(soap, "item", -1, &a->__ptr[i], "");
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__manyCascadeLinksResult * SOAP_FMAC4 soap_in_bmd230__manyCascadeLinksResult(struct soap *soap, const char *tag, struct bmd230__manyCascadeLinksResult *a, const char *type)
{	int i, j;
	struct bmd230__manyCascadeLinksElement *p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_array(soap, "bmd230:manyCascadeLinksElement") && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct bmd230__manyCascadeLinksResult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__manyCascadeLinksResult, sizeof(struct bmd230__manyCascadeLinksResult), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__manyCascadeLinksResult(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct bmd230__manyCascadeLinksElement *)soap_malloc(soap, sizeof(struct bmd230__manyCascadeLinksElement) * a->__size);
			for (i = 0; i < a->__size; i++)
				soap_default_bmd230__manyCascadeLinksElement(soap, a->__ptr+i);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_bmd230__manyCascadeLinksElement(soap, NULL, a->__ptr + i, "bmd230:manyCascadeLinksElement"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct bmd230__manyCascadeLinksElement *)soap_push_block(soap, NULL, sizeof(struct bmd230__manyCascadeLinksElement));
				if (!p)
					return NULL;
				soap_default_bmd230__manyCascadeLinksElement(soap, p);
				if (!soap_in_bmd230__manyCascadeLinksElement(soap, NULL, p, "bmd230:manyCascadeLinksElement"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct bmd230__manyCascadeLinksElement *)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__manyCascadeLinksResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__manyCascadeLinksResult, 0, sizeof(struct bmd230__manyCascadeLinksResult), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__manyCascadeLinksResult(struct soap *soap, const struct bmd230__manyCascadeLinksResult *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_bmd230__manyCascadeLinksResult);
	if (soap_out_bmd230__manyCascadeLinksResult(soap, tag?tag:"bmd230:manyCascadeLinksResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__manyCascadeLinksResult * SOAP_FMAC4 soap_get_bmd230__manyCascadeLinksResult(struct soap *soap, struct bmd230__manyCascadeLinksResult *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__manyCascadeLinksResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__manyCascadeLinksElement(struct soap *soap, struct bmd230__manyCascadeLinksElement *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->idsList = NULL;
	soap_default_long(soap, &a->errorCode);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__manyCascadeLinksElement(struct soap *soap, const struct bmd230__manyCascadeLinksElement *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTobmd230__idList(soap, &a->idsList);
	soap_embedded(soap, &a->errorCode, SOAP_TYPE_long);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__manyCascadeLinksElement(struct soap *soap, const char *tag, int id, const struct bmd230__manyCascadeLinksElement *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__manyCascadeLinksElement), type))
		return soap->error;
	if (soap_out_PointerTobmd230__idList(soap, "idsList", -1, &a->idsList, ""))
		return soap->error;
	if (soap_out_long(soap, "errorCode", -1, &a->errorCode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__manyCascadeLinksElement * SOAP_FMAC4 soap_in_bmd230__manyCascadeLinksElement(struct soap *soap, const char *tag, struct bmd230__manyCascadeLinksElement *a, const char *type)
{
	size_t soap_flag_idsList = 1;
	size_t soap_flag_errorCode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__manyCascadeLinksElement *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__manyCascadeLinksElement, sizeof(struct bmd230__manyCascadeLinksElement), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__manyCascadeLinksElement(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_idsList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobmd230__idList(soap, "idsList", &a->idsList, "bmd230:idList"))
				{	soap_flag_idsList--;
					continue;
				}
			if (soap_flag_errorCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_long(soap, "errorCode", &a->errorCode, "xsd:long"))
				{	soap_flag_errorCode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__manyCascadeLinksElement *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__manyCascadeLinksElement, 0, sizeof(struct bmd230__manyCascadeLinksElement), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_errorCode > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__manyCascadeLinksElement(struct soap *soap, const struct bmd230__manyCascadeLinksElement *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__manyCascadeLinksElement);
	if (soap_out_bmd230__manyCascadeLinksElement(soap, tag?tag:"bmd230:manyCascadeLinksElement", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__manyCascadeLinksElement * SOAP_FMAC4 soap_get_bmd230__manyCascadeLinksElement(struct soap *soap, struct bmd230__manyCascadeLinksElement *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__manyCascadeLinksElement(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__cascadeLinksInfo(struct soap *soap, struct bmd230__cascadeLinksInfo *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__cascadeLinksInfo(struct soap *soap, struct bmd230__cascadeLinksInfo const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_bmd230__cascadeLinksInfo))
		for (i = 0; i < a->__size; i++)
		{	soap_embedded(soap, a->__ptr + i, SOAP_TYPE_bmd230__singleCascadeLinkInfo);
			soap_serialize_bmd230__singleCascadeLinkInfo(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__cascadeLinksInfo(struct soap *soap, const char *tag, int id, const struct bmd230__cascadeLinksInfo *a, const char *type)
{
	int i, n = a->__size;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_bmd230__cascadeLinksInfo);
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap_out_bmd230__singleCascadeLinkInfo(soap, "item", -1, &a->__ptr[i], "");
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__cascadeLinksInfo * SOAP_FMAC4 soap_in_bmd230__cascadeLinksInfo(struct soap *soap, const char *tag, struct bmd230__cascadeLinksInfo *a, const char *type)
{	int i, j;
	struct bmd230__singleCascadeLinkInfo *p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_array(soap, "bmd230:singleCascadeLinkInfo") && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct bmd230__cascadeLinksInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__cascadeLinksInfo, sizeof(struct bmd230__cascadeLinksInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__cascadeLinksInfo(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct bmd230__singleCascadeLinkInfo *)soap_malloc(soap, sizeof(struct bmd230__singleCascadeLinkInfo) * a->__size);
			for (i = 0; i < a->__size; i++)
				soap_default_bmd230__singleCascadeLinkInfo(soap, a->__ptr+i);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_bmd230__singleCascadeLinkInfo(soap, NULL, a->__ptr + i, "bmd230:singleCascadeLinkInfo"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct bmd230__singleCascadeLinkInfo *)soap_push_block(soap, NULL, sizeof(struct bmd230__singleCascadeLinkInfo));
				if (!p)
					return NULL;
				soap_default_bmd230__singleCascadeLinkInfo(soap, p);
				if (!soap_in_bmd230__singleCascadeLinkInfo(soap, NULL, p, "bmd230:singleCascadeLinkInfo"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct bmd230__singleCascadeLinkInfo *)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__cascadeLinksInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__cascadeLinksInfo, 0, sizeof(struct bmd230__cascadeLinksInfo), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__cascadeLinksInfo(struct soap *soap, const struct bmd230__cascadeLinksInfo *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_bmd230__cascadeLinksInfo);
	if (soap_out_bmd230__cascadeLinksInfo(soap, tag?tag:"bmd230:cascadeLinksInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__cascadeLinksInfo * SOAP_FMAC4 soap_get_bmd230__cascadeLinksInfo(struct soap *soap, struct bmd230__cascadeLinksInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__cascadeLinksInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__singleCascadeLinkInfo(struct soap *soap, struct bmd230__singleCascadeLinkInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->linkInfo = NULL;
	soap_default_long(soap, &a->correspondingFilesMaxLevel);
	soap_default_visibilityType_t(soap, &a->visible);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__singleCascadeLinkInfo(struct soap *soap, const struct bmd230__singleCascadeLinkInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTobmd230__singleLinkInfo(soap, &a->linkInfo);
	soap_embedded(soap, &a->correspondingFilesMaxLevel, SOAP_TYPE_long);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__singleCascadeLinkInfo(struct soap *soap, const char *tag, int id, const struct bmd230__singleCascadeLinkInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__singleCascadeLinkInfo), type))
		return soap->error;
	if (soap_out_PointerTobmd230__singleLinkInfo(soap, "linkInfo", -1, &a->linkInfo, ""))
		return soap->error;
	if (soap_out_long(soap, "correspondingFilesMaxLevel", -1, &a->correspondingFilesMaxLevel, ""))
		return soap->error;
	if (soap_out_visibilityType_t(soap, "visible", -1, &a->visible, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__singleCascadeLinkInfo * SOAP_FMAC4 soap_in_bmd230__singleCascadeLinkInfo(struct soap *soap, const char *tag, struct bmd230__singleCascadeLinkInfo *a, const char *type)
{
	size_t soap_flag_linkInfo = 1;
	size_t soap_flag_correspondingFilesMaxLevel = 1;
	size_t soap_flag_visible = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__singleCascadeLinkInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__singleCascadeLinkInfo, sizeof(struct bmd230__singleCascadeLinkInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__singleCascadeLinkInfo(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_linkInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobmd230__singleLinkInfo(soap, "linkInfo", &a->linkInfo, "bmd230:singleLinkInfo"))
				{	soap_flag_linkInfo--;
					continue;
				}
			if (soap_flag_correspondingFilesMaxLevel && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_long(soap, "correspondingFilesMaxLevel", &a->correspondingFilesMaxLevel, "xsd:long"))
				{	soap_flag_correspondingFilesMaxLevel--;
					continue;
				}
			if (soap_flag_visible && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_visibilityType_t(soap, "visible", &a->visible, "visibilityType-t"))
				{	soap_flag_visible--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__singleCascadeLinkInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__singleCascadeLinkInfo, 0, sizeof(struct bmd230__singleCascadeLinkInfo), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_correspondingFilesMaxLevel > 0 || soap_flag_visible > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__singleCascadeLinkInfo(struct soap *soap, const struct bmd230__singleCascadeLinkInfo *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__singleCascadeLinkInfo);
	if (soap_out_bmd230__singleCascadeLinkInfo(soap, tag?tag:"bmd230:singleCascadeLinkInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__singleCascadeLinkInfo * SOAP_FMAC4 soap_get_bmd230__singleCascadeLinkInfo(struct soap *soap, struct bmd230__singleCascadeLinkInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__singleCascadeLinkInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__linksInfo(struct soap *soap, struct bmd230__linksInfo *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__linksInfo(struct soap *soap, struct bmd230__linksInfo const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_bmd230__linksInfo))
		for (i = 0; i < a->__size; i++)
		{	soap_embedded(soap, a->__ptr + i, SOAP_TYPE_bmd230__singleLinkInfo);
			soap_serialize_bmd230__singleLinkInfo(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__linksInfo(struct soap *soap, const char *tag, int id, const struct bmd230__linksInfo *a, const char *type)
{
	int i, n = a->__size;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_bmd230__linksInfo);
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap_out_bmd230__singleLinkInfo(soap, "item", -1, &a->__ptr[i], "");
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__linksInfo * SOAP_FMAC4 soap_in_bmd230__linksInfo(struct soap *soap, const char *tag, struct bmd230__linksInfo *a, const char *type)
{	int i, j;
	struct bmd230__singleLinkInfo *p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_array(soap, "bmd230:singleLinkInfo") && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct bmd230__linksInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__linksInfo, sizeof(struct bmd230__linksInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__linksInfo(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct bmd230__singleLinkInfo *)soap_malloc(soap, sizeof(struct bmd230__singleLinkInfo) * a->__size);
			for (i = 0; i < a->__size; i++)
				soap_default_bmd230__singleLinkInfo(soap, a->__ptr+i);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_bmd230__singleLinkInfo(soap, NULL, a->__ptr + i, "bmd230:singleLinkInfo"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct bmd230__singleLinkInfo *)soap_push_block(soap, NULL, sizeof(struct bmd230__singleLinkInfo));
				if (!p)
					return NULL;
				soap_default_bmd230__singleLinkInfo(soap, p);
				if (!soap_in_bmd230__singleLinkInfo(soap, NULL, p, "bmd230:singleLinkInfo"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct bmd230__singleLinkInfo *)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__linksInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__linksInfo, 0, sizeof(struct bmd230__linksInfo), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__linksInfo(struct soap *soap, const struct bmd230__linksInfo *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_bmd230__linksInfo);
	if (soap_out_bmd230__linksInfo(soap, tag?tag:"bmd230:linksInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__linksInfo * SOAP_FMAC4 soap_get_bmd230__linksInfo(struct soap *soap, struct bmd230__linksInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__linksInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__DateTime(struct soap *soap, struct bmd230__DateTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_long(soap, &a->year);
	soap_default_long(soap, &a->month);
	soap_default_long(soap, &a->day);
	soap_default_long(soap, &a->hour);
	soap_default_long(soap, &a->minute);
	soap_default_long(soap, &a->second);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__DateTime(struct soap *soap, const struct bmd230__DateTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->year, SOAP_TYPE_long);
	soap_embedded(soap, &a->month, SOAP_TYPE_long);
	soap_embedded(soap, &a->day, SOAP_TYPE_long);
	soap_embedded(soap, &a->hour, SOAP_TYPE_long);
	soap_embedded(soap, &a->minute, SOAP_TYPE_long);
	soap_embedded(soap, &a->second, SOAP_TYPE_long);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__DateTime(struct soap *soap, const char *tag, int id, const struct bmd230__DateTime *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__DateTime), type))
		return soap->error;
	if (soap_out_long(soap, "year", -1, &a->year, ""))
		return soap->error;
	if (soap_out_long(soap, "month", -1, &a->month, ""))
		return soap->error;
	if (soap_out_long(soap, "day", -1, &a->day, ""))
		return soap->error;
	if (soap_out_long(soap, "hour", -1, &a->hour, ""))
		return soap->error;
	if (soap_out_long(soap, "minute", -1, &a->minute, ""))
		return soap->error;
	if (soap_out_long(soap, "second", -1, &a->second, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__DateTime * SOAP_FMAC4 soap_in_bmd230__DateTime(struct soap *soap, const char *tag, struct bmd230__DateTime *a, const char *type)
{
	size_t soap_flag_year = 1;
	size_t soap_flag_month = 1;
	size_t soap_flag_day = 1;
	size_t soap_flag_hour = 1;
	size_t soap_flag_minute = 1;
	size_t soap_flag_second = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__DateTime *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__DateTime, sizeof(struct bmd230__DateTime), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__DateTime(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_year && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_long(soap, "year", &a->year, "xsd:long"))
				{	soap_flag_year--;
					continue;
				}
			if (soap_flag_month && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_long(soap, "month", &a->month, "xsd:long"))
				{	soap_flag_month--;
					continue;
				}
			if (soap_flag_day && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_long(soap, "day", &a->day, "xsd:long"))
				{	soap_flag_day--;
					continue;
				}
			if (soap_flag_hour && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_long(soap, "hour", &a->hour, "xsd:long"))
				{	soap_flag_hour--;
					continue;
				}
			if (soap_flag_minute && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_long(soap, "minute", &a->minute, "xsd:long"))
				{	soap_flag_minute--;
					continue;
				}
			if (soap_flag_second && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_long(soap, "second", &a->second, "xsd:long"))
				{	soap_flag_second--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__DateTime *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__DateTime, 0, sizeof(struct bmd230__DateTime), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_year > 0 || soap_flag_month > 0 || soap_flag_day > 0 || soap_flag_hour > 0 || soap_flag_minute > 0 || soap_flag_second > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__DateTime(struct soap *soap, const struct bmd230__DateTime *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__DateTime);
	if (soap_out_bmd230__DateTime(soap, tag?tag:"bmd230:DateTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__DateTime * SOAP_FMAC4 soap_get_bmd230__DateTime(struct soap *soap, struct bmd230__DateTime *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__DateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__singleLinkInfo(struct soap *soap, struct bmd230__singleLinkInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->pointingId);
	soap_default_string(soap, &a->ownerIdentityId);
	soap_default_string(soap, &a->ownerCertificateId);
	soap_default_string(soap, &a->ownerGroupId);
	soap_default_string(soap, &a->linkName);
	soap_default_string(soap, &a->linkDescription);
	soap_default_grantingType_e(soap, &a->granting);
	a->expirationDate = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__singleLinkInfo(struct soap *soap, const struct bmd230__singleLinkInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->pointingId);
	soap_serialize_string(soap, &a->ownerIdentityId);
	soap_serialize_string(soap, &a->ownerCertificateId);
	soap_serialize_string(soap, &a->ownerGroupId);
	soap_serialize_string(soap, &a->linkName);
	soap_serialize_string(soap, &a->linkDescription);
	soap_serialize_PointerTobmd230__DateTime(soap, &a->expirationDate);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__singleLinkInfo(struct soap *soap, const char *tag, int id, const struct bmd230__singleLinkInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__singleLinkInfo), type))
		return soap->error;
	if (soap_out_string(soap, "pointingId", -1, &a->pointingId, ""))
		return soap->error;
	if (soap_out_string(soap, "ownerIdentityId", -1, &a->ownerIdentityId, ""))
		return soap->error;
	if (soap_out_string(soap, "ownerCertificateId", -1, &a->ownerCertificateId, ""))
		return soap->error;
	if (soap_out_string(soap, "ownerGroupId", -1, &a->ownerGroupId, ""))
		return soap->error;
	if (soap_out_string(soap, "linkName", -1, &a->linkName, ""))
		return soap->error;
	if (soap_out_string(soap, "linkDescription", -1, &a->linkDescription, ""))
		return soap->error;
	if (soap_out_grantingType_e(soap, "granting", -1, &a->granting, ""))
		return soap->error;
	if (soap_out_PointerTobmd230__DateTime(soap, "expirationDate", -1, &a->expirationDate, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__singleLinkInfo * SOAP_FMAC4 soap_in_bmd230__singleLinkInfo(struct soap *soap, const char *tag, struct bmd230__singleLinkInfo *a, const char *type)
{
	size_t soap_flag_pointingId = 1;
	size_t soap_flag_ownerIdentityId = 1;
	size_t soap_flag_ownerCertificateId = 1;
	size_t soap_flag_ownerGroupId = 1;
	size_t soap_flag_linkName = 1;
	size_t soap_flag_linkDescription = 1;
	size_t soap_flag_granting = 1;
	size_t soap_flag_expirationDate = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__singleLinkInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__singleLinkInfo, sizeof(struct bmd230__singleLinkInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__singleLinkInfo(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pointingId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "pointingId", &a->pointingId, "xsd:string"))
				{	soap_flag_pointingId--;
					continue;
				}
			if (soap_flag_ownerIdentityId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ownerIdentityId", &a->ownerIdentityId, "xsd:string"))
				{	soap_flag_ownerIdentityId--;
					continue;
				}
			if (soap_flag_ownerCertificateId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ownerCertificateId", &a->ownerCertificateId, "xsd:string"))
				{	soap_flag_ownerCertificateId--;
					continue;
				}
			if (soap_flag_ownerGroupId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ownerGroupId", &a->ownerGroupId, "xsd:string"))
				{	soap_flag_ownerGroupId--;
					continue;
				}
			if (soap_flag_linkName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "linkName", &a->linkName, "xsd:string"))
				{	soap_flag_linkName--;
					continue;
				}
			if (soap_flag_linkDescription && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "linkDescription", &a->linkDescription, "xsd:string"))
				{	soap_flag_linkDescription--;
					continue;
				}
			if (soap_flag_granting && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_grantingType_e(soap, "granting", &a->granting, "grantingType-e"))
				{	soap_flag_granting--;
					continue;
				}
			if (soap_flag_expirationDate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobmd230__DateTime(soap, "expirationDate", &a->expirationDate, "bmd230:DateTime"))
				{	soap_flag_expirationDate--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__singleLinkInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__singleLinkInfo, 0, sizeof(struct bmd230__singleLinkInfo), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_granting > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__singleLinkInfo(struct soap *soap, const struct bmd230__singleLinkInfo *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__singleLinkInfo);
	if (soap_out_bmd230__singleLinkInfo(soap, tag?tag:"bmd230:singleLinkInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__singleLinkInfo * SOAP_FMAC4 soap_get_bmd230__singleLinkInfo(struct soap *soap, struct bmd230__singleLinkInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__singleLinkInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__securityInfo(struct soap *soap, struct bmd230__securityInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->secCategoryInfo = NULL;
	a->secLevelInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__securityInfo(struct soap *soap, const struct bmd230__securityInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTobmd230__secCategoryInfo(soap, &a->secCategoryInfo);
	soap_serialize_PointerTobmd230__secLevelInfo(soap, &a->secLevelInfo);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__securityInfo(struct soap *soap, const char *tag, int id, const struct bmd230__securityInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__securityInfo), type))
		return soap->error;
	if (soap_out_PointerTobmd230__secCategoryInfo(soap, "secCategoryInfo", -1, &a->secCategoryInfo, ""))
		return soap->error;
	if (soap_out_PointerTobmd230__secLevelInfo(soap, "secLevelInfo", -1, &a->secLevelInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__securityInfo * SOAP_FMAC4 soap_in_bmd230__securityInfo(struct soap *soap, const char *tag, struct bmd230__securityInfo *a, const char *type)
{
	size_t soap_flag_secCategoryInfo = 1;
	size_t soap_flag_secLevelInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__securityInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__securityInfo, sizeof(struct bmd230__securityInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__securityInfo(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_secCategoryInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobmd230__secCategoryInfo(soap, "secCategoryInfo", &a->secCategoryInfo, "bmd230:secCategoryInfo"))
				{	soap_flag_secCategoryInfo--;
					continue;
				}
			if (soap_flag_secLevelInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobmd230__secLevelInfo(soap, "secLevelInfo", &a->secLevelInfo, "bmd230:secLevelInfo"))
				{	soap_flag_secLevelInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__securityInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__securityInfo, 0, sizeof(struct bmd230__securityInfo), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__securityInfo(struct soap *soap, const struct bmd230__securityInfo *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__securityInfo);
	if (soap_out_bmd230__securityInfo(soap, tag?tag:"bmd230:securityInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__securityInfo * SOAP_FMAC4 soap_get_bmd230__securityInfo(struct soap *soap, struct bmd230__securityInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__securityInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__secLevelInfo(struct soap *soap, struct bmd230__secLevelInfo *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__secLevelInfo(struct soap *soap, struct bmd230__secLevelInfo const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_bmd230__secLevelInfo))
		for (i = 0; i < a->__size; i++)
		{	soap_embedded(soap, a->__ptr + i, SOAP_TYPE_bmd230__singleSecLevelInfo);
			soap_serialize_bmd230__singleSecLevelInfo(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__secLevelInfo(struct soap *soap, const char *tag, int id, const struct bmd230__secLevelInfo *a, const char *type)
{
	int i, n = a->__size;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_bmd230__secLevelInfo);
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap_out_bmd230__singleSecLevelInfo(soap, "item", -1, &a->__ptr[i], "");
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__secLevelInfo * SOAP_FMAC4 soap_in_bmd230__secLevelInfo(struct soap *soap, const char *tag, struct bmd230__secLevelInfo *a, const char *type)
{	int i, j;
	struct bmd230__singleSecLevelInfo *p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_array(soap, "bmd230:singleSecLevelInfo") && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct bmd230__secLevelInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__secLevelInfo, sizeof(struct bmd230__secLevelInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__secLevelInfo(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct bmd230__singleSecLevelInfo *)soap_malloc(soap, sizeof(struct bmd230__singleSecLevelInfo) * a->__size);
			for (i = 0; i < a->__size; i++)
				soap_default_bmd230__singleSecLevelInfo(soap, a->__ptr+i);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_bmd230__singleSecLevelInfo(soap, NULL, a->__ptr + i, "bmd230:singleSecLevelInfo"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct bmd230__singleSecLevelInfo *)soap_push_block(soap, NULL, sizeof(struct bmd230__singleSecLevelInfo));
				if (!p)
					return NULL;
				soap_default_bmd230__singleSecLevelInfo(soap, p);
				if (!soap_in_bmd230__singleSecLevelInfo(soap, NULL, p, "bmd230:singleSecLevelInfo"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct bmd230__singleSecLevelInfo *)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__secLevelInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__secLevelInfo, 0, sizeof(struct bmd230__secLevelInfo), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__secLevelInfo(struct soap *soap, const struct bmd230__secLevelInfo *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_bmd230__secLevelInfo);
	if (soap_out_bmd230__secLevelInfo(soap, tag?tag:"bmd230:secLevelInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__secLevelInfo * SOAP_FMAC4 soap_get_bmd230__secLevelInfo(struct soap *soap, struct bmd230__secLevelInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__secLevelInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__singleSecLevelInfo(struct soap *soap, struct bmd230__singleSecLevelInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->secLevelName);
	soap_default_xsd__string(soap, &a->secLevelId);
	soap_default_xsd__string(soap, &a->secLevelPriority);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__singleSecLevelInfo(struct soap *soap, const struct bmd230__singleSecLevelInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__string(soap, &a->secLevelName);
	soap_serialize_xsd__string(soap, &a->secLevelId);
	soap_serialize_xsd__string(soap, &a->secLevelPriority);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__singleSecLevelInfo(struct soap *soap, const char *tag, int id, const struct bmd230__singleSecLevelInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__singleSecLevelInfo), type))
		return soap->error;
	if (soap_out_xsd__string(soap, "secLevelName", -1, &a->secLevelName, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "secLevelId", -1, &a->secLevelId, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "secLevelPriority", -1, &a->secLevelPriority, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__singleSecLevelInfo * SOAP_FMAC4 soap_in_bmd230__singleSecLevelInfo(struct soap *soap, const char *tag, struct bmd230__singleSecLevelInfo *a, const char *type)
{
	size_t soap_flag_secLevelName = 1;
	size_t soap_flag_secLevelId = 1;
	size_t soap_flag_secLevelPriority = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__singleSecLevelInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__singleSecLevelInfo, sizeof(struct bmd230__singleSecLevelInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__singleSecLevelInfo(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_secLevelName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "secLevelName", &a->secLevelName, "xsd:string"))
				{	soap_flag_secLevelName--;
					continue;
				}
			if (soap_flag_secLevelId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "secLevelId", &a->secLevelId, "xsd:string"))
				{	soap_flag_secLevelId--;
					continue;
				}
			if (soap_flag_secLevelPriority && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "secLevelPriority", &a->secLevelPriority, "xsd:string"))
				{	soap_flag_secLevelPriority--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__singleSecLevelInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__singleSecLevelInfo, 0, sizeof(struct bmd230__singleSecLevelInfo), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__singleSecLevelInfo(struct soap *soap, const struct bmd230__singleSecLevelInfo *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__singleSecLevelInfo);
	if (soap_out_bmd230__singleSecLevelInfo(soap, tag?tag:"bmd230:singleSecLevelInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__singleSecLevelInfo * SOAP_FMAC4 soap_get_bmd230__singleSecLevelInfo(struct soap *soap, struct bmd230__singleSecLevelInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__singleSecLevelInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__secCategoryInfo(struct soap *soap, struct bmd230__secCategoryInfo *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__secCategoryInfo(struct soap *soap, struct bmd230__secCategoryInfo const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_bmd230__secCategoryInfo))
		for (i = 0; i < a->__size; i++)
		{	soap_embedded(soap, a->__ptr + i, SOAP_TYPE_bmd230__singleSecCategoryInfo);
			soap_serialize_bmd230__singleSecCategoryInfo(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__secCategoryInfo(struct soap *soap, const char *tag, int id, const struct bmd230__secCategoryInfo *a, const char *type)
{
	int i, n = a->__size;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_bmd230__secCategoryInfo);
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap_out_bmd230__singleSecCategoryInfo(soap, "item", -1, &a->__ptr[i], "");
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__secCategoryInfo * SOAP_FMAC4 soap_in_bmd230__secCategoryInfo(struct soap *soap, const char *tag, struct bmd230__secCategoryInfo *a, const char *type)
{	int i, j;
	struct bmd230__singleSecCategoryInfo *p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_array(soap, "bmd230:singleSecCategoryInfo") && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct bmd230__secCategoryInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__secCategoryInfo, sizeof(struct bmd230__secCategoryInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__secCategoryInfo(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct bmd230__singleSecCategoryInfo *)soap_malloc(soap, sizeof(struct bmd230__singleSecCategoryInfo) * a->__size);
			for (i = 0; i < a->__size; i++)
				soap_default_bmd230__singleSecCategoryInfo(soap, a->__ptr+i);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_bmd230__singleSecCategoryInfo(soap, NULL, a->__ptr + i, "bmd230:singleSecCategoryInfo"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct bmd230__singleSecCategoryInfo *)soap_push_block(soap, NULL, sizeof(struct bmd230__singleSecCategoryInfo));
				if (!p)
					return NULL;
				soap_default_bmd230__singleSecCategoryInfo(soap, p);
				if (!soap_in_bmd230__singleSecCategoryInfo(soap, NULL, p, "bmd230:singleSecCategoryInfo"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct bmd230__singleSecCategoryInfo *)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__secCategoryInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__secCategoryInfo, 0, sizeof(struct bmd230__secCategoryInfo), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__secCategoryInfo(struct soap *soap, const struct bmd230__secCategoryInfo *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_bmd230__secCategoryInfo);
	if (soap_out_bmd230__secCategoryInfo(soap, tag?tag:"bmd230:secCategoryInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__secCategoryInfo * SOAP_FMAC4 soap_get_bmd230__secCategoryInfo(struct soap *soap, struct bmd230__secCategoryInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__secCategoryInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__singleSecCategoryInfo(struct soap *soap, struct bmd230__singleSecCategoryInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->secCategoryName);
	soap_default_xsd__string(soap, &a->secCategoryId);
	a->secCategoryParentNames = NULL;
	a->secCategoryChildNames = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__singleSecCategoryInfo(struct soap *soap, const struct bmd230__singleSecCategoryInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__string(soap, &a->secCategoryName);
	soap_serialize_xsd__string(soap, &a->secCategoryId);
	soap_serialize_PointerTobmd230__stringList(soap, &a->secCategoryParentNames);
	soap_serialize_PointerTobmd230__stringList(soap, &a->secCategoryChildNames);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__singleSecCategoryInfo(struct soap *soap, const char *tag, int id, const struct bmd230__singleSecCategoryInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__singleSecCategoryInfo), type))
		return soap->error;
	if (soap_out_xsd__string(soap, "secCategoryName", -1, &a->secCategoryName, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "secCategoryId", -1, &a->secCategoryId, ""))
		return soap->error;
	if (soap_out_PointerTobmd230__stringList(soap, "secCategoryParentNames", -1, &a->secCategoryParentNames, ""))
		return soap->error;
	if (soap_out_PointerTobmd230__stringList(soap, "secCategoryChildNames", -1, &a->secCategoryChildNames, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__singleSecCategoryInfo * SOAP_FMAC4 soap_in_bmd230__singleSecCategoryInfo(struct soap *soap, const char *tag, struct bmd230__singleSecCategoryInfo *a, const char *type)
{
	size_t soap_flag_secCategoryName = 1;
	size_t soap_flag_secCategoryId = 1;
	size_t soap_flag_secCategoryParentNames = 1;
	size_t soap_flag_secCategoryChildNames = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__singleSecCategoryInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__singleSecCategoryInfo, sizeof(struct bmd230__singleSecCategoryInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__singleSecCategoryInfo(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_secCategoryName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "secCategoryName", &a->secCategoryName, "xsd:string"))
				{	soap_flag_secCategoryName--;
					continue;
				}
			if (soap_flag_secCategoryId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "secCategoryId", &a->secCategoryId, "xsd:string"))
				{	soap_flag_secCategoryId--;
					continue;
				}
			if (soap_flag_secCategoryParentNames && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobmd230__stringList(soap, "secCategoryParentNames", &a->secCategoryParentNames, "bmd230:stringList"))
				{	soap_flag_secCategoryParentNames--;
					continue;
				}
			if (soap_flag_secCategoryChildNames && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobmd230__stringList(soap, "secCategoryChildNames", &a->secCategoryChildNames, "bmd230:stringList"))
				{	soap_flag_secCategoryChildNames--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__singleSecCategoryInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__singleSecCategoryInfo, 0, sizeof(struct bmd230__singleSecCategoryInfo), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__singleSecCategoryInfo(struct soap *soap, const struct bmd230__singleSecCategoryInfo *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__singleSecCategoryInfo);
	if (soap_out_bmd230__singleSecCategoryInfo(soap, tag?tag:"bmd230:singleSecCategoryInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__singleSecCategoryInfo * SOAP_FMAC4 soap_get_bmd230__singleSecCategoryInfo(struct soap *soap, struct bmd230__singleSecCategoryInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__singleSecCategoryInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__classInfo(struct soap *soap, struct bmd230__classInfo *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__classInfo(struct soap *soap, struct bmd230__classInfo const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_bmd230__classInfo))
		for (i = 0; i < a->__size; i++)
		{	soap_embedded(soap, a->__ptr + i, SOAP_TYPE_bmd230__singleClassInfo);
			soap_serialize_bmd230__singleClassInfo(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__classInfo(struct soap *soap, const char *tag, int id, const struct bmd230__classInfo *a, const char *type)
{
	int i, n = a->__size;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_bmd230__classInfo);
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap_out_bmd230__singleClassInfo(soap, "item", -1, &a->__ptr[i], "");
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__classInfo * SOAP_FMAC4 soap_in_bmd230__classInfo(struct soap *soap, const char *tag, struct bmd230__classInfo *a, const char *type)
{	int i, j;
	struct bmd230__singleClassInfo *p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_array(soap, "bmd230:singleClassInfo") && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct bmd230__classInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__classInfo, sizeof(struct bmd230__classInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__classInfo(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct bmd230__singleClassInfo *)soap_malloc(soap, sizeof(struct bmd230__singleClassInfo) * a->__size);
			for (i = 0; i < a->__size; i++)
				soap_default_bmd230__singleClassInfo(soap, a->__ptr+i);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_bmd230__singleClassInfo(soap, NULL, a->__ptr + i, "bmd230:singleClassInfo"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct bmd230__singleClassInfo *)soap_push_block(soap, NULL, sizeof(struct bmd230__singleClassInfo));
				if (!p)
					return NULL;
				soap_default_bmd230__singleClassInfo(soap, p);
				if (!soap_in_bmd230__singleClassInfo(soap, NULL, p, "bmd230:singleClassInfo"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct bmd230__singleClassInfo *)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__classInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__classInfo, 0, sizeof(struct bmd230__classInfo), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__classInfo(struct soap *soap, const struct bmd230__classInfo *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_bmd230__classInfo);
	if (soap_out_bmd230__classInfo(soap, tag?tag:"bmd230:classInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__classInfo * SOAP_FMAC4 soap_get_bmd230__classInfo(struct soap *soap, struct bmd230__classInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__classInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__singleClassInfo(struct soap *soap, struct bmd230__singleClassInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->classId);
	soap_default_xsd__string(soap, &a->className);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__singleClassInfo(struct soap *soap, const struct bmd230__singleClassInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__string(soap, &a->classId);
	soap_serialize_xsd__string(soap, &a->className);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__singleClassInfo(struct soap *soap, const char *tag, int id, const struct bmd230__singleClassInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__singleClassInfo), type))
		return soap->error;
	if (soap_out_xsd__string(soap, "classId", -1, &a->classId, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "className", -1, &a->className, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__singleClassInfo * SOAP_FMAC4 soap_in_bmd230__singleClassInfo(struct soap *soap, const char *tag, struct bmd230__singleClassInfo *a, const char *type)
{
	size_t soap_flag_classId = 1;
	size_t soap_flag_className = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__singleClassInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__singleClassInfo, sizeof(struct bmd230__singleClassInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__singleClassInfo(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_classId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "classId", &a->classId, "xsd:string"))
				{	soap_flag_classId--;
					continue;
				}
			if (soap_flag_className && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "className", &a->className, "xsd:string"))
				{	soap_flag_className--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__singleClassInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__singleClassInfo, 0, sizeof(struct bmd230__singleClassInfo), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__singleClassInfo(struct soap *soap, const struct bmd230__singleClassInfo *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__singleClassInfo);
	if (soap_out_bmd230__singleClassInfo(soap, tag?tag:"bmd230:singleClassInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__singleClassInfo * SOAP_FMAC4 soap_get_bmd230__singleClassInfo(struct soap *soap, struct bmd230__singleClassInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__singleClassInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__groupInfo(struct soap *soap, struct bmd230__groupInfo *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__groupInfo(struct soap *soap, struct bmd230__groupInfo const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_bmd230__groupInfo))
		for (i = 0; i < a->__size; i++)
		{	soap_embedded(soap, a->__ptr + i, SOAP_TYPE_bmd230__singleGroupInfo);
			soap_serialize_bmd230__singleGroupInfo(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__groupInfo(struct soap *soap, const char *tag, int id, const struct bmd230__groupInfo *a, const char *type)
{
	int i, n = a->__size;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_bmd230__groupInfo);
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap_out_bmd230__singleGroupInfo(soap, "item", -1, &a->__ptr[i], "");
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__groupInfo * SOAP_FMAC4 soap_in_bmd230__groupInfo(struct soap *soap, const char *tag, struct bmd230__groupInfo *a, const char *type)
{	int i, j;
	struct bmd230__singleGroupInfo *p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_array(soap, "bmd230:singleGroupInfo") && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct bmd230__groupInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__groupInfo, sizeof(struct bmd230__groupInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__groupInfo(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct bmd230__singleGroupInfo *)soap_malloc(soap, sizeof(struct bmd230__singleGroupInfo) * a->__size);
			for (i = 0; i < a->__size; i++)
				soap_default_bmd230__singleGroupInfo(soap, a->__ptr+i);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_bmd230__singleGroupInfo(soap, NULL, a->__ptr + i, "bmd230:singleGroupInfo"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct bmd230__singleGroupInfo *)soap_push_block(soap, NULL, sizeof(struct bmd230__singleGroupInfo));
				if (!p)
					return NULL;
				soap_default_bmd230__singleGroupInfo(soap, p);
				if (!soap_in_bmd230__singleGroupInfo(soap, NULL, p, "bmd230:singleGroupInfo"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct bmd230__singleGroupInfo *)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__groupInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__groupInfo, 0, sizeof(struct bmd230__groupInfo), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__groupInfo(struct soap *soap, const struct bmd230__groupInfo *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_bmd230__groupInfo);
	if (soap_out_bmd230__groupInfo(soap, tag?tag:"bmd230:groupInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__groupInfo * SOAP_FMAC4 soap_get_bmd230__groupInfo(struct soap *soap, struct bmd230__groupInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__groupInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__singleGroupInfo(struct soap *soap, struct bmd230__singleGroupInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->groupId);
	soap_default_xsd__string(soap, &a->groupName);
	a->groupParentNames = NULL;
	a->groupParentIds = NULL;
	a->groupChildNames = NULL;
	a->groupChildIds = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__singleGroupInfo(struct soap *soap, const struct bmd230__singleGroupInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__string(soap, &a->groupId);
	soap_serialize_xsd__string(soap, &a->groupName);
	soap_serialize_PointerTobmd230__stringList(soap, &a->groupParentNames);
	soap_serialize_PointerTobmd230__stringList(soap, &a->groupParentIds);
	soap_serialize_PointerTobmd230__stringList(soap, &a->groupChildNames);
	soap_serialize_PointerTobmd230__stringList(soap, &a->groupChildIds);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__singleGroupInfo(struct soap *soap, const char *tag, int id, const struct bmd230__singleGroupInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__singleGroupInfo), type))
		return soap->error;
	if (soap_out_xsd__string(soap, "groupId", -1, &a->groupId, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "groupName", -1, &a->groupName, ""))
		return soap->error;
	if (soap_out_PointerTobmd230__stringList(soap, "groupParentNames", -1, &a->groupParentNames, ""))
		return soap->error;
	if (soap_out_PointerTobmd230__stringList(soap, "groupParentIds", -1, &a->groupParentIds, ""))
		return soap->error;
	if (soap_out_PointerTobmd230__stringList(soap, "groupChildNames", -1, &a->groupChildNames, ""))
		return soap->error;
	if (soap_out_PointerTobmd230__stringList(soap, "groupChildIds", -1, &a->groupChildIds, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__singleGroupInfo * SOAP_FMAC4 soap_in_bmd230__singleGroupInfo(struct soap *soap, const char *tag, struct bmd230__singleGroupInfo *a, const char *type)
{
	size_t soap_flag_groupId = 1;
	size_t soap_flag_groupName = 1;
	size_t soap_flag_groupParentNames = 1;
	size_t soap_flag_groupParentIds = 1;
	size_t soap_flag_groupChildNames = 1;
	size_t soap_flag_groupChildIds = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__singleGroupInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__singleGroupInfo, sizeof(struct bmd230__singleGroupInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__singleGroupInfo(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_groupId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "groupId", &a->groupId, "xsd:string"))
				{	soap_flag_groupId--;
					continue;
				}
			if (soap_flag_groupName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "groupName", &a->groupName, "xsd:string"))
				{	soap_flag_groupName--;
					continue;
				}
			if (soap_flag_groupParentNames && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobmd230__stringList(soap, "groupParentNames", &a->groupParentNames, "bmd230:stringList"))
				{	soap_flag_groupParentNames--;
					continue;
				}
			if (soap_flag_groupParentIds && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobmd230__stringList(soap, "groupParentIds", &a->groupParentIds, "bmd230:stringList"))
				{	soap_flag_groupParentIds--;
					continue;
				}
			if (soap_flag_groupChildNames && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobmd230__stringList(soap, "groupChildNames", &a->groupChildNames, "bmd230:stringList"))
				{	soap_flag_groupChildNames--;
					continue;
				}
			if (soap_flag_groupChildIds && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobmd230__stringList(soap, "groupChildIds", &a->groupChildIds, "bmd230:stringList"))
				{	soap_flag_groupChildIds--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__singleGroupInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__singleGroupInfo, 0, sizeof(struct bmd230__singleGroupInfo), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__singleGroupInfo(struct soap *soap, const struct bmd230__singleGroupInfo *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__singleGroupInfo);
	if (soap_out_bmd230__singleGroupInfo(soap, tag?tag:"bmd230:singleGroupInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__singleGroupInfo * SOAP_FMAC4 soap_get_bmd230__singleGroupInfo(struct soap *soap, struct bmd230__singleGroupInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__singleGroupInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__userRoleInfo(struct soap *soap, struct bmd230__userRoleInfo *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__userRoleInfo(struct soap *soap, struct bmd230__userRoleInfo const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_bmd230__userRoleInfo))
		for (i = 0; i < a->__size; i++)
		{	soap_embedded(soap, a->__ptr + i, SOAP_TYPE_bmd230__singleRoleInfo);
			soap_serialize_bmd230__singleRoleInfo(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__userRoleInfo(struct soap *soap, const char *tag, int id, const struct bmd230__userRoleInfo *a, const char *type)
{
	int i, n = a->__size;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_bmd230__userRoleInfo);
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap_out_bmd230__singleRoleInfo(soap, "item", -1, &a->__ptr[i], "");
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__userRoleInfo * SOAP_FMAC4 soap_in_bmd230__userRoleInfo(struct soap *soap, const char *tag, struct bmd230__userRoleInfo *a, const char *type)
{	int i, j;
	struct bmd230__singleRoleInfo *p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_array(soap, "bmd230:singleRoleInfo") && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct bmd230__userRoleInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__userRoleInfo, sizeof(struct bmd230__userRoleInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__userRoleInfo(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct bmd230__singleRoleInfo *)soap_malloc(soap, sizeof(struct bmd230__singleRoleInfo) * a->__size);
			for (i = 0; i < a->__size; i++)
				soap_default_bmd230__singleRoleInfo(soap, a->__ptr+i);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_bmd230__singleRoleInfo(soap, NULL, a->__ptr + i, "bmd230:singleRoleInfo"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct bmd230__singleRoleInfo *)soap_push_block(soap, NULL, sizeof(struct bmd230__singleRoleInfo));
				if (!p)
					return NULL;
				soap_default_bmd230__singleRoleInfo(soap, p);
				if (!soap_in_bmd230__singleRoleInfo(soap, NULL, p, "bmd230:singleRoleInfo"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct bmd230__singleRoleInfo *)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__userRoleInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__userRoleInfo, 0, sizeof(struct bmd230__userRoleInfo), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__userRoleInfo(struct soap *soap, const struct bmd230__userRoleInfo *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_bmd230__userRoleInfo);
	if (soap_out_bmd230__userRoleInfo(soap, tag?tag:"bmd230:userRoleInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__userRoleInfo * SOAP_FMAC4 soap_get_bmd230__userRoleInfo(struct soap *soap, struct bmd230__userRoleInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__userRoleInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__singleRoleInfo(struct soap *soap, struct bmd230__singleRoleInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->roleId);
	soap_default_xsd__string(soap, &a->roleName);
	a->roleActionList = NULL;
	a->roleRightsOids = NULL;
	a->roleRightsCodes = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__singleRoleInfo(struct soap *soap, const struct bmd230__singleRoleInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__string(soap, &a->roleId);
	soap_serialize_xsd__string(soap, &a->roleName);
	soap_serialize_PointerTobmd230__stringList(soap, &a->roleActionList);
	soap_serialize_PointerTobmd230__stringList(soap, &a->roleRightsOids);
	soap_serialize_PointerTobmd230__stringList(soap, &a->roleRightsCodes);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__singleRoleInfo(struct soap *soap, const char *tag, int id, const struct bmd230__singleRoleInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__singleRoleInfo), type))
		return soap->error;
	if (soap_out_xsd__string(soap, "roleId", -1, &a->roleId, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "roleName", -1, &a->roleName, ""))
		return soap->error;
	if (soap_out_PointerTobmd230__stringList(soap, "roleActionList", -1, &a->roleActionList, ""))
		return soap->error;
	if (soap_out_PointerTobmd230__stringList(soap, "roleRightsOids", -1, &a->roleRightsOids, ""))
		return soap->error;
	if (soap_out_PointerTobmd230__stringList(soap, "roleRightsCodes", -1, &a->roleRightsCodes, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__singleRoleInfo * SOAP_FMAC4 soap_in_bmd230__singleRoleInfo(struct soap *soap, const char *tag, struct bmd230__singleRoleInfo *a, const char *type)
{
	size_t soap_flag_roleId = 1;
	size_t soap_flag_roleName = 1;
	size_t soap_flag_roleActionList = 1;
	size_t soap_flag_roleRightsOids = 1;
	size_t soap_flag_roleRightsCodes = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__singleRoleInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__singleRoleInfo, sizeof(struct bmd230__singleRoleInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__singleRoleInfo(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_roleId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "roleId", &a->roleId, "xsd:string"))
				{	soap_flag_roleId--;
					continue;
				}
			if (soap_flag_roleName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "roleName", &a->roleName, "xsd:string"))
				{	soap_flag_roleName--;
					continue;
				}
			if (soap_flag_roleActionList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobmd230__stringList(soap, "roleActionList", &a->roleActionList, "bmd230:stringList"))
				{	soap_flag_roleActionList--;
					continue;
				}
			if (soap_flag_roleRightsOids && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobmd230__stringList(soap, "roleRightsOids", &a->roleRightsOids, "bmd230:stringList"))
				{	soap_flag_roleRightsOids--;
					continue;
				}
			if (soap_flag_roleRightsCodes && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobmd230__stringList(soap, "roleRightsCodes", &a->roleRightsCodes, "bmd230:stringList"))
				{	soap_flag_roleRightsCodes--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__singleRoleInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__singleRoleInfo, 0, sizeof(struct bmd230__singleRoleInfo), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__singleRoleInfo(struct soap *soap, const struct bmd230__singleRoleInfo *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__singleRoleInfo);
	if (soap_out_bmd230__singleRoleInfo(soap, tag?tag:"bmd230:singleRoleInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__singleRoleInfo * SOAP_FMAC4 soap_get_bmd230__singleRoleInfo(struct soap *soap, struct bmd230__singleRoleInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__singleRoleInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__loginResponse(struct soap *soap, struct bmd230__loginResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->userInfo = NULL;
	a->formSearch = NULL;
	a->formSend = NULL;
	a->formHistory = NULL;
	a->formUpdate = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__loginResponse(struct soap *soap, const struct bmd230__loginResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTobmd230__singleUserInfo(soap, &a->userInfo);
	soap_serialize_PointerTobmd230__mtdsInfo(soap, &a->formSearch);
	soap_serialize_PointerTobmd230__mtdsInfo(soap, &a->formSend);
	soap_serialize_PointerTobmd230__mtdsInfo(soap, &a->formHistory);
	soap_serialize_PointerTobmd230__mtdsInfo(soap, &a->formUpdate);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__loginResponse(struct soap *soap, const char *tag, int id, const struct bmd230__loginResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__loginResponse), type))
		return soap->error;
	if (soap_out_PointerTobmd230__singleUserInfo(soap, "userInfo", -1, &a->userInfo, ""))
		return soap->error;
	if (soap_out_PointerTobmd230__mtdsInfo(soap, "formSearch", -1, &a->formSearch, ""))
		return soap->error;
	if (soap_out_PointerTobmd230__mtdsInfo(soap, "formSend", -1, &a->formSend, ""))
		return soap->error;
	if (soap_out_PointerTobmd230__mtdsInfo(soap, "formHistory", -1, &a->formHistory, ""))
		return soap->error;
	if (soap_out_PointerTobmd230__mtdsInfo(soap, "formUpdate", -1, &a->formUpdate, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__loginResponse * SOAP_FMAC4 soap_in_bmd230__loginResponse(struct soap *soap, const char *tag, struct bmd230__loginResponse *a, const char *type)
{
	size_t soap_flag_userInfo = 1;
	size_t soap_flag_formSearch = 1;
	size_t soap_flag_formSend = 1;
	size_t soap_flag_formHistory = 1;
	size_t soap_flag_formUpdate = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__loginResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__loginResponse, sizeof(struct bmd230__loginResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__loginResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_userInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobmd230__singleUserInfo(soap, "userInfo", &a->userInfo, "bmd230:singleUserInfo"))
				{	soap_flag_userInfo--;
					continue;
				}
			if (soap_flag_formSearch && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobmd230__mtdsInfo(soap, "formSearch", &a->formSearch, "bmd230:mtdsInfo"))
				{	soap_flag_formSearch--;
					continue;
				}
			if (soap_flag_formSend && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobmd230__mtdsInfo(soap, "formSend", &a->formSend, "bmd230:mtdsInfo"))
				{	soap_flag_formSend--;
					continue;
				}
			if (soap_flag_formHistory && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobmd230__mtdsInfo(soap, "formHistory", &a->formHistory, "bmd230:mtdsInfo"))
				{	soap_flag_formHistory--;
					continue;
				}
			if (soap_flag_formUpdate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobmd230__mtdsInfo(soap, "formUpdate", &a->formUpdate, "bmd230:mtdsInfo"))
				{	soap_flag_formUpdate--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__loginResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__loginResponse, 0, sizeof(struct bmd230__loginResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__loginResponse(struct soap *soap, const struct bmd230__loginResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__loginResponse);
	if (soap_out_bmd230__loginResponse(soap, tag?tag:"bmd230:loginResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__loginResponse * SOAP_FMAC4 soap_get_bmd230__loginResponse(struct soap *soap, struct bmd230__loginResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__loginResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__userRegistrationResult(struct soap *soap, struct bmd230__userRegistrationResult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_long(soap, &a->userIdentityId);
	soap_default_long(soap, &a->userCertificateId);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__userRegistrationResult(struct soap *soap, const struct bmd230__userRegistrationResult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->userIdentityId, SOAP_TYPE_long);
	soap_embedded(soap, &a->userCertificateId, SOAP_TYPE_long);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__userRegistrationResult(struct soap *soap, const char *tag, int id, const struct bmd230__userRegistrationResult *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__userRegistrationResult), type))
		return soap->error;
	if (soap_out_long(soap, "userIdentityId", -1, &a->userIdentityId, ""))
		return soap->error;
	if (soap_out_long(soap, "userCertificateId", -1, &a->userCertificateId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__userRegistrationResult * SOAP_FMAC4 soap_in_bmd230__userRegistrationResult(struct soap *soap, const char *tag, struct bmd230__userRegistrationResult *a, const char *type)
{
	size_t soap_flag_userIdentityId = 1;
	size_t soap_flag_userCertificateId = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__userRegistrationResult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__userRegistrationResult, sizeof(struct bmd230__userRegistrationResult), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__userRegistrationResult(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_userIdentityId && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_long(soap, "userIdentityId", &a->userIdentityId, "xsd:long"))
				{	soap_flag_userIdentityId--;
					continue;
				}
			if (soap_flag_userCertificateId && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_long(soap, "userCertificateId", &a->userCertificateId, "xsd:long"))
				{	soap_flag_userCertificateId--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__userRegistrationResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__userRegistrationResult, 0, sizeof(struct bmd230__userRegistrationResult), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_userIdentityId > 0 || soap_flag_userCertificateId > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__userRegistrationResult(struct soap *soap, const struct bmd230__userRegistrationResult *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__userRegistrationResult);
	if (soap_out_bmd230__userRegistrationResult(soap, tag?tag:"bmd230:userRegistrationResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__userRegistrationResult * SOAP_FMAC4 soap_get_bmd230__userRegistrationResult(struct soap *soap, struct bmd230__userRegistrationResult *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__userRegistrationResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__userListInfo(struct soap *soap, struct bmd230__userListInfo *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__userListInfo(struct soap *soap, struct bmd230__userListInfo const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_bmd230__userListInfo))
		for (i = 0; i < a->__size; i++)
		{	soap_embedded(soap, a->__ptr + i, SOAP_TYPE_bmd230__singleUserInfo);
			soap_serialize_bmd230__singleUserInfo(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__userListInfo(struct soap *soap, const char *tag, int id, const struct bmd230__userListInfo *a, const char *type)
{
	int i, n = a->__size;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_bmd230__userListInfo);
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap_out_bmd230__singleUserInfo(soap, "item", -1, &a->__ptr[i], "");
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__userListInfo * SOAP_FMAC4 soap_in_bmd230__userListInfo(struct soap *soap, const char *tag, struct bmd230__userListInfo *a, const char *type)
{	int i, j;
	struct bmd230__singleUserInfo *p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_array(soap, "bmd230:singleUserInfo") && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct bmd230__userListInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__userListInfo, sizeof(struct bmd230__userListInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__userListInfo(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct bmd230__singleUserInfo *)soap_malloc(soap, sizeof(struct bmd230__singleUserInfo) * a->__size);
			for (i = 0; i < a->__size; i++)
				soap_default_bmd230__singleUserInfo(soap, a->__ptr+i);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_bmd230__singleUserInfo(soap, NULL, a->__ptr + i, "bmd230:singleUserInfo"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct bmd230__singleUserInfo *)soap_push_block(soap, NULL, sizeof(struct bmd230__singleUserInfo));
				if (!p)
					return NULL;
				soap_default_bmd230__singleUserInfo(soap, p);
				if (!soap_in_bmd230__singleUserInfo(soap, NULL, p, "bmd230:singleUserInfo"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct bmd230__singleUserInfo *)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__userListInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__userListInfo, 0, sizeof(struct bmd230__userListInfo), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__userListInfo(struct soap *soap, const struct bmd230__userListInfo *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_bmd230__userListInfo);
	if (soap_out_bmd230__userListInfo(soap, tag?tag:"bmd230:userListInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__userListInfo * SOAP_FMAC4 soap_get_bmd230__userListInfo(struct soap *soap, struct bmd230__userListInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__userListInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__singleUserInfo(struct soap *soap, struct bmd230__singleUserInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->userId);
	soap_default_xsd__string(soap, &a->userCertIssuer);
	soap_default_xsd__string(soap, &a->userCertSerial);
	soap_default_xsd__string(soap, &a->userName);
	soap_default_xsd__string(soap, &a->userIdentity);
	soap_default_xsd__string(soap, &a->userAccepted);
	a->userRoleIdList = NULL;
	a->userRoleNameList = NULL;
	a->userGroupIdList = NULL;
	a->userGroupNameList = NULL;
	a->userClassIdList = NULL;
	a->userClassNameList = NULL;
	a->userSecurityNameList = NULL;
	soap_default_xsd__string(soap, &a->userDefaultRoleId);
	soap_default_xsd__string(soap, &a->userDefaultRoleName);
	soap_default_xsd__string(soap, &a->userDefaultGroupId);
	soap_default_xsd__string(soap, &a->userDefaultGroupName);
	soap_default_xsd__string(soap, &a->userDefaultClassId);
	soap_default_xsd__string(soap, &a->userDefaultClassName);
	a->userNewGroupInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__singleUserInfo(struct soap *soap, const struct bmd230__singleUserInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__string(soap, &a->userId);
	soap_serialize_xsd__string(soap, &a->userCertIssuer);
	soap_serialize_xsd__string(soap, &a->userCertSerial);
	soap_serialize_xsd__string(soap, &a->userName);
	soap_serialize_xsd__string(soap, &a->userIdentity);
	soap_serialize_xsd__string(soap, &a->userAccepted);
	soap_serialize_PointerTobmd230__stringList(soap, &a->userRoleIdList);
	soap_serialize_PointerTobmd230__stringList(soap, &a->userRoleNameList);
	soap_serialize_PointerTobmd230__stringList(soap, &a->userGroupIdList);
	soap_serialize_PointerTobmd230__stringList(soap, &a->userGroupNameList);
	soap_serialize_PointerTobmd230__stringList(soap, &a->userClassIdList);
	soap_serialize_PointerTobmd230__stringList(soap, &a->userClassNameList);
	soap_serialize_PointerTobmd230__stringList(soap, &a->userSecurityNameList);
	soap_serialize_xsd__string(soap, &a->userDefaultRoleId);
	soap_serialize_xsd__string(soap, &a->userDefaultRoleName);
	soap_serialize_xsd__string(soap, &a->userDefaultGroupId);
	soap_serialize_xsd__string(soap, &a->userDefaultGroupName);
	soap_serialize_xsd__string(soap, &a->userDefaultClassId);
	soap_serialize_xsd__string(soap, &a->userDefaultClassName);
	soap_serialize_PointerTobmd230__userNewGroupInfo(soap, &a->userNewGroupInfo);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__singleUserInfo(struct soap *soap, const char *tag, int id, const struct bmd230__singleUserInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__singleUserInfo), type))
		return soap->error;
	if (soap_out_xsd__string(soap, "userId", -1, &a->userId, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "userCertIssuer", -1, &a->userCertIssuer, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "userCertSerial", -1, &a->userCertSerial, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "userName", -1, &a->userName, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "userIdentity", -1, &a->userIdentity, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "userAccepted", -1, &a->userAccepted, ""))
		return soap->error;
	if (soap_out_PointerTobmd230__stringList(soap, "userRoleIdList", -1, &a->userRoleIdList, ""))
		return soap->error;
	if (soap_out_PointerTobmd230__stringList(soap, "userRoleNameList", -1, &a->userRoleNameList, ""))
		return soap->error;
	if (soap_out_PointerTobmd230__stringList(soap, "userGroupIdList", -1, &a->userGroupIdList, ""))
		return soap->error;
	if (soap_out_PointerTobmd230__stringList(soap, "userGroupNameList", -1, &a->userGroupNameList, ""))
		return soap->error;
	if (soap_out_PointerTobmd230__stringList(soap, "userClassIdList", -1, &a->userClassIdList, ""))
		return soap->error;
	if (soap_out_PointerTobmd230__stringList(soap, "userClassNameList", -1, &a->userClassNameList, ""))
		return soap->error;
	if (soap_out_PointerTobmd230__stringList(soap, "userSecurityNameList", -1, &a->userSecurityNameList, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "userDefaultRoleId", -1, &a->userDefaultRoleId, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "userDefaultRoleName", -1, &a->userDefaultRoleName, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "userDefaultGroupId", -1, &a->userDefaultGroupId, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "userDefaultGroupName", -1, &a->userDefaultGroupName, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "userDefaultClassId", -1, &a->userDefaultClassId, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "userDefaultClassName", -1, &a->userDefaultClassName, ""))
		return soap->error;
	if (soap_out_PointerTobmd230__userNewGroupInfo(soap, "userNewGroupInfo", -1, &a->userNewGroupInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__singleUserInfo * SOAP_FMAC4 soap_in_bmd230__singleUserInfo(struct soap *soap, const char *tag, struct bmd230__singleUserInfo *a, const char *type)
{
	size_t soap_flag_userId = 1;
	size_t soap_flag_userCertIssuer = 1;
	size_t soap_flag_userCertSerial = 1;
	size_t soap_flag_userName = 1;
	size_t soap_flag_userIdentity = 1;
	size_t soap_flag_userAccepted = 1;
	size_t soap_flag_userRoleIdList = 1;
	size_t soap_flag_userRoleNameList = 1;
	size_t soap_flag_userGroupIdList = 1;
	size_t soap_flag_userGroupNameList = 1;
	size_t soap_flag_userClassIdList = 1;
	size_t soap_flag_userClassNameList = 1;
	size_t soap_flag_userSecurityNameList = 1;
	size_t soap_flag_userDefaultRoleId = 1;
	size_t soap_flag_userDefaultRoleName = 1;
	size_t soap_flag_userDefaultGroupId = 1;
	size_t soap_flag_userDefaultGroupName = 1;
	size_t soap_flag_userDefaultClassId = 1;
	size_t soap_flag_userDefaultClassName = 1;
	size_t soap_flag_userNewGroupInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__singleUserInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__singleUserInfo, sizeof(struct bmd230__singleUserInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__singleUserInfo(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_userId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "userId", &a->userId, "xsd:string"))
				{	soap_flag_userId--;
					continue;
				}
			if (soap_flag_userCertIssuer && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "userCertIssuer", &a->userCertIssuer, "xsd:string"))
				{	soap_flag_userCertIssuer--;
					continue;
				}
			if (soap_flag_userCertSerial && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "userCertSerial", &a->userCertSerial, "xsd:string"))
				{	soap_flag_userCertSerial--;
					continue;
				}
			if (soap_flag_userName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "userName", &a->userName, "xsd:string"))
				{	soap_flag_userName--;
					continue;
				}
			if (soap_flag_userIdentity && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "userIdentity", &a->userIdentity, "xsd:string"))
				{	soap_flag_userIdentity--;
					continue;
				}
			if (soap_flag_userAccepted && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "userAccepted", &a->userAccepted, "xsd:string"))
				{	soap_flag_userAccepted--;
					continue;
				}
			if (soap_flag_userRoleIdList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobmd230__stringList(soap, "userRoleIdList", &a->userRoleIdList, "bmd230:stringList"))
				{	soap_flag_userRoleIdList--;
					continue;
				}
			if (soap_flag_userRoleNameList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobmd230__stringList(soap, "userRoleNameList", &a->userRoleNameList, "bmd230:stringList"))
				{	soap_flag_userRoleNameList--;
					continue;
				}
			if (soap_flag_userGroupIdList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobmd230__stringList(soap, "userGroupIdList", &a->userGroupIdList, "bmd230:stringList"))
				{	soap_flag_userGroupIdList--;
					continue;
				}
			if (soap_flag_userGroupNameList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobmd230__stringList(soap, "userGroupNameList", &a->userGroupNameList, "bmd230:stringList"))
				{	soap_flag_userGroupNameList--;
					continue;
				}
			if (soap_flag_userClassIdList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobmd230__stringList(soap, "userClassIdList", &a->userClassIdList, "bmd230:stringList"))
				{	soap_flag_userClassIdList--;
					continue;
				}
			if (soap_flag_userClassNameList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobmd230__stringList(soap, "userClassNameList", &a->userClassNameList, "bmd230:stringList"))
				{	soap_flag_userClassNameList--;
					continue;
				}
			if (soap_flag_userSecurityNameList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobmd230__stringList(soap, "userSecurityNameList", &a->userSecurityNameList, "bmd230:stringList"))
				{	soap_flag_userSecurityNameList--;
					continue;
				}
			if (soap_flag_userDefaultRoleId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "userDefaultRoleId", &a->userDefaultRoleId, "xsd:string"))
				{	soap_flag_userDefaultRoleId--;
					continue;
				}
			if (soap_flag_userDefaultRoleName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "userDefaultRoleName", &a->userDefaultRoleName, "xsd:string"))
				{	soap_flag_userDefaultRoleName--;
					continue;
				}
			if (soap_flag_userDefaultGroupId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "userDefaultGroupId", &a->userDefaultGroupId, "xsd:string"))
				{	soap_flag_userDefaultGroupId--;
					continue;
				}
			if (soap_flag_userDefaultGroupName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "userDefaultGroupName", &a->userDefaultGroupName, "xsd:string"))
				{	soap_flag_userDefaultGroupName--;
					continue;
				}
			if (soap_flag_userDefaultClassId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "userDefaultClassId", &a->userDefaultClassId, "xsd:string"))
				{	soap_flag_userDefaultClassId--;
					continue;
				}
			if (soap_flag_userDefaultClassName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "userDefaultClassName", &a->userDefaultClassName, "xsd:string"))
				{	soap_flag_userDefaultClassName--;
					continue;
				}
			if (soap_flag_userNewGroupInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobmd230__userNewGroupInfo(soap, "userNewGroupInfo", &a->userNewGroupInfo, "bmd230:userNewGroupInfo"))
				{	soap_flag_userNewGroupInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__singleUserInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__singleUserInfo, 0, sizeof(struct bmd230__singleUserInfo), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__singleUserInfo(struct soap *soap, const struct bmd230__singleUserInfo *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__singleUserInfo);
	if (soap_out_bmd230__singleUserInfo(soap, tag?tag:"bmd230:singleUserInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__singleUserInfo * SOAP_FMAC4 soap_get_bmd230__singleUserInfo(struct soap *soap, struct bmd230__singleUserInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__singleUserInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__userNewGroupInfo(struct soap *soap, struct bmd230__userNewGroupInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->userNewGroupName);
	a->userNewGroupParentIds = NULL;
	a->userNewGroupChildIds = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__userNewGroupInfo(struct soap *soap, const struct bmd230__userNewGroupInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__string(soap, &a->userNewGroupName);
	soap_serialize_PointerTobmd230__stringList(soap, &a->userNewGroupParentIds);
	soap_serialize_PointerTobmd230__stringList(soap, &a->userNewGroupChildIds);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__userNewGroupInfo(struct soap *soap, const char *tag, int id, const struct bmd230__userNewGroupInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__userNewGroupInfo), type))
		return soap->error;
	if (soap_out_xsd__string(soap, "userNewGroupName", -1, &a->userNewGroupName, ""))
		return soap->error;
	if (soap_out_PointerTobmd230__stringList(soap, "userNewGroupParentIds", -1, &a->userNewGroupParentIds, ""))
		return soap->error;
	if (soap_out_PointerTobmd230__stringList(soap, "userNewGroupChildIds", -1, &a->userNewGroupChildIds, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__userNewGroupInfo * SOAP_FMAC4 soap_in_bmd230__userNewGroupInfo(struct soap *soap, const char *tag, struct bmd230__userNewGroupInfo *a, const char *type)
{
	size_t soap_flag_userNewGroupName = 1;
	size_t soap_flag_userNewGroupParentIds = 1;
	size_t soap_flag_userNewGroupChildIds = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__userNewGroupInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__userNewGroupInfo, sizeof(struct bmd230__userNewGroupInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__userNewGroupInfo(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_userNewGroupName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "userNewGroupName", &a->userNewGroupName, "xsd:string"))
				{	soap_flag_userNewGroupName--;
					continue;
				}
			if (soap_flag_userNewGroupParentIds && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobmd230__stringList(soap, "userNewGroupParentIds", &a->userNewGroupParentIds, "bmd230:stringList"))
				{	soap_flag_userNewGroupParentIds--;
					continue;
				}
			if (soap_flag_userNewGroupChildIds && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobmd230__stringList(soap, "userNewGroupChildIds", &a->userNewGroupChildIds, "bmd230:stringList"))
				{	soap_flag_userNewGroupChildIds--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__userNewGroupInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__userNewGroupInfo, 0, sizeof(struct bmd230__userNewGroupInfo), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__userNewGroupInfo(struct soap *soap, const struct bmd230__userNewGroupInfo *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__userNewGroupInfo);
	if (soap_out_bmd230__userNewGroupInfo(soap, tag?tag:"bmd230:userNewGroupInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__userNewGroupInfo * SOAP_FMAC4 soap_get_bmd230__userNewGroupInfo(struct soap *soap, struct bmd230__userNewGroupInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__userNewGroupInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__stringList(struct soap *soap, struct bmd230__stringList *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__stringList(struct soap *soap, struct bmd230__stringList const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_bmd230__stringList))
		for (i = 0; i < a->__size; i++)
		{
			soap_serialize_xsd__string(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__stringList(struct soap *soap, const char *tag, int id, const struct bmd230__stringList *a, const char *type)
{
	int i, n = a->__size;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_bmd230__stringList);
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap_out_xsd__string(soap, "item", -1, &a->__ptr[i], "");
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__stringList * SOAP_FMAC4 soap_in_bmd230__stringList(struct soap *soap, const char *tag, struct bmd230__stringList *a, const char *type)
{	int i, j;
	char **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_array(soap, "xsd:string") && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct bmd230__stringList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__stringList, sizeof(struct bmd230__stringList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__stringList(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (char **)soap_malloc(soap, sizeof(char *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_xsd__string(soap, NULL, a->__ptr + i, "xsd:string"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (char **)soap_push_block(soap, NULL, sizeof(char *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_xsd__string(soap, NULL, p, "xsd:string"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (char **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__stringList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__stringList, 0, sizeof(struct bmd230__stringList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__stringList(struct soap *soap, const struct bmd230__stringList *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_bmd230__stringList);
	if (soap_out_bmd230__stringList(soap, tag?tag:"bmd230:stringList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__stringList * SOAP_FMAC4 soap_get_bmd230__stringList(struct soap *soap, struct bmd230__stringList *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__stringList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__mtdsSearchValues(struct soap *soap, struct bmd230__mtdsSearchValues *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__mtdsSearchValues(struct soap *soap, struct bmd230__mtdsSearchValues const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_bmd230__mtdsSearchValues))
		for (i = 0; i < a->__size; i++)
		{	soap_embedded(soap, a->__ptr + i, SOAP_TYPE_bmd230__mtdSearchSingleValue);
			soap_serialize_bmd230__mtdSearchSingleValue(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__mtdsSearchValues(struct soap *soap, const char *tag, int id, const struct bmd230__mtdsSearchValues *a, const char *type)
{
	int i, n = a->__size;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_bmd230__mtdsSearchValues);
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap_out_bmd230__mtdSearchSingleValue(soap, "item", -1, &a->__ptr[i], "");
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__mtdsSearchValues * SOAP_FMAC4 soap_in_bmd230__mtdsSearchValues(struct soap *soap, const char *tag, struct bmd230__mtdsSearchValues *a, const char *type)
{	int i, j;
	struct bmd230__mtdSearchSingleValue *p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_array(soap, "bmd230:mtdSearchSingleValue") && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct bmd230__mtdsSearchValues *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__mtdsSearchValues, sizeof(struct bmd230__mtdsSearchValues), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__mtdsSearchValues(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct bmd230__mtdSearchSingleValue *)soap_malloc(soap, sizeof(struct bmd230__mtdSearchSingleValue) * a->__size);
			for (i = 0; i < a->__size; i++)
				soap_default_bmd230__mtdSearchSingleValue(soap, a->__ptr+i);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_bmd230__mtdSearchSingleValue(soap, NULL, a->__ptr + i, "bmd230:mtdSearchSingleValue"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct bmd230__mtdSearchSingleValue *)soap_push_block(soap, NULL, sizeof(struct bmd230__mtdSearchSingleValue));
				if (!p)
					return NULL;
				soap_default_bmd230__mtdSearchSingleValue(soap, p);
				if (!soap_in_bmd230__mtdSearchSingleValue(soap, NULL, p, "bmd230:mtdSearchSingleValue"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct bmd230__mtdSearchSingleValue *)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__mtdsSearchValues *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__mtdsSearchValues, 0, sizeof(struct bmd230__mtdsSearchValues), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__mtdsSearchValues(struct soap *soap, const struct bmd230__mtdsSearchValues *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_bmd230__mtdsSearchValues);
	if (soap_out_bmd230__mtdsSearchValues(soap, tag?tag:"bmd230:mtdsSearchValues", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__mtdsSearchValues * SOAP_FMAC4 soap_get_bmd230__mtdsSearchValues(struct soap *soap, struct bmd230__mtdsSearchValues *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__mtdsSearchValues(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__mtdSearchSingleValue(struct soap *soap, struct bmd230__mtdSearchSingleValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->mtdOid);
	soap_default_xsd__string(soap, &a->mtdValue);
	soap_default_xsd__string(soap, &a->mtdDesc);
	soap_default_xsd__string(soap, &a->mtdLogicalOperator);
	soap_default_int(soap, &a->noOfOpenBrackets);
	soap_default_int(soap, &a->noOfCloseBrackets);
	soap_default_xsd__string(soap, &a->mtdAdjustment);
	soap_default_xsd__string(soap, &a->mtdStatement);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__mtdSearchSingleValue(struct soap *soap, const struct bmd230__mtdSearchSingleValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__string(soap, &a->mtdOid);
	soap_serialize_xsd__string(soap, &a->mtdValue);
	soap_serialize_xsd__string(soap, &a->mtdDesc);
	soap_serialize_xsd__string(soap, &a->mtdLogicalOperator);
	soap_embedded(soap, &a->noOfOpenBrackets, SOAP_TYPE_int);
	soap_embedded(soap, &a->noOfCloseBrackets, SOAP_TYPE_int);
	soap_serialize_xsd__string(soap, &a->mtdAdjustment);
	soap_serialize_xsd__string(soap, &a->mtdStatement);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__mtdSearchSingleValue(struct soap *soap, const char *tag, int id, const struct bmd230__mtdSearchSingleValue *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__mtdSearchSingleValue), type))
		return soap->error;
	if (soap_out_xsd__string(soap, "mtdOid", -1, &a->mtdOid, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "mtdValue", -1, &a->mtdValue, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "mtdDesc", -1, &a->mtdDesc, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "mtdLogicalOperator", -1, &a->mtdLogicalOperator, ""))
		return soap->error;
	if (soap_out_int(soap, "noOfOpenBrackets", -1, &a->noOfOpenBrackets, ""))
		return soap->error;
	if (soap_out_int(soap, "noOfCloseBrackets", -1, &a->noOfCloseBrackets, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "mtdAdjustment", -1, &a->mtdAdjustment, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "mtdStatement", -1, &a->mtdStatement, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__mtdSearchSingleValue * SOAP_FMAC4 soap_in_bmd230__mtdSearchSingleValue(struct soap *soap, const char *tag, struct bmd230__mtdSearchSingleValue *a, const char *type)
{
	size_t soap_flag_mtdOid = 1;
	size_t soap_flag_mtdValue = 1;
	size_t soap_flag_mtdDesc = 1;
	size_t soap_flag_mtdLogicalOperator = 1;
	size_t soap_flag_noOfOpenBrackets = 1;
	size_t soap_flag_noOfCloseBrackets = 1;
	size_t soap_flag_mtdAdjustment = 1;
	size_t soap_flag_mtdStatement = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__mtdSearchSingleValue *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__mtdSearchSingleValue, sizeof(struct bmd230__mtdSearchSingleValue), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__mtdSearchSingleValue(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_mtdOid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "mtdOid", &a->mtdOid, "xsd:string"))
				{	soap_flag_mtdOid--;
					continue;
				}
			if (soap_flag_mtdValue && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "mtdValue", &a->mtdValue, "xsd:string"))
				{	soap_flag_mtdValue--;
					continue;
				}
			if (soap_flag_mtdDesc && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "mtdDesc", &a->mtdDesc, "xsd:string"))
				{	soap_flag_mtdDesc--;
					continue;
				}
			if (soap_flag_mtdLogicalOperator && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "mtdLogicalOperator", &a->mtdLogicalOperator, "xsd:string"))
				{	soap_flag_mtdLogicalOperator--;
					continue;
				}
			if (soap_flag_noOfOpenBrackets && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "noOfOpenBrackets", &a->noOfOpenBrackets, "xsd:int"))
				{	soap_flag_noOfOpenBrackets--;
					continue;
				}
			if (soap_flag_noOfCloseBrackets && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "noOfCloseBrackets", &a->noOfCloseBrackets, "xsd:int"))
				{	soap_flag_noOfCloseBrackets--;
					continue;
				}
			if (soap_flag_mtdAdjustment && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "mtdAdjustment", &a->mtdAdjustment, "xsd:string"))
				{	soap_flag_mtdAdjustment--;
					continue;
				}
			if (soap_flag_mtdStatement && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "mtdStatement", &a->mtdStatement, "xsd:string"))
				{	soap_flag_mtdStatement--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__mtdSearchSingleValue *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__mtdSearchSingleValue, 0, sizeof(struct bmd230__mtdSearchSingleValue), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_noOfOpenBrackets > 0 || soap_flag_noOfCloseBrackets > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__mtdSearchSingleValue(struct soap *soap, const struct bmd230__mtdSearchSingleValue *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__mtdSearchSingleValue);
	if (soap_out_bmd230__mtdSearchSingleValue(soap, tag?tag:"bmd230:mtdSearchSingleValue", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__mtdSearchSingleValue * SOAP_FMAC4 soap_get_bmd230__mtdSearchSingleValue(struct soap *soap, struct bmd230__mtdSearchSingleValue *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__mtdSearchSingleValue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__bmdTimestamp(struct soap *soap, struct bmd230__bmdTimestamp *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->timestamp = NULL;
	soap_default_string(soap, &a->genTime);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__bmdTimestamp(struct soap *soap, const struct bmd230__bmdTimestamp *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__base64Binary(soap, &a->timestamp);
	soap_serialize_string(soap, &a->genTime);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__bmdTimestamp(struct soap *soap, const char *tag, int id, const struct bmd230__bmdTimestamp *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__bmdTimestamp), type))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "timestamp", -1, &a->timestamp, ""))
		return soap->error;
	if (soap_out_string(soap, "genTime", -1, &a->genTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__bmdTimestamp * SOAP_FMAC4 soap_in_bmd230__bmdTimestamp(struct soap *soap, const char *tag, struct bmd230__bmdTimestamp *a, const char *type)
{
	size_t soap_flag_timestamp = 1;
	size_t soap_flag_genTime = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__bmdTimestamp *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__bmdTimestamp, sizeof(struct bmd230__bmdTimestamp), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__bmdTimestamp(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_timestamp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "timestamp", &a->timestamp, "xsd:base64Binary"))
				{	soap_flag_timestamp--;
					continue;
				}
			if (soap_flag_genTime && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "genTime", &a->genTime, "xsd:string"))
				{	soap_flag_genTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdTimestamp *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__bmdTimestamp, 0, sizeof(struct bmd230__bmdTimestamp), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__bmdTimestamp(struct soap *soap, const struct bmd230__bmdTimestamp *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__bmdTimestamp);
	if (soap_out_bmd230__bmdTimestamp(soap, tag?tag:"bmd230:bmdTimestamp", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdTimestamp * SOAP_FMAC4 soap_get_bmd230__bmdTimestamp(struct soap *soap, struct bmd230__bmdTimestamp *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__bmdTimestamp(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__historyResults(struct soap *soap, struct bmd230__historyResults *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__historyResults(struct soap *soap, struct bmd230__historyResults const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_bmd230__historyResults))
		for (i = 0; i < a->__size; i++)
		{	soap_embedded(soap, a->__ptr + i, SOAP_TYPE_bmd230__historySingleResult);
			soap_serialize_bmd230__historySingleResult(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__historyResults(struct soap *soap, const char *tag, int id, const struct bmd230__historyResults *a, const char *type)
{
	int i, n = a->__size;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_bmd230__historyResults);
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap_out_bmd230__historySingleResult(soap, "item", -1, &a->__ptr[i], "");
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__historyResults * SOAP_FMAC4 soap_in_bmd230__historyResults(struct soap *soap, const char *tag, struct bmd230__historyResults *a, const char *type)
{	int i, j;
	struct bmd230__historySingleResult *p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_array(soap, "bmd230:historySingleResult") && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct bmd230__historyResults *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__historyResults, sizeof(struct bmd230__historyResults), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__historyResults(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct bmd230__historySingleResult *)soap_malloc(soap, sizeof(struct bmd230__historySingleResult) * a->__size);
			for (i = 0; i < a->__size; i++)
				soap_default_bmd230__historySingleResult(soap, a->__ptr+i);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_bmd230__historySingleResult(soap, NULL, a->__ptr + i, "bmd230:historySingleResult"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct bmd230__historySingleResult *)soap_push_block(soap, NULL, sizeof(struct bmd230__historySingleResult));
				if (!p)
					return NULL;
				soap_default_bmd230__historySingleResult(soap, p);
				if (!soap_in_bmd230__historySingleResult(soap, NULL, p, "bmd230:historySingleResult"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct bmd230__historySingleResult *)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__historyResults *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__historyResults, 0, sizeof(struct bmd230__historyResults), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__historyResults(struct soap *soap, const struct bmd230__historyResults *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_bmd230__historyResults);
	if (soap_out_bmd230__historyResults(soap, tag?tag:"bmd230:historyResults", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__historyResults * SOAP_FMAC4 soap_get_bmd230__historyResults(struct soap *soap, struct bmd230__historyResults *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__historyResults(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__historySingleResult(struct soap *soap, struct bmd230__historySingleResult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->mtds = NULL;
	soap_default_xsd__string(soap, &a->updateDate);
	soap_default_xsd__string(soap, &a->updateOwner);
	soap_default_xsd__string(soap, &a->updateReason);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__historySingleResult(struct soap *soap, const struct bmd230__historySingleResult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTobmd230__mtdsValues(soap, &a->mtds);
	soap_serialize_xsd__string(soap, &a->updateDate);
	soap_serialize_xsd__string(soap, &a->updateOwner);
	soap_serialize_xsd__string(soap, &a->updateReason);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__historySingleResult(struct soap *soap, const char *tag, int id, const struct bmd230__historySingleResult *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__historySingleResult), type))
		return soap->error;
	if (soap_out_PointerTobmd230__mtdsValues(soap, "mtds", -1, &a->mtds, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "updateDate", -1, &a->updateDate, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "updateOwner", -1, &a->updateOwner, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "updateReason", -1, &a->updateReason, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__historySingleResult * SOAP_FMAC4 soap_in_bmd230__historySingleResult(struct soap *soap, const char *tag, struct bmd230__historySingleResult *a, const char *type)
{
	size_t soap_flag_mtds = 1;
	size_t soap_flag_updateDate = 1;
	size_t soap_flag_updateOwner = 1;
	size_t soap_flag_updateReason = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__historySingleResult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__historySingleResult, sizeof(struct bmd230__historySingleResult), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__historySingleResult(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_mtds && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobmd230__mtdsValues(soap, "mtds", &a->mtds, "bmd230:mtdsValues"))
				{	soap_flag_mtds--;
					continue;
				}
			if (soap_flag_updateDate && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "updateDate", &a->updateDate, "xsd:string"))
				{	soap_flag_updateDate--;
					continue;
				}
			if (soap_flag_updateOwner && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "updateOwner", &a->updateOwner, "xsd:string"))
				{	soap_flag_updateOwner--;
					continue;
				}
			if (soap_flag_updateReason && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "updateReason", &a->updateReason, "xsd:string"))
				{	soap_flag_updateReason--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__historySingleResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__historySingleResult, 0, sizeof(struct bmd230__historySingleResult), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__historySingleResult(struct soap *soap, const struct bmd230__historySingleResult *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__historySingleResult);
	if (soap_out_bmd230__historySingleResult(soap, tag?tag:"bmd230:historySingleResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__historySingleResult * SOAP_FMAC4 soap_get_bmd230__historySingleResult(struct soap *soap, struct bmd230__historySingleResult *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__historySingleResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__searchResults(struct soap *soap, struct bmd230__searchResults *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__searchResults(struct soap *soap, struct bmd230__searchResults const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_bmd230__searchResults))
		for (i = 0; i < a->__size; i++)
		{	soap_embedded(soap, a->__ptr + i, SOAP_TYPE_bmd230__searchSingleResult);
			soap_serialize_bmd230__searchSingleResult(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__searchResults(struct soap *soap, const char *tag, int id, const struct bmd230__searchResults *a, const char *type)
{
	int i, n = a->__size;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_bmd230__searchResults);
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap_out_bmd230__searchSingleResult(soap, "item", -1, &a->__ptr[i], "");
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__searchResults * SOAP_FMAC4 soap_in_bmd230__searchResults(struct soap *soap, const char *tag, struct bmd230__searchResults *a, const char *type)
{	int i, j;
	struct bmd230__searchSingleResult *p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_array(soap, "bmd230:searchSingleResult") && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct bmd230__searchResults *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__searchResults, sizeof(struct bmd230__searchResults), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__searchResults(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct bmd230__searchSingleResult *)soap_malloc(soap, sizeof(struct bmd230__searchSingleResult) * a->__size);
			for (i = 0; i < a->__size; i++)
				soap_default_bmd230__searchSingleResult(soap, a->__ptr+i);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_bmd230__searchSingleResult(soap, NULL, a->__ptr + i, "bmd230:searchSingleResult"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct bmd230__searchSingleResult *)soap_push_block(soap, NULL, sizeof(struct bmd230__searchSingleResult));
				if (!p)
					return NULL;
				soap_default_bmd230__searchSingleResult(soap, p);
				if (!soap_in_bmd230__searchSingleResult(soap, NULL, p, "bmd230:searchSingleResult"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct bmd230__searchSingleResult *)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__searchResults *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__searchResults, 0, sizeof(struct bmd230__searchResults), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__searchResults(struct soap *soap, const struct bmd230__searchResults *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_bmd230__searchResults);
	if (soap_out_bmd230__searchResults(soap, tag?tag:"bmd230:searchResults", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__searchResults * SOAP_FMAC4 soap_get_bmd230__searchResults(struct soap *soap, struct bmd230__searchResults *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__searchResults(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__searchSingleResult(struct soap *soap, struct bmd230__searchSingleResult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->mtds = NULL;
	soap_default_xsd__string(soap, &a->filename);
	soap_default_long(soap, &a->id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__searchSingleResult(struct soap *soap, const struct bmd230__searchSingleResult *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTobmd230__mtdsValues(soap, &a->mtds);
	soap_serialize_xsd__string(soap, &a->filename);
	soap_embedded(soap, &a->id, SOAP_TYPE_long);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__searchSingleResult(struct soap *soap, const char *tag, int id, const struct bmd230__searchSingleResult *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__searchSingleResult), type))
		return soap->error;
	if (soap_out_PointerTobmd230__mtdsValues(soap, "mtds", -1, &a->mtds, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "filename", -1, &a->filename, ""))
		return soap->error;
	if (soap_out_long(soap, "id", -1, &a->id, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__searchSingleResult * SOAP_FMAC4 soap_in_bmd230__searchSingleResult(struct soap *soap, const char *tag, struct bmd230__searchSingleResult *a, const char *type)
{
	size_t soap_flag_mtds = 1;
	size_t soap_flag_filename = 1;
	size_t soap_flag_id = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__searchSingleResult *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__searchSingleResult, sizeof(struct bmd230__searchSingleResult), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__searchSingleResult(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_mtds && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobmd230__mtdsValues(soap, "mtds", &a->mtds, "bmd230:mtdsValues"))
				{	soap_flag_mtds--;
					continue;
				}
			if (soap_flag_filename && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "filename", &a->filename, "xsd:string"))
				{	soap_flag_filename--;
					continue;
				}
			if (soap_flag_id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_long(soap, "id", &a->id, "xsd:long"))
				{	soap_flag_id--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__searchSingleResult *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__searchSingleResult, 0, sizeof(struct bmd230__searchSingleResult), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__searchSingleResult(struct soap *soap, const struct bmd230__searchSingleResult *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__searchSingleResult);
	if (soap_out_bmd230__searchSingleResult(soap, tag?tag:"bmd230:searchSingleResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__searchSingleResult * SOAP_FMAC4 soap_get_bmd230__searchSingleResult(struct soap *soap, struct bmd230__searchSingleResult *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__searchSingleResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__mtdsInfo(struct soap *soap, struct bmd230__mtdsInfo *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__mtdsInfo(struct soap *soap, struct bmd230__mtdsInfo const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_bmd230__mtdsInfo))
		for (i = 0; i < a->__size; i++)
		{	soap_embedded(soap, a->__ptr + i, SOAP_TYPE_bmd230__mtdSingleInfo);
			soap_serialize_bmd230__mtdSingleInfo(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__mtdsInfo(struct soap *soap, const char *tag, int id, const struct bmd230__mtdsInfo *a, const char *type)
{
	int i, n = a->__size;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_bmd230__mtdsInfo);
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap_out_bmd230__mtdSingleInfo(soap, "item", -1, &a->__ptr[i], "");
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__mtdsInfo * SOAP_FMAC4 soap_in_bmd230__mtdsInfo(struct soap *soap, const char *tag, struct bmd230__mtdsInfo *a, const char *type)
{	int i, j;
	struct bmd230__mtdSingleInfo *p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_array(soap, "bmd230:mtdSingleInfo") && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct bmd230__mtdsInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__mtdsInfo, sizeof(struct bmd230__mtdsInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__mtdsInfo(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct bmd230__mtdSingleInfo *)soap_malloc(soap, sizeof(struct bmd230__mtdSingleInfo) * a->__size);
			for (i = 0; i < a->__size; i++)
				soap_default_bmd230__mtdSingleInfo(soap, a->__ptr+i);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_bmd230__mtdSingleInfo(soap, NULL, a->__ptr + i, "bmd230:mtdSingleInfo"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct bmd230__mtdSingleInfo *)soap_push_block(soap, NULL, sizeof(struct bmd230__mtdSingleInfo));
				if (!p)
					return NULL;
				soap_default_bmd230__mtdSingleInfo(soap, p);
				if (!soap_in_bmd230__mtdSingleInfo(soap, NULL, p, "bmd230:mtdSingleInfo"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct bmd230__mtdSingleInfo *)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__mtdsInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__mtdsInfo, 0, sizeof(struct bmd230__mtdsInfo), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__mtdsInfo(struct soap *soap, const struct bmd230__mtdsInfo *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_bmd230__mtdsInfo);
	if (soap_out_bmd230__mtdsInfo(soap, tag?tag:"bmd230:mtdsInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__mtdsInfo * SOAP_FMAC4 soap_get_bmd230__mtdsInfo(struct soap *soap, struct bmd230__mtdsInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__mtdsInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__mtdSingleInfo(struct soap *soap, struct bmd230__mtdSingleInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->mtdOid);
	soap_default_xsd__string(soap, &a->mtdDesc);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__mtdSingleInfo(struct soap *soap, const struct bmd230__mtdSingleInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__string(soap, &a->mtdOid);
	soap_serialize_xsd__string(soap, &a->mtdDesc);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__mtdSingleInfo(struct soap *soap, const char *tag, int id, const struct bmd230__mtdSingleInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__mtdSingleInfo), type))
		return soap->error;
	if (soap_out_xsd__string(soap, "mtdOid", -1, &a->mtdOid, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "mtdDesc", -1, &a->mtdDesc, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__mtdSingleInfo * SOAP_FMAC4 soap_in_bmd230__mtdSingleInfo(struct soap *soap, const char *tag, struct bmd230__mtdSingleInfo *a, const char *type)
{
	size_t soap_flag_mtdOid = 1;
	size_t soap_flag_mtdDesc = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__mtdSingleInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__mtdSingleInfo, sizeof(struct bmd230__mtdSingleInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__mtdSingleInfo(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_mtdOid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "mtdOid", &a->mtdOid, "xsd:string"))
				{	soap_flag_mtdOid--;
					continue;
				}
			if (soap_flag_mtdDesc && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "mtdDesc", &a->mtdDesc, "xsd:string"))
				{	soap_flag_mtdDesc--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__mtdSingleInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__mtdSingleInfo, 0, sizeof(struct bmd230__mtdSingleInfo), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__mtdSingleInfo(struct soap *soap, const struct bmd230__mtdSingleInfo *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__mtdSingleInfo);
	if (soap_out_bmd230__mtdSingleInfo(soap, tag?tag:"bmd230:mtdSingleInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__mtdSingleInfo * SOAP_FMAC4 soap_get_bmd230__mtdSingleInfo(struct soap *soap, struct bmd230__mtdSingleInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__mtdSingleInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__searchSortInfoList(struct soap *soap, struct bmd230__searchSortInfoList *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__searchSortInfoList(struct soap *soap, struct bmd230__searchSortInfoList const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_bmd230__searchSortInfoList))
		for (i = 0; i < a->__size; i++)
		{	soap_embedded(soap, a->__ptr + i, SOAP_TYPE_bmd230__searchSortInfo);
			soap_serialize_bmd230__searchSortInfo(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__searchSortInfoList(struct soap *soap, const char *tag, int id, const struct bmd230__searchSortInfoList *a, const char *type)
{
	int i, n = a->__size;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_bmd230__searchSortInfoList);
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap_out_bmd230__searchSortInfo(soap, "item", -1, &a->__ptr[i], "");
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__searchSortInfoList * SOAP_FMAC4 soap_in_bmd230__searchSortInfoList(struct soap *soap, const char *tag, struct bmd230__searchSortInfoList *a, const char *type)
{	int i, j;
	struct bmd230__searchSortInfo *p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_array(soap, "bmd230:searchSortInfo") && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct bmd230__searchSortInfoList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__searchSortInfoList, sizeof(struct bmd230__searchSortInfoList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__searchSortInfoList(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct bmd230__searchSortInfo *)soap_malloc(soap, sizeof(struct bmd230__searchSortInfo) * a->__size);
			for (i = 0; i < a->__size; i++)
				soap_default_bmd230__searchSortInfo(soap, a->__ptr+i);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_bmd230__searchSortInfo(soap, NULL, a->__ptr + i, "bmd230:searchSortInfo"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct bmd230__searchSortInfo *)soap_push_block(soap, NULL, sizeof(struct bmd230__searchSortInfo));
				if (!p)
					return NULL;
				soap_default_bmd230__searchSortInfo(soap, p);
				if (!soap_in_bmd230__searchSortInfo(soap, NULL, p, "bmd230:searchSortInfo"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct bmd230__searchSortInfo *)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__searchSortInfoList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__searchSortInfoList, 0, sizeof(struct bmd230__searchSortInfoList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__searchSortInfoList(struct soap *soap, const struct bmd230__searchSortInfoList *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_bmd230__searchSortInfoList);
	if (soap_out_bmd230__searchSortInfoList(soap, tag?tag:"bmd230:searchSortInfoList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__searchSortInfoList * SOAP_FMAC4 soap_get_bmd230__searchSortInfoList(struct soap *soap, struct bmd230__searchSortInfoList *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__searchSortInfoList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__searchSortInfo(struct soap *soap, struct bmd230__searchSortInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->sortOid);
	soap_default_xsd__string(soap, &a->sortOrder);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__searchSortInfo(struct soap *soap, const struct bmd230__searchSortInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__string(soap, &a->sortOid);
	soap_serialize_xsd__string(soap, &a->sortOrder);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__searchSortInfo(struct soap *soap, const char *tag, int id, const struct bmd230__searchSortInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__searchSortInfo), type))
		return soap->error;
	if (soap_out_xsd__string(soap, "sortOid", -1, &a->sortOid, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "sortOrder", -1, &a->sortOrder, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__searchSortInfo * SOAP_FMAC4 soap_in_bmd230__searchSortInfo(struct soap *soap, const char *tag, struct bmd230__searchSortInfo *a, const char *type)
{
	size_t soap_flag_sortOid = 1;
	size_t soap_flag_sortOrder = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__searchSortInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__searchSortInfo, sizeof(struct bmd230__searchSortInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__searchSortInfo(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sortOid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "sortOid", &a->sortOid, "xsd:string"))
				{	soap_flag_sortOid--;
					continue;
				}
			if (soap_flag_sortOrder && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "sortOrder", &a->sortOrder, "xsd:string"))
				{	soap_flag_sortOrder--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__searchSortInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__searchSortInfo, 0, sizeof(struct bmd230__searchSortInfo), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__searchSortInfo(struct soap *soap, const struct bmd230__searchSortInfo *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__searchSortInfo);
	if (soap_out_bmd230__searchSortInfo(soap, tag?tag:"bmd230:searchSortInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__searchSortInfo * SOAP_FMAC4 soap_get_bmd230__searchSortInfo(struct soap *soap, struct bmd230__searchSortInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__searchSortInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__idList(struct soap *soap, struct bmd230__idList *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__idList(struct soap *soap, struct bmd230__idList const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_bmd230__idList))
		for (i = 0; i < a->__size; i++)
		{	soap_embedded(soap, a->__ptr + i, SOAP_TYPE_int);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__idList(struct soap *soap, const char *tag, int id, const struct bmd230__idList *a, const char *type)
{
	int i, n = a->__size;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_bmd230__idList);
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap_out_int(soap, "item", -1, &a->__ptr[i], "");
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__idList * SOAP_FMAC4 soap_in_bmd230__idList(struct soap *soap, const char *tag, struct bmd230__idList *a, const char *type)
{	int i, j;
	int *p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_array(soap, "xsd:int") && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct bmd230__idList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__idList, sizeof(struct bmd230__idList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__idList(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (int *)soap_malloc(soap, sizeof(int) * a->__size);
			for (i = 0; i < a->__size; i++)
				soap_default_int(soap, a->__ptr+i);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_int(soap, NULL, a->__ptr + i, "xsd:int"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (int *)soap_push_block(soap, NULL, sizeof(int));
				if (!p)
					return NULL;
				soap_default_int(soap, p);
				if (!soap_in_int(soap, NULL, p, "xsd:int"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (int *)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__idList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__idList, 0, sizeof(struct bmd230__idList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__idList(struct soap *soap, const struct bmd230__idList *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_bmd230__idList);
	if (soap_out_bmd230__idList(soap, tag?tag:"bmd230:idList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__idList * SOAP_FMAC4 soap_get_bmd230__idList(struct soap *soap, struct bmd230__idList *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__idList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__fileComplexList(struct soap *soap, struct bmd230__fileComplexList *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__fileComplexList(struct soap *soap, struct bmd230__fileComplexList const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_bmd230__fileComplexList))
		for (i = 0; i < a->__size; i++)
		{	soap_embedded(soap, a->__ptr + i, SOAP_TYPE_bmd230__fileComplex);
			soap_serialize_bmd230__fileComplex(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__fileComplexList(struct soap *soap, const char *tag, int id, const struct bmd230__fileComplexList *a, const char *type)
{
	int i, n = a->__size;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_bmd230__fileComplexList);
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap_out_bmd230__fileComplex(soap, "item", -1, &a->__ptr[i], "");
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__fileComplexList * SOAP_FMAC4 soap_in_bmd230__fileComplexList(struct soap *soap, const char *tag, struct bmd230__fileComplexList *a, const char *type)
{	int i, j;
	struct bmd230__fileComplex *p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_array(soap, "bmd230:fileComplex") && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct bmd230__fileComplexList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__fileComplexList, sizeof(struct bmd230__fileComplexList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__fileComplexList(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct bmd230__fileComplex *)soap_malloc(soap, sizeof(struct bmd230__fileComplex) * a->__size);
			for (i = 0; i < a->__size; i++)
				soap_default_bmd230__fileComplex(soap, a->__ptr+i);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_bmd230__fileComplex(soap, NULL, a->__ptr + i, "bmd230:fileComplex"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct bmd230__fileComplex *)soap_push_block(soap, NULL, sizeof(struct bmd230__fileComplex));
				if (!p)
					return NULL;
				soap_default_bmd230__fileComplex(soap, p);
				if (!soap_in_bmd230__fileComplex(soap, NULL, p, "bmd230:fileComplex"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct bmd230__fileComplex *)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__fileComplexList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__fileComplexList, 0, sizeof(struct bmd230__fileComplexList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__fileComplexList(struct soap *soap, const struct bmd230__fileComplexList *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_bmd230__fileComplexList);
	if (soap_out_bmd230__fileComplexList(soap, tag?tag:"bmd230:fileComplexList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__fileComplexList * SOAP_FMAC4 soap_get_bmd230__fileComplexList(struct soap *soap, struct bmd230__fileComplexList *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__fileComplexList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__fileComplex(struct soap *soap, struct bmd230__fileComplex *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->mtds = NULL;
	a->file = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__fileComplex(struct soap *soap, const struct bmd230__fileComplex *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTobmd230__mtdsValues(soap, &a->mtds);
	soap_serialize_PointerTobmd230__fileInfo(soap, &a->file);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__fileComplex(struct soap *soap, const char *tag, int id, const struct bmd230__fileComplex *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__fileComplex), type))
		return soap->error;
	if (soap_out_PointerTobmd230__mtdsValues(soap, "mtds", -1, &a->mtds, ""))
		return soap->error;
	if (soap_out_PointerTobmd230__fileInfo(soap, "file", -1, &a->file, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__fileComplex * SOAP_FMAC4 soap_in_bmd230__fileComplex(struct soap *soap, const char *tag, struct bmd230__fileComplex *a, const char *type)
{
	size_t soap_flag_mtds = 1;
	size_t soap_flag_file = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__fileComplex *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__fileComplex, sizeof(struct bmd230__fileComplex), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__fileComplex(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_mtds && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobmd230__mtdsValues(soap, "mtds", &a->mtds, "bmd230:mtdsValues"))
				{	soap_flag_mtds--;
					continue;
				}
			if (soap_flag_file && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobmd230__fileInfo(soap, "file", &a->file, "bmd230:fileInfo"))
				{	soap_flag_file--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__fileComplex *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__fileComplex, 0, sizeof(struct bmd230__fileComplex), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__fileComplex(struct soap *soap, const struct bmd230__fileComplex *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__fileComplex);
	if (soap_out_bmd230__fileComplex(soap, tag?tag:"bmd230:fileComplex", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__fileComplex * SOAP_FMAC4 soap_get_bmd230__fileComplex(struct soap *soap, struct bmd230__fileComplex *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__fileComplex(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__mtdsValues(struct soap *soap, struct bmd230__mtdsValues *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__mtdsValues(struct soap *soap, struct bmd230__mtdsValues const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_bmd230__mtdsValues))
		for (i = 0; i < a->__size; i++)
		{	soap_embedded(soap, a->__ptr + i, SOAP_TYPE_bmd230__mtdSingleValue);
			soap_serialize_bmd230__mtdSingleValue(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__mtdsValues(struct soap *soap, const char *tag, int id, const struct bmd230__mtdsValues *a, const char *type)
{
	int i, n = a->__size;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_bmd230__mtdsValues);
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap_out_bmd230__mtdSingleValue(soap, "item", -1, &a->__ptr[i], "");
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__mtdsValues * SOAP_FMAC4 soap_in_bmd230__mtdsValues(struct soap *soap, const char *tag, struct bmd230__mtdsValues *a, const char *type)
{	int i, j;
	struct bmd230__mtdSingleValue *p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_array(soap, "bmd230:mtdSingleValue") && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct bmd230__mtdsValues *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__mtdsValues, sizeof(struct bmd230__mtdsValues), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__mtdsValues(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct bmd230__mtdSingleValue *)soap_malloc(soap, sizeof(struct bmd230__mtdSingleValue) * a->__size);
			for (i = 0; i < a->__size; i++)
				soap_default_bmd230__mtdSingleValue(soap, a->__ptr+i);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_bmd230__mtdSingleValue(soap, NULL, a->__ptr + i, "bmd230:mtdSingleValue"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct bmd230__mtdSingleValue *)soap_push_block(soap, NULL, sizeof(struct bmd230__mtdSingleValue));
				if (!p)
					return NULL;
				soap_default_bmd230__mtdSingleValue(soap, p);
				if (!soap_in_bmd230__mtdSingleValue(soap, NULL, p, "bmd230:mtdSingleValue"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct bmd230__mtdSingleValue *)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__mtdsValues *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__mtdsValues, 0, sizeof(struct bmd230__mtdsValues), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__mtdsValues(struct soap *soap, const struct bmd230__mtdsValues *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_bmd230__mtdsValues);
	if (soap_out_bmd230__mtdsValues(soap, tag?tag:"bmd230:mtdsValues", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__mtdsValues * SOAP_FMAC4 soap_get_bmd230__mtdsValues(struct soap *soap, struct bmd230__mtdsValues *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__mtdsValues(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__mtdSingleValue(struct soap *soap, struct bmd230__mtdSingleValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->mtdOid);
	soap_default_xsd__string(soap, &a->mtdValue);
	soap_default_xsd__string(soap, &a->mtdDesc);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__mtdSingleValue(struct soap *soap, const struct bmd230__mtdSingleValue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__string(soap, &a->mtdOid);
	soap_serialize_xsd__string(soap, &a->mtdValue);
	soap_serialize_xsd__string(soap, &a->mtdDesc);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__mtdSingleValue(struct soap *soap, const char *tag, int id, const struct bmd230__mtdSingleValue *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__mtdSingleValue), type))
		return soap->error;
	if (soap_out_xsd__string(soap, "mtdOid", -1, &a->mtdOid, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "mtdValue", -1, &a->mtdValue, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "mtdDesc", -1, &a->mtdDesc, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__mtdSingleValue * SOAP_FMAC4 soap_in_bmd230__mtdSingleValue(struct soap *soap, const char *tag, struct bmd230__mtdSingleValue *a, const char *type)
{
	size_t soap_flag_mtdOid = 1;
	size_t soap_flag_mtdValue = 1;
	size_t soap_flag_mtdDesc = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__mtdSingleValue *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__mtdSingleValue, sizeof(struct bmd230__mtdSingleValue), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__mtdSingleValue(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_mtdOid && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "mtdOid", &a->mtdOid, "xsd:string"))
				{	soap_flag_mtdOid--;
					continue;
				}
			if (soap_flag_mtdValue && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "mtdValue", &a->mtdValue, "xsd:string"))
				{	soap_flag_mtdValue--;
					continue;
				}
			if (soap_flag_mtdDesc && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "mtdDesc", &a->mtdDesc, "xsd:string"))
				{	soap_flag_mtdDesc--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__mtdSingleValue *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__mtdSingleValue, 0, sizeof(struct bmd230__mtdSingleValue), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__mtdSingleValue(struct soap *soap, const struct bmd230__mtdSingleValue *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__mtdSingleValue);
	if (soap_out_bmd230__mtdSingleValue(soap, tag?tag:"bmd230:mtdSingleValue", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__mtdSingleValue * SOAP_FMAC4 soap_get_bmd230__mtdSingleValue(struct soap *soap, struct bmd230__mtdSingleValue *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__mtdSingleValue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__fileInfoList(struct soap *soap, struct bmd230__fileInfoList *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__fileInfoList(struct soap *soap, struct bmd230__fileInfoList const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_bmd230__fileInfoList))
		for (i = 0; i < a->__size; i++)
		{	soap_embedded(soap, a->__ptr + i, SOAP_TYPE_bmd230__fileInfo);
			soap_serialize_bmd230__fileInfo(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__fileInfoList(struct soap *soap, const char *tag, int id, const struct bmd230__fileInfoList *a, const char *type)
{
	int i, n = a->__size;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_bmd230__fileInfoList);
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap_out_bmd230__fileInfo(soap, "item", -1, &a->__ptr[i], "");
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__fileInfoList * SOAP_FMAC4 soap_in_bmd230__fileInfoList(struct soap *soap, const char *tag, struct bmd230__fileInfoList *a, const char *type)
{	int i, j;
	struct bmd230__fileInfo *p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_array(soap, "bmd230:fileInfo") && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct bmd230__fileInfoList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__fileInfoList, sizeof(struct bmd230__fileInfoList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__fileInfoList(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct bmd230__fileInfo *)soap_malloc(soap, sizeof(struct bmd230__fileInfo) * a->__size);
			for (i = 0; i < a->__size; i++)
				soap_default_bmd230__fileInfo(soap, a->__ptr+i);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_bmd230__fileInfo(soap, NULL, a->__ptr + i, "bmd230:fileInfo"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (struct bmd230__fileInfo *)soap_push_block(soap, NULL, sizeof(struct bmd230__fileInfo));
				if (!p)
					return NULL;
				soap_default_bmd230__fileInfo(soap, p);
				if (!soap_in_bmd230__fileInfo(soap, NULL, p, "bmd230:fileInfo"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (struct bmd230__fileInfo *)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__fileInfoList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__fileInfoList, 0, sizeof(struct bmd230__fileInfoList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__fileInfoList(struct soap *soap, const struct bmd230__fileInfoList *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_bmd230__fileInfoList);
	if (soap_out_bmd230__fileInfoList(soap, tag?tag:"bmd230:fileInfoList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__fileInfoList * SOAP_FMAC4 soap_get_bmd230__fileInfoList(struct soap *soap, struct bmd230__fileInfoList *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__fileInfoList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__fileInfo(struct soap *soap, struct bmd230__fileInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->file = NULL;
	soap_default_xsd__string(soap, &a->filename);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__fileInfo(struct soap *soap, const struct bmd230__fileInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTobmd230__myBinaryDataType(soap, &a->file);
	soap_serialize_xsd__string(soap, &a->filename);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__fileInfo(struct soap *soap, const char *tag, int id, const struct bmd230__fileInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__fileInfo), type))
		return soap->error;
	if (soap_out_PointerTobmd230__myBinaryDataType(soap, "file", -1, &a->file, ""))
		return soap->error;
	if (soap_out_xsd__string(soap, "filename", -1, &a->filename, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__fileInfo * SOAP_FMAC4 soap_in_bmd230__fileInfo(struct soap *soap, const char *tag, struct bmd230__fileInfo *a, const char *type)
{
	size_t soap_flag_file = 1;
	size_t soap_flag_filename = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__fileInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__fileInfo, sizeof(struct bmd230__fileInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__fileInfo(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_file && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobmd230__myBinaryDataType(soap, "file", &a->file, "bmd230:myBinaryDataType"))
				{	soap_flag_file--;
					continue;
				}
			if (soap_flag_filename && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "filename", &a->filename, "xsd:string"))
				{	soap_flag_filename--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__fileInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__fileInfo, 0, sizeof(struct bmd230__fileInfo), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__fileInfo(struct soap *soap, const struct bmd230__fileInfo *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__fileInfo);
	if (soap_out_bmd230__fileInfo(soap, tag?tag:"bmd230:fileInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__fileInfo * SOAP_FMAC4 soap_get_bmd230__fileInfo(struct soap *soap, struct bmd230__fileInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__fileInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__PkiFileInfo(struct soap *soap, struct bmd230__PkiFileInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->filename);
	a->timestamp = NULL;
	a->signature = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__PkiFileInfo(struct soap *soap, const struct bmd230__PkiFileInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__string(soap, &a->filename);
	soap_serialize_PointerTobmd230__TimestampList(soap, &a->timestamp);
	soap_serialize_PointerTobmd230__SignatureList(soap, &a->signature);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__PkiFileInfo(struct soap *soap, const char *tag, int id, const struct bmd230__PkiFileInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__PkiFileInfo), type))
		return soap->error;
	if (soap_out_xsd__string(soap, "filename", -1, &a->filename, ""))
		return soap->error;
	if (soap_out_PointerTobmd230__TimestampList(soap, "timestamp", -1, &a->timestamp, ""))
		return soap->error;
	if (soap_out_PointerTobmd230__SignatureList(soap, "signature", -1, &a->signature, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__PkiFileInfo * SOAP_FMAC4 soap_in_bmd230__PkiFileInfo(struct soap *soap, const char *tag, struct bmd230__PkiFileInfo *a, const char *type)
{
	size_t soap_flag_filename = 1;
	size_t soap_flag_timestamp = 1;
	size_t soap_flag_signature = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__PkiFileInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__PkiFileInfo, sizeof(struct bmd230__PkiFileInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__PkiFileInfo(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_filename && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "filename", &a->filename, "xsd:string"))
				{	soap_flag_filename--;
					continue;
				}
			if (soap_flag_timestamp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobmd230__TimestampList(soap, "timestamp", &a->timestamp, "bmd230:TimestampList"))
				{	soap_flag_timestamp--;
					continue;
				}
			if (soap_flag_signature && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobmd230__SignatureList(soap, "signature", &a->signature, "bmd230:SignatureList"))
				{	soap_flag_signature--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__PkiFileInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__PkiFileInfo, 0, sizeof(struct bmd230__PkiFileInfo), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__PkiFileInfo(struct soap *soap, const struct bmd230__PkiFileInfo *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__PkiFileInfo);
	if (soap_out_bmd230__PkiFileInfo(soap, tag?tag:"bmd230:PkiFileInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__PkiFileInfo * SOAP_FMAC4 soap_get_bmd230__PkiFileInfo(struct soap *soap, struct bmd230__PkiFileInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__PkiFileInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__SignatureList(struct soap *soap, struct bmd230__SignatureList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__SignatureList(struct soap *soap, const struct bmd230__SignatureList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->__ptr)
	{	int i;
		for (i = 0; i < a->__size; i++)
		{
			soap_embedded(soap, a->__ptr + i, SOAP_TYPE_bmd230__SignatureSingle);
			soap_serialize_bmd230__SignatureSingle(soap, a->__ptr + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__SignatureList(struct soap *soap, const char *tag, int id, const struct bmd230__SignatureList *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__SignatureList), type))
		return soap->error;
	if (a->__ptr)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_bmd230__SignatureSingle(soap, "item", -1, a->__ptr + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__SignatureList * SOAP_FMAC4 soap_in_bmd230__SignatureList(struct soap *soap, const char *tag, struct bmd230__SignatureList *a, const char *type)
{
	struct soap_blist *soap_blist___ptr = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__SignatureList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__SignatureList, sizeof(struct bmd230__SignatureList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__SignatureList(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "item", 1, NULL))
			{	if (a->__ptr == NULL)
				{	if (soap_blist___ptr == NULL)
						soap_blist___ptr = soap_new_block(soap);
					a->__ptr = (struct bmd230__SignatureSingle *)soap_push_block(soap, soap_blist___ptr, sizeof(struct bmd230__SignatureSingle));
					if (a->__ptr == NULL)
						return NULL;
					soap_default_bmd230__SignatureSingle(soap, a->__ptr);
				}soap_revert(soap);
				if (soap_in_bmd230__SignatureSingle(soap, "item", a->__ptr, "bmd230:SignatureSingle"))
				{	a->__size++;
					a->__ptr = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__ptr)
			soap_pop_block(soap, soap_blist___ptr);
		if (a->__size)
			a->__ptr = (struct bmd230__SignatureSingle *)soap_save_block(soap, soap_blist___ptr, NULL, 1);
		else
		{	a->__ptr = NULL;
			if (soap_blist___ptr)
				soap_end_block(soap, soap_blist___ptr);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__SignatureList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__SignatureList, 0, sizeof(struct bmd230__SignatureList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__SignatureList(struct soap *soap, const struct bmd230__SignatureList *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__SignatureList);
	if (soap_out_bmd230__SignatureList(soap, tag?tag:"bmd230:SignatureList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__SignatureList * SOAP_FMAC4 soap_get_bmd230__SignatureList(struct soap *soap, struct bmd230__SignatureList *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__SignatureList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__DVCSList(struct soap *soap, struct bmd230__DVCSList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__DVCSList(struct soap *soap, const struct bmd230__DVCSList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->__ptr)
	{	int i;
		for (i = 0; i < a->__size; i++)
		{
			soap_embedded(soap, a->__ptr + i, SOAP_TYPE_bmd230__DVCSSingle);
			soap_serialize_bmd230__DVCSSingle(soap, a->__ptr + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__DVCSList(struct soap *soap, const char *tag, int id, const struct bmd230__DVCSList *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__DVCSList), type))
		return soap->error;
	if (a->__ptr)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_bmd230__DVCSSingle(soap, "item", -1, a->__ptr + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__DVCSList * SOAP_FMAC4 soap_in_bmd230__DVCSList(struct soap *soap, const char *tag, struct bmd230__DVCSList *a, const char *type)
{
	struct soap_blist *soap_blist___ptr = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__DVCSList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__DVCSList, sizeof(struct bmd230__DVCSList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__DVCSList(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "item", 1, NULL))
			{	if (a->__ptr == NULL)
				{	if (soap_blist___ptr == NULL)
						soap_blist___ptr = soap_new_block(soap);
					a->__ptr = (struct bmd230__DVCSSingle *)soap_push_block(soap, soap_blist___ptr, sizeof(struct bmd230__DVCSSingle));
					if (a->__ptr == NULL)
						return NULL;
					soap_default_bmd230__DVCSSingle(soap, a->__ptr);
				}soap_revert(soap);
				if (soap_in_bmd230__DVCSSingle(soap, "item", a->__ptr, "bmd230:DVCSSingle"))
				{	a->__size++;
					a->__ptr = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__ptr)
			soap_pop_block(soap, soap_blist___ptr);
		if (a->__size)
			a->__ptr = (struct bmd230__DVCSSingle *)soap_save_block(soap, soap_blist___ptr, NULL, 1);
		else
		{	a->__ptr = NULL;
			if (soap_blist___ptr)
				soap_end_block(soap, soap_blist___ptr);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__DVCSList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__DVCSList, 0, sizeof(struct bmd230__DVCSList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__DVCSList(struct soap *soap, const struct bmd230__DVCSList *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__DVCSList);
	if (soap_out_bmd230__DVCSList(soap, tag?tag:"bmd230:DVCSList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__DVCSList * SOAP_FMAC4 soap_get_bmd230__DVCSList(struct soap *soap, struct bmd230__DVCSList *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__DVCSList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__SignatureSingle(struct soap *soap, struct bmd230__SignatureSingle *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->value = NULL;
	a->timestamp = NULL;
	a->dvcs = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__SignatureSingle(struct soap *soap, const struct bmd230__SignatureSingle *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__base64Binary(soap, &a->value);
	soap_serialize_PointerTobmd230__TimestampList(soap, &a->timestamp);
	soap_serialize_PointerTobmd230__DVCSList(soap, &a->dvcs);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__SignatureSingle(struct soap *soap, const char *tag, int id, const struct bmd230__SignatureSingle *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__SignatureSingle), type))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "value", -1, &a->value, ""))
		return soap->error;
	if (soap_out_PointerTobmd230__TimestampList(soap, "timestamp", -1, &a->timestamp, ""))
		return soap->error;
	if (soap_out_PointerTobmd230__DVCSList(soap, "dvcs", -1, &a->dvcs, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__SignatureSingle * SOAP_FMAC4 soap_in_bmd230__SignatureSingle(struct soap *soap, const char *tag, struct bmd230__SignatureSingle *a, const char *type)
{
	size_t soap_flag_value = 1;
	size_t soap_flag_timestamp = 1;
	size_t soap_flag_dvcs = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__SignatureSingle *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__SignatureSingle, sizeof(struct bmd230__SignatureSingle), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__SignatureSingle(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_value && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "value", &a->value, "xsd:base64Binary"))
				{	soap_flag_value--;
					continue;
				}
			if (soap_flag_timestamp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobmd230__TimestampList(soap, "timestamp", &a->timestamp, "bmd230:TimestampList"))
				{	soap_flag_timestamp--;
					continue;
				}
			if (soap_flag_dvcs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobmd230__DVCSList(soap, "dvcs", &a->dvcs, "bmd230:DVCSList"))
				{	soap_flag_dvcs--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__SignatureSingle *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__SignatureSingle, 0, sizeof(struct bmd230__SignatureSingle), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__SignatureSingle(struct soap *soap, const struct bmd230__SignatureSingle *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__SignatureSingle);
	if (soap_out_bmd230__SignatureSingle(soap, tag?tag:"bmd230:SignatureSingle", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__SignatureSingle * SOAP_FMAC4 soap_get_bmd230__SignatureSingle(struct soap *soap, struct bmd230__SignatureSingle *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__SignatureSingle(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__TimestampList(struct soap *soap, struct bmd230__TimestampList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__TimestampList(struct soap *soap, const struct bmd230__TimestampList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->__ptr)
	{	int i;
		for (i = 0; i < a->__size; i++)
		{
			soap_embedded(soap, a->__ptr + i, SOAP_TYPE_bmd230__TimestampSingle);
			soap_serialize_bmd230__TimestampSingle(soap, a->__ptr + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__TimestampList(struct soap *soap, const char *tag, int id, const struct bmd230__TimestampList *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__TimestampList), type))
		return soap->error;
	if (a->__ptr)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_bmd230__TimestampSingle(soap, "item", -1, a->__ptr + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__TimestampList * SOAP_FMAC4 soap_in_bmd230__TimestampList(struct soap *soap, const char *tag, struct bmd230__TimestampList *a, const char *type)
{
	struct soap_blist *soap_blist___ptr = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__TimestampList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__TimestampList, sizeof(struct bmd230__TimestampList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__TimestampList(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "item", 1, NULL))
			{	if (a->__ptr == NULL)
				{	if (soap_blist___ptr == NULL)
						soap_blist___ptr = soap_new_block(soap);
					a->__ptr = (struct bmd230__TimestampSingle *)soap_push_block(soap, soap_blist___ptr, sizeof(struct bmd230__TimestampSingle));
					if (a->__ptr == NULL)
						return NULL;
					soap_default_bmd230__TimestampSingle(soap, a->__ptr);
				}soap_revert(soap);
				if (soap_in_bmd230__TimestampSingle(soap, "item", a->__ptr, "bmd230:TimestampSingle"))
				{	a->__size++;
					a->__ptr = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__ptr)
			soap_pop_block(soap, soap_blist___ptr);
		if (a->__size)
			a->__ptr = (struct bmd230__TimestampSingle *)soap_save_block(soap, soap_blist___ptr, NULL, 1);
		else
		{	a->__ptr = NULL;
			if (soap_blist___ptr)
				soap_end_block(soap, soap_blist___ptr);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__TimestampList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__TimestampList, 0, sizeof(struct bmd230__TimestampList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__TimestampList(struct soap *soap, const struct bmd230__TimestampList *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__TimestampList);
	if (soap_out_bmd230__TimestampList(soap, tag?tag:"bmd230:TimestampList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__TimestampList * SOAP_FMAC4 soap_get_bmd230__TimestampList(struct soap *soap, struct bmd230__TimestampList *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__TimestampList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__DVCSSingle(struct soap *soap, struct bmd230__DVCSSingle *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->value = NULL;
	a->timestamp = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__DVCSSingle(struct soap *soap, const struct bmd230__DVCSSingle *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__base64Binary(soap, &a->value);
	soap_serialize_PointerTobmd230__TimestampList(soap, &a->timestamp);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__DVCSSingle(struct soap *soap, const char *tag, int id, const struct bmd230__DVCSSingle *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__DVCSSingle), type))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "value", -1, &a->value, ""))
		return soap->error;
	if (soap_out_PointerTobmd230__TimestampList(soap, "timestamp", -1, &a->timestamp, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__DVCSSingle * SOAP_FMAC4 soap_in_bmd230__DVCSSingle(struct soap *soap, const char *tag, struct bmd230__DVCSSingle *a, const char *type)
{
	size_t soap_flag_value = 1;
	size_t soap_flag_timestamp = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__DVCSSingle *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__DVCSSingle, sizeof(struct bmd230__DVCSSingle), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__DVCSSingle(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_value && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "value", &a->value, "xsd:base64Binary"))
				{	soap_flag_value--;
					continue;
				}
			if (soap_flag_timestamp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTobmd230__TimestampList(soap, "timestamp", &a->timestamp, "bmd230:TimestampList"))
				{	soap_flag_timestamp--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__DVCSSingle *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__DVCSSingle, 0, sizeof(struct bmd230__DVCSSingle), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__DVCSSingle(struct soap *soap, const struct bmd230__DVCSSingle *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__DVCSSingle);
	if (soap_out_bmd230__DVCSSingle(soap, tag?tag:"bmd230:DVCSSingle", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__DVCSSingle * SOAP_FMAC4 soap_get_bmd230__DVCSSingle(struct soap *soap, struct bmd230__DVCSSingle *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__DVCSSingle(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__TimestampSingle(struct soap *soap, struct bmd230__TimestampSingle *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->value = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__TimestampSingle(struct soap *soap, const struct bmd230__TimestampSingle *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__base64Binary(soap, &a->value);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__TimestampSingle(struct soap *soap, const char *tag, int id, const struct bmd230__TimestampSingle *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bmd230__TimestampSingle), type))
		return soap->error;
	if (soap_out_PointerToxsd__base64Binary(soap, "value", -1, &a->value, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__TimestampSingle * SOAP_FMAC4 soap_in_bmd230__TimestampSingle(struct soap *soap, const char *tag, struct bmd230__TimestampSingle *a, const char *type)
{
	size_t soap_flag_value = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct bmd230__TimestampSingle *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__TimestampSingle, sizeof(struct bmd230__TimestampSingle), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__TimestampSingle(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_value && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "value", &a->value, "xsd:base64Binary"))
				{	soap_flag_value--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__TimestampSingle *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__TimestampSingle, 0, sizeof(struct bmd230__TimestampSingle), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__TimestampSingle(struct soap *soap, const struct bmd230__TimestampSingle *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bmd230__TimestampSingle);
	if (soap_out_bmd230__TimestampSingle(soap, tag?tag:"bmd230:TimestampSingle", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__TimestampSingle * SOAP_FMAC4 soap_get_bmd230__TimestampSingle(struct soap *soap, struct bmd230__TimestampSingle *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__TimestampSingle(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__LongNumbersList(struct soap *soap, struct bmd230__LongNumbersList *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__LongNumbersList(struct soap *soap, struct bmd230__LongNumbersList const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_bmd230__LongNumbersList))
		for (i = 0; i < a->__size; i++)
		{	soap_embedded(soap, a->__ptr + i, SOAP_TYPE_long);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__LongNumbersList(struct soap *soap, const char *tag, int id, const struct bmd230__LongNumbersList *a, const char *type)
{
	int i, n = a->__size;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_bmd230__LongNumbersList);
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap_out_long(soap, "item", -1, &a->__ptr[i], "");
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__LongNumbersList * SOAP_FMAC4 soap_in_bmd230__LongNumbersList(struct soap *soap, const char *tag, struct bmd230__LongNumbersList *a, const char *type)
{	int i, j;
	long *p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_array(soap, "xsd:long") && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct bmd230__LongNumbersList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__LongNumbersList, sizeof(struct bmd230__LongNumbersList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__LongNumbersList(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (long *)soap_malloc(soap, sizeof(long) * a->__size);
			for (i = 0; i < a->__size; i++)
				soap_default_long(soap, a->__ptr+i);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_long(soap, NULL, a->__ptr + i, "xsd:long"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (long *)soap_push_block(soap, NULL, sizeof(long));
				if (!p)
					return NULL;
				soap_default_long(soap, p);
				if (!soap_in_long(soap, NULL, p, "xsd:long"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (long *)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct bmd230__LongNumbersList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__LongNumbersList, 0, sizeof(struct bmd230__LongNumbersList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__LongNumbersList(struct soap *soap, const struct bmd230__LongNumbersList *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_bmd230__LongNumbersList);
	if (soap_out_bmd230__LongNumbersList(soap, tag?tag:"bmd230:LongNumbersList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__LongNumbersList * SOAP_FMAC4 soap_get_bmd230__LongNumbersList(struct soap *soap, struct bmd230__LongNumbersList *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__LongNumbersList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bmd230__myBinaryDataType(struct soap *soap, struct bmd230__myBinaryDataType *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
	a->id = NULL;
	a->type = NULL;
	a->options = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_bmd230__myBinaryDataType(struct soap *soap, struct bmd230__myBinaryDataType const*a)
{
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_bmd230__myBinaryDataType))
		if (a->id || a->type)
			soap->mode |= SOAP_ENC_DIME;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bmd230__myBinaryDataType(struct soap *soap, const char *tag, int id, const struct bmd230__myBinaryDataType *a, const char *type)
{
#ifndef WITH_LEANER
	id = soap_attachment(soap, tag, id, a, (struct soap_array*)&a->__ptr, a->id, a->type, a->options, 1, type, SOAP_TYPE_bmd230__myBinaryDataType);
#else
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_bmd230__myBinaryDataType);
#endif
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	if (soap_putbase64(soap, a->__ptr, a->__size))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct bmd230__myBinaryDataType * SOAP_FMAC4 soap_in_bmd230__myBinaryDataType(struct soap *soap, const char *tag, struct bmd230__myBinaryDataType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":base64Binary") && soap_match_tag(soap, soap->type, ":base64"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct bmd230__myBinaryDataType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bmd230__myBinaryDataType, sizeof(struct bmd230__myBinaryDataType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_bmd230__myBinaryDataType(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__ptr = soap_getbase64(soap, &a->__size, 0);
#ifndef WITH_LEANER
		if (soap_xop_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
			return NULL;
#endif
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
#ifndef WITH_LEANER
		if (*soap->href != '#')
		{	if (soap_dime_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
				return NULL;
		}
		else
#endif
			a = (struct bmd230__myBinaryDataType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bmd230__myBinaryDataType, 0, sizeof(struct bmd230__myBinaryDataType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bmd230__myBinaryDataType(struct soap *soap, const struct bmd230__myBinaryDataType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_bmd230__myBinaryDataType);
	if (soap_out_bmd230__myBinaryDataType(soap, tag?tag:"bmd230:myBinaryDataType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__myBinaryDataType * SOAP_FMAC4 soap_get_bmd230__myBinaryDataType(struct soap *soap, struct bmd230__myBinaryDataType *p, const char *tag, const char *type)
{
	if ((p = soap_in_bmd230__myBinaryDataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__base64Binary(struct soap *soap, struct xsd__base64Binary *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__base64Binary(struct soap *soap, struct xsd__base64Binary const*a)
{
	if (a->__ptr)
		soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_xsd__base64Binary);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__base64Binary(struct soap *soap, const char *tag, int id, const struct xsd__base64Binary *a, const char *type)
{
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_xsd__base64Binary);
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	if (soap_putbase64(soap, a->__ptr, a->__size))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xsd__base64Binary * SOAP_FMAC4 soap_in_xsd__base64Binary(struct soap *soap, const char *tag, struct xsd__base64Binary *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":base64Binary") && soap_match_tag(soap, soap->type, ":base64"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct xsd__base64Binary *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__base64Binary, sizeof(struct xsd__base64Binary), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xsd__base64Binary(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__ptr = soap_getbase64(soap, &a->__size, 0);
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xsd__base64Binary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xsd__base64Binary, 0, sizeof(struct xsd__base64Binary), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__base64Binary(struct soap *soap, const struct xsd__base64Binary *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_xsd__base64Binary);
	if (soap_out_xsd__base64Binary(soap, tag?tag:"xsd:base64Binary", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xsd__base64Binary * SOAP_FMAC4 soap_get_xsd__base64Binary(struct soap *soap, struct xsd__base64Binary *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__base64Binary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsse__Security = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_wsse__Security(soap, &a->wsse__Security);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out_PointerTo_wsse__Security(soap, "wsse:Security", -1, &a->wsse__Security, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	size_t soap_flag_wsse__Security = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsse__Security && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__Security(soap, "wsse:Security", &a->wsse__Security, ""))
				{	soap_flag_wsse__Security--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__Security(struct soap *soap, struct _wsse__Security *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsu__Timestamp = NULL;
	a->UsernameToken = NULL;
	a->BinarySecurityToken = NULL;
	a->ds__Signature = NULL;
	soap_default_string(soap, &a->SOAP_ENV__actor);
	soap_default_string(soap, &a->SOAP_ENV__role);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__Security(struct soap *soap, const struct _wsse__Security *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_wsu__Timestamp(soap, &a->wsu__Timestamp);
	soap_serialize_PointerTo_wsse__UsernameToken(soap, &a->UsernameToken);
	soap_serialize_PointerTo_wsse__BinarySecurityToken(soap, &a->BinarySecurityToken);
	soap_serialize_PointerTods__SignatureType(soap, &a->ds__Signature);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__Security(struct soap *soap, const char *tag, int id, const struct _wsse__Security *a, const char *type)
{
	if (a->SOAP_ENV__actor)
		soap_set_attr(soap, "SOAP-ENV:actor", a->SOAP_ENV__actor, 1);
	if (a->SOAP_ENV__role)
		soap_set_attr(soap, "SOAP-ENV:role", a->SOAP_ENV__role, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsse__Security), type))
		return soap->error;
	if (soap_out_PointerTo_wsu__Timestamp(soap, "wsu:Timestamp", -1, &a->wsu__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTo_wsse__UsernameToken(soap, "wsse:UsernameToken", -1, &a->UsernameToken, ""))
		return soap->error;
	if (soap_out_PointerTo_wsse__BinarySecurityToken(soap, "wsse:BinarySecurityToken", -1, &a->BinarySecurityToken, ""))
		return soap->error;
	if (soap_out_PointerTods__SignatureType(soap, "ds:Signature", -1, &a->ds__Signature, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsse__Security * SOAP_FMAC4 soap_in__wsse__Security(struct soap *soap, const char *tag, struct _wsse__Security *a, const char *type)
{
	size_t soap_flag_wsu__Timestamp = 1;
	size_t soap_flag_UsernameToken = 1;
	size_t soap_flag_BinarySecurityToken = 1;
	size_t soap_flag_ds__Signature = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsse__Security *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__Security, sizeof(struct _wsse__Security), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsse__Security(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "SOAP-ENV:actor", 0), &a->SOAP_ENV__actor, -1, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "SOAP-ENV:role", 0), &a->SOAP_ENV__role, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsu__Timestamp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsu__Timestamp(soap, "wsu:Timestamp", &a->wsu__Timestamp, ""))
				{	soap_flag_wsu__Timestamp--;
					continue;
				}
			if (soap_flag_UsernameToken && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__UsernameToken(soap, "wsse:UsernameToken", &a->UsernameToken, ""))
				{	soap_flag_UsernameToken--;
					continue;
				}
			if (soap_flag_BinarySecurityToken && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__BinarySecurityToken(soap, "wsse:BinarySecurityToken", &a->BinarySecurityToken, ""))
				{	soap_flag_BinarySecurityToken--;
					continue;
				}
			if (soap_flag_ds__Signature && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__SignatureType(soap, "ds:Signature", &a->ds__Signature, "ds:SignatureType"))
				{	soap_flag_ds__Signature--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsse__Security *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsse__Security, 0, sizeof(struct _wsse__Security), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__Security(struct soap *soap, const struct _wsse__Security *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__Security);
	if (soap_out__wsse__Security(soap, tag?tag:"wsse:Security", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Security * SOAP_FMAC4 soap_get__wsse__Security(struct soap *soap, struct _wsse__Security *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__Security(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__RSAKeyValueType(struct soap *soap, struct ds__RSAKeyValueType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Modulus);
	soap_default_string(soap, &a->Exponent);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__RSAKeyValueType(struct soap *soap, const struct ds__RSAKeyValueType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Modulus);
	soap_serialize_string(soap, &a->Exponent);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__RSAKeyValueType(struct soap *soap, const char *tag, int id, const struct ds__RSAKeyValueType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__RSAKeyValueType), type))
		return soap->error;
	if (soap_out_string(soap, "ds:Modulus", -1, &a->Modulus, ""))
		return soap->error;
	if (soap_out_string(soap, "ds:Exponent", -1, &a->Exponent, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__RSAKeyValueType * SOAP_FMAC4 soap_in_ds__RSAKeyValueType(struct soap *soap, const char *tag, struct ds__RSAKeyValueType *a, const char *type)
{
	size_t soap_flag_Modulus = 1;
	size_t soap_flag_Exponent = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__RSAKeyValueType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__RSAKeyValueType, sizeof(struct ds__RSAKeyValueType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__RSAKeyValueType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Modulus && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:Modulus", &a->Modulus, "xsd:string"))
				{	soap_flag_Modulus--;
					continue;
				}
			if (soap_flag_Exponent && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:Exponent", &a->Exponent, "xsd:string"))
				{	soap_flag_Exponent--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__RSAKeyValueType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__RSAKeyValueType, 0, sizeof(struct ds__RSAKeyValueType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Modulus > 0 || soap_flag_Exponent > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__RSAKeyValueType(struct soap *soap, const struct ds__RSAKeyValueType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__RSAKeyValueType);
	if (soap_out_ds__RSAKeyValueType(soap, tag?tag:"ds:RSAKeyValueType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__RSAKeyValueType * SOAP_FMAC4 soap_get_ds__RSAKeyValueType(struct soap *soap, struct ds__RSAKeyValueType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__RSAKeyValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__DSAKeyValueType(struct soap *soap, struct ds__DSAKeyValueType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->G);
	soap_default_string(soap, &a->Y);
	soap_default_string(soap, &a->J);
	soap_default_string(soap, &a->P);
	soap_default_string(soap, &a->Q);
	soap_default_string(soap, &a->Seed);
	soap_default_string(soap, &a->PgenCounter);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__DSAKeyValueType(struct soap *soap, const struct ds__DSAKeyValueType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->G);
	soap_serialize_string(soap, &a->Y);
	soap_serialize_string(soap, &a->J);
	soap_serialize_string(soap, &a->P);
	soap_serialize_string(soap, &a->Q);
	soap_serialize_string(soap, &a->Seed);
	soap_serialize_string(soap, &a->PgenCounter);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__DSAKeyValueType(struct soap *soap, const char *tag, int id, const struct ds__DSAKeyValueType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__DSAKeyValueType), type))
		return soap->error;
	if (soap_out_string(soap, "ds:G", -1, &a->G, ""))
		return soap->error;
	if (soap_out_string(soap, "ds:Y", -1, &a->Y, ""))
		return soap->error;
	if (soap_out_string(soap, "ds:J", -1, &a->J, ""))
		return soap->error;
	if (soap_out_string(soap, "ds:P", -1, &a->P, ""))
		return soap->error;
	if (soap_out_string(soap, "ds:Q", -1, &a->Q, ""))
		return soap->error;
	if (soap_out_string(soap, "ds:Seed", -1, &a->Seed, ""))
		return soap->error;
	if (soap_out_string(soap, "ds:PgenCounter", -1, &a->PgenCounter, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__DSAKeyValueType * SOAP_FMAC4 soap_in_ds__DSAKeyValueType(struct soap *soap, const char *tag, struct ds__DSAKeyValueType *a, const char *type)
{
	size_t soap_flag_G = 1;
	size_t soap_flag_Y = 1;
	size_t soap_flag_J = 1;
	size_t soap_flag_P = 1;
	size_t soap_flag_Q = 1;
	size_t soap_flag_Seed = 1;
	size_t soap_flag_PgenCounter = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__DSAKeyValueType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__DSAKeyValueType, sizeof(struct ds__DSAKeyValueType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__DSAKeyValueType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_G && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:G", &a->G, "xsd:string"))
				{	soap_flag_G--;
					continue;
				}
			if (soap_flag_Y && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:Y", &a->Y, "xsd:string"))
				{	soap_flag_Y--;
					continue;
				}
			if (soap_flag_J && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:J", &a->J, "xsd:string"))
				{	soap_flag_J--;
					continue;
				}
			if (soap_flag_P && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:P", &a->P, "xsd:string"))
				{	soap_flag_P--;
					continue;
				}
			if (soap_flag_Q && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:Q", &a->Q, "xsd:string"))
				{	soap_flag_Q--;
					continue;
				}
			if (soap_flag_Seed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:Seed", &a->Seed, "xsd:string"))
				{	soap_flag_Seed--;
					continue;
				}
			if (soap_flag_PgenCounter && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:PgenCounter", &a->PgenCounter, "xsd:string"))
				{	soap_flag_PgenCounter--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__DSAKeyValueType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__DSAKeyValueType, 0, sizeof(struct ds__DSAKeyValueType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Y > 0 || soap_flag_P > 0 || soap_flag_Q > 0 || soap_flag_Seed > 0 || soap_flag_PgenCounter > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__DSAKeyValueType(struct soap *soap, const struct ds__DSAKeyValueType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__DSAKeyValueType);
	if (soap_out_ds__DSAKeyValueType(soap, tag?tag:"ds:DSAKeyValueType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__DSAKeyValueType * SOAP_FMAC4 soap_get_ds__DSAKeyValueType(struct soap *soap, struct ds__DSAKeyValueType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__DSAKeyValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__X509IssuerSerialType(struct soap *soap, struct ds__X509IssuerSerialType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->X509IssuerName);
	soap_default_int(soap, &a->X509SerialNumber);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__X509IssuerSerialType(struct soap *soap, const struct ds__X509IssuerSerialType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->X509IssuerName);
	soap_embedded(soap, &a->X509SerialNumber, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__X509IssuerSerialType(struct soap *soap, const char *tag, int id, const struct ds__X509IssuerSerialType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__X509IssuerSerialType), type))
		return soap->error;
	if (soap_out_string(soap, "ds:X509IssuerName", -1, &a->X509IssuerName, ""))
		return soap->error;
	if (soap_out_int(soap, "ds:X509SerialNumber", -1, &a->X509SerialNumber, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__X509IssuerSerialType * SOAP_FMAC4 soap_in_ds__X509IssuerSerialType(struct soap *soap, const char *tag, struct ds__X509IssuerSerialType *a, const char *type)
{
	size_t soap_flag_X509IssuerName = 1;
	size_t soap_flag_X509SerialNumber = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__X509IssuerSerialType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__X509IssuerSerialType, sizeof(struct ds__X509IssuerSerialType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__X509IssuerSerialType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_X509IssuerName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:X509IssuerName", &a->X509IssuerName, "xsd:string"))
				{	soap_flag_X509IssuerName--;
					continue;
				}
			if (soap_flag_X509SerialNumber && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ds:X509SerialNumber", &a->X509SerialNumber, "xsd:int"))
				{	soap_flag_X509SerialNumber--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__X509IssuerSerialType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__X509IssuerSerialType, 0, sizeof(struct ds__X509IssuerSerialType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_X509IssuerName > 0 || soap_flag_X509SerialNumber > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__X509IssuerSerialType(struct soap *soap, const struct ds__X509IssuerSerialType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__X509IssuerSerialType);
	if (soap_out_ds__X509IssuerSerialType(soap, tag?tag:"ds:X509IssuerSerialType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__X509IssuerSerialType * SOAP_FMAC4 soap_get_ds__X509IssuerSerialType(struct soap *soap, struct ds__X509IssuerSerialType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__X509IssuerSerialType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__X509DataType(struct soap *soap, struct ds__X509DataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->X509IssuerSerial = NULL;
	soap_default_string(soap, &a->X509SKI);
	soap_default_string(soap, &a->X509SubjectName);
	soap_default_string(soap, &a->X509Certificate);
	soap_default_string(soap, &a->X509CRL);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__X509DataType(struct soap *soap, const struct ds__X509DataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTods__X509IssuerSerialType(soap, &a->X509IssuerSerial);
	soap_serialize_string(soap, &a->X509SKI);
	soap_serialize_string(soap, &a->X509SubjectName);
	soap_serialize_string(soap, &a->X509Certificate);
	soap_serialize_string(soap, &a->X509CRL);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__X509DataType(struct soap *soap, const char *tag, int id, const struct ds__X509DataType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__X509DataType), type))
		return soap->error;
	if (soap_out_PointerTods__X509IssuerSerialType(soap, "ds:X509IssuerSerial", -1, &a->X509IssuerSerial, ""))
		return soap->error;
	if (soap_out_string(soap, "ds:X509SKI", -1, &a->X509SKI, ""))
		return soap->error;
	if (soap_out_string(soap, "ds:X509SubjectName", -1, &a->X509SubjectName, ""))
		return soap->error;
	if (soap_out_string(soap, "ds:X509Certificate", -1, &a->X509Certificate, ""))
		return soap->error;
	if (soap_out_string(soap, "ds:X509CRL", -1, &a->X509CRL, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__X509DataType * SOAP_FMAC4 soap_in_ds__X509DataType(struct soap *soap, const char *tag, struct ds__X509DataType *a, const char *type)
{
	size_t soap_flag_X509IssuerSerial = 1;
	size_t soap_flag_X509SKI = 1;
	size_t soap_flag_X509SubjectName = 1;
	size_t soap_flag_X509Certificate = 1;
	size_t soap_flag_X509CRL = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__X509DataType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__X509DataType, sizeof(struct ds__X509DataType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__X509DataType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_X509IssuerSerial && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__X509IssuerSerialType(soap, "ds:X509IssuerSerial", &a->X509IssuerSerial, "ds:X509IssuerSerialType"))
				{	soap_flag_X509IssuerSerial--;
					continue;
				}
			if (soap_flag_X509SKI && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:X509SKI", &a->X509SKI, "xsd:string"))
				{	soap_flag_X509SKI--;
					continue;
				}
			if (soap_flag_X509SubjectName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:X509SubjectName", &a->X509SubjectName, "xsd:string"))
				{	soap_flag_X509SubjectName--;
					continue;
				}
			if (soap_flag_X509Certificate && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:X509Certificate", &a->X509Certificate, "xsd:string"))
				{	soap_flag_X509Certificate--;
					continue;
				}
			if (soap_flag_X509CRL && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:X509CRL", &a->X509CRL, "xsd:string"))
				{	soap_flag_X509CRL--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__X509DataType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__X509DataType, 0, sizeof(struct ds__X509DataType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_X509IssuerSerial > 0 || soap_flag_X509SKI > 0 || soap_flag_X509SubjectName > 0 || soap_flag_X509Certificate > 0 || soap_flag_X509CRL > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__X509DataType(struct soap *soap, const struct ds__X509DataType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__X509DataType);
	if (soap_out_ds__X509DataType(soap, tag?tag:"ds:X509DataType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__X509DataType * SOAP_FMAC4 soap_get_ds__X509DataType(struct soap *soap, struct ds__X509DataType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__X509DataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__RetrievalMethodType(struct soap *soap, struct ds__RetrievalMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Transforms = NULL;
	soap_default_string(soap, &a->URI);
	soap_default_string(soap, &a->Type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__RetrievalMethodType(struct soap *soap, const struct ds__RetrievalMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTods__TransformsType(soap, &a->Transforms);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__RetrievalMethodType(struct soap *soap, const char *tag, int id, const struct ds__RetrievalMethodType *a, const char *type)
{
	if (a->URI)
		soap_set_attr(soap, "URI", a->URI, 1);
	if (a->Type)
		soap_set_attr(soap, "Type", a->Type, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__RetrievalMethodType), type))
		return soap->error;
	if (soap_out_PointerTods__TransformsType(soap, "ds:Transforms", -1, &a->Transforms, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__RetrievalMethodType * SOAP_FMAC4 soap_in_ds__RetrievalMethodType(struct soap *soap, const char *tag, struct ds__RetrievalMethodType *a, const char *type)
{
	size_t soap_flag_Transforms = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__RetrievalMethodType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__RetrievalMethodType, sizeof(struct ds__RetrievalMethodType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__RetrievalMethodType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "URI", 0), &a->URI, -1, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Type", 0), &a->Type, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Transforms && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__TransformsType(soap, "ds:Transforms", &a->Transforms, "ds:TransformsType"))
				{	soap_flag_Transforms--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__RetrievalMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__RetrievalMethodType, 0, sizeof(struct ds__RetrievalMethodType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__RetrievalMethodType(struct soap *soap, const struct ds__RetrievalMethodType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__RetrievalMethodType);
	if (soap_out_ds__RetrievalMethodType(soap, tag?tag:"ds:RetrievalMethodType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__RetrievalMethodType * SOAP_FMAC4 soap_get_ds__RetrievalMethodType(struct soap *soap, struct ds__RetrievalMethodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__RetrievalMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__KeyValueType(struct soap *soap, struct ds__KeyValueType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->DSAKeyValue = NULL;
	a->RSAKeyValue = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__KeyValueType(struct soap *soap, const struct ds__KeyValueType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTods__DSAKeyValueType(soap, &a->DSAKeyValue);
	soap_serialize_PointerTods__RSAKeyValueType(soap, &a->RSAKeyValue);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__KeyValueType(struct soap *soap, const char *tag, int id, const struct ds__KeyValueType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__KeyValueType), type))
		return soap->error;
	if (soap_out_PointerTods__DSAKeyValueType(soap, "ds:DSAKeyValue", -1, &a->DSAKeyValue, ""))
		return soap->error;
	if (soap_out_PointerTods__RSAKeyValueType(soap, "ds:RSAKeyValue", -1, &a->RSAKeyValue, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__KeyValueType * SOAP_FMAC4 soap_in_ds__KeyValueType(struct soap *soap, const char *tag, struct ds__KeyValueType *a, const char *type)
{
	size_t soap_flag_DSAKeyValue = 1;
	size_t soap_flag_RSAKeyValue = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__KeyValueType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__KeyValueType, sizeof(struct ds__KeyValueType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__KeyValueType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DSAKeyValue && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__DSAKeyValueType(soap, "ds:DSAKeyValue", &a->DSAKeyValue, "ds:DSAKeyValueType"))
				{	soap_flag_DSAKeyValue--;
					continue;
				}
			if (soap_flag_RSAKeyValue && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__RSAKeyValueType(soap, "ds:RSAKeyValue", &a->RSAKeyValue, "ds:RSAKeyValueType"))
				{	soap_flag_RSAKeyValue--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__KeyValueType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__KeyValueType, 0, sizeof(struct ds__KeyValueType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DSAKeyValue > 0 || soap_flag_RSAKeyValue > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__KeyValueType(struct soap *soap, const struct ds__KeyValueType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__KeyValueType);
	if (soap_out_ds__KeyValueType(soap, tag?tag:"ds:KeyValueType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__KeyValueType * SOAP_FMAC4 soap_get_ds__KeyValueType(struct soap *soap, struct ds__KeyValueType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__KeyValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__DigestMethodType(struct soap *soap, struct ds__DigestMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Algorithm);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__DigestMethodType(struct soap *soap, const struct ds__DigestMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__DigestMethodType(struct soap *soap, const char *tag, int id, const struct ds__DigestMethodType *a, const char *type)
{
	if (a->Algorithm)
		soap_set_attr(soap, "Algorithm", a->Algorithm, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__DigestMethodType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__DigestMethodType * SOAP_FMAC4 soap_in_ds__DigestMethodType(struct soap *soap, const char *tag, struct ds__DigestMethodType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__DigestMethodType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__DigestMethodType, sizeof(struct ds__DigestMethodType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__DigestMethodType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 1), &a->Algorithm, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__DigestMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__DigestMethodType, 0, sizeof(struct ds__DigestMethodType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__DigestMethodType(struct soap *soap, const struct ds__DigestMethodType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__DigestMethodType);
	if (soap_out_ds__DigestMethodType(soap, tag?tag:"ds:DigestMethodType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__DigestMethodType * SOAP_FMAC4 soap_get_ds__DigestMethodType(struct soap *soap, struct ds__DigestMethodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__DigestMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__TransformType(struct soap *soap, struct ds__TransformType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->c14n__InclusiveNamespaces = NULL;
	a->__any = NULL;
	soap_default_string(soap, &a->Algorithm);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__TransformType(struct soap *soap, const struct ds__TransformType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_c14n__InclusiveNamespaces(soap, &a->c14n__InclusiveNamespaces);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__TransformType(struct soap *soap, const char *tag, int id, const struct ds__TransformType *a, const char *type)
{
	if (a->Algorithm)
		soap_set_attr(soap, "Algorithm", a->Algorithm, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__TransformType), type))
		return soap->error;
	if (soap_out_PointerTo_c14n__InclusiveNamespaces(soap, "c14n:InclusiveNamespaces", -1, &a->c14n__InclusiveNamespaces, ""))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__TransformType * SOAP_FMAC4 soap_in_ds__TransformType(struct soap *soap, const char *tag, struct ds__TransformType *a, const char *type)
{
	size_t soap_flag_c14n__InclusiveNamespaces = 1;
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__TransformType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__TransformType, sizeof(struct ds__TransformType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__TransformType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 0), &a->Algorithm, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_c14n__InclusiveNamespaces && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_c14n__InclusiveNamespaces(soap, "c14n:InclusiveNamespaces", &a->c14n__InclusiveNamespaces, ""))
				{	soap_flag_c14n__InclusiveNamespaces--;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__TransformType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__TransformType, 0, sizeof(struct ds__TransformType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__TransformType(struct soap *soap, const struct ds__TransformType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__TransformType);
	if (soap_out_ds__TransformType(soap, tag?tag:"ds:TransformType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__TransformType * SOAP_FMAC4 soap_get_ds__TransformType(struct soap *soap, struct ds__TransformType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__TransformType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__c14n__InclusiveNamespaces(struct soap *soap, struct _c14n__InclusiveNamespaces *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->PrefixList);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__c14n__InclusiveNamespaces(struct soap *soap, const struct _c14n__InclusiveNamespaces *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__c14n__InclusiveNamespaces(struct soap *soap, const char *tag, int id, const struct _c14n__InclusiveNamespaces *a, const char *type)
{
	if (a->PrefixList)
		soap_set_attr(soap, "PrefixList", a->PrefixList, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__c14n__InclusiveNamespaces), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _c14n__InclusiveNamespaces * SOAP_FMAC4 soap_in__c14n__InclusiveNamespaces(struct soap *soap, const char *tag, struct _c14n__InclusiveNamespaces *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _c14n__InclusiveNamespaces *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__c14n__InclusiveNamespaces, sizeof(struct _c14n__InclusiveNamespaces), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__c14n__InclusiveNamespaces(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "PrefixList", 0), &a->PrefixList, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _c14n__InclusiveNamespaces *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__c14n__InclusiveNamespaces, 0, sizeof(struct _c14n__InclusiveNamespaces), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__c14n__InclusiveNamespaces(struct soap *soap, const struct _c14n__InclusiveNamespaces *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__c14n__InclusiveNamespaces);
	if (soap_out__c14n__InclusiveNamespaces(soap, tag?tag:"c14n:InclusiveNamespaces", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _c14n__InclusiveNamespaces * SOAP_FMAC4 soap_get__c14n__InclusiveNamespaces(struct soap *soap, struct _c14n__InclusiveNamespaces *p, const char *tag, const char *type)
{
	if ((p = soap_in__c14n__InclusiveNamespaces(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__TransformsType(struct soap *soap, struct ds__TransformsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeTransform = 0;
	a->Transform = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__TransformsType(struct soap *soap, const struct ds__TransformsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Transform)
	{	int i;
		for (i = 0; i < a->__sizeTransform; i++)
		{
			soap_embedded(soap, a->Transform + i, SOAP_TYPE_ds__TransformType);
			soap_serialize_ds__TransformType(soap, a->Transform + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__TransformsType(struct soap *soap, const char *tag, int id, const struct ds__TransformsType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__TransformsType), type))
		return soap->error;
	if (a->Transform)
	{	int i;
		for (i = 0; i < a->__sizeTransform; i++)
			if (soap_out_ds__TransformType(soap, "ds:Transform", -1, a->Transform + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__TransformsType * SOAP_FMAC4 soap_in_ds__TransformsType(struct soap *soap, const char *tag, struct ds__TransformsType *a, const char *type)
{
	struct soap_blist *soap_blist_Transform = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__TransformsType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__TransformsType, sizeof(struct ds__TransformsType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__TransformsType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ds:Transform", 1, NULL))
			{	if (a->Transform == NULL)
				{	if (soap_blist_Transform == NULL)
						soap_blist_Transform = soap_new_block(soap);
					a->Transform = (struct ds__TransformType *)soap_push_block(soap, soap_blist_Transform, sizeof(struct ds__TransformType));
					if (a->Transform == NULL)
						return NULL;
					soap_default_ds__TransformType(soap, a->Transform);
				}soap_revert(soap);
				if (soap_in_ds__TransformType(soap, "ds:Transform", a->Transform, "ds:TransformType"))
				{	a->__sizeTransform++;
					a->Transform = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Transform)
			soap_pop_block(soap, soap_blist_Transform);
		if (a->__sizeTransform)
			a->Transform = (struct ds__TransformType *)soap_save_block(soap, soap_blist_Transform, NULL, 1);
		else
		{	a->Transform = NULL;
			if (soap_blist_Transform)
				soap_end_block(soap, soap_blist_Transform);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__TransformsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__TransformsType, 0, sizeof(struct ds__TransformsType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__TransformsType(struct soap *soap, const struct ds__TransformsType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__TransformsType);
	if (soap_out_ds__TransformsType(soap, tag?tag:"ds:TransformsType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__TransformsType * SOAP_FMAC4 soap_get_ds__TransformsType(struct soap *soap, struct ds__TransformsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__TransformsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__ReferenceType(struct soap *soap, struct ds__ReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Transforms = NULL;
	a->DigestMethod = NULL;
	soap_default_string(soap, &a->DigestValue);
	soap_default_string(soap, &a->Id);
	soap_default_string(soap, &a->URI);
	soap_default_string(soap, &a->Type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__ReferenceType(struct soap *soap, const struct ds__ReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTods__TransformsType(soap, &a->Transforms);
	soap_serialize_PointerTods__DigestMethodType(soap, &a->DigestMethod);
	soap_serialize_string(soap, &a->DigestValue);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__ReferenceType(struct soap *soap, const char *tag, int id, const struct ds__ReferenceType *a, const char *type)
{
	if (a->Id)
		soap_set_attr(soap, "Id", a->Id, 1);
	if (a->URI)
		soap_set_attr(soap, "URI", a->URI, 1);
	if (a->Type)
		soap_set_attr(soap, "Type", a->Type, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__ReferenceType), type))
		return soap->error;
	if (soap_out_PointerTods__TransformsType(soap, "ds:Transforms", -1, &a->Transforms, ""))
		return soap->error;
	if (soap_out_PointerTods__DigestMethodType(soap, "ds:DigestMethod", -1, &a->DigestMethod, ""))
		return soap->error;
	if (soap_out_string(soap, "ds:DigestValue", -1, &a->DigestValue, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__ReferenceType * SOAP_FMAC4 soap_in_ds__ReferenceType(struct soap *soap, const char *tag, struct ds__ReferenceType *a, const char *type)
{
	size_t soap_flag_Transforms = 1;
	size_t soap_flag_DigestMethod = 1;
	size_t soap_flag_DigestValue = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__ReferenceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__ReferenceType, sizeof(struct ds__ReferenceType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__ReferenceType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 0), &a->Id, -1, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "URI", 0), &a->URI, -1, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Type", 0), &a->Type, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Transforms && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__TransformsType(soap, "ds:Transforms", &a->Transforms, "ds:TransformsType"))
				{	soap_flag_Transforms--;
					continue;
				}
			if (soap_flag_DigestMethod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__DigestMethodType(soap, "ds:DigestMethod", &a->DigestMethod, "ds:DigestMethodType"))
				{	soap_flag_DigestMethod--;
					continue;
				}
			if (soap_flag_DigestValue && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:DigestValue", &a->DigestValue, "xsd:string"))
				{	soap_flag_DigestValue--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__ReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__ReferenceType, 0, sizeof(struct ds__ReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DigestMethod > 0 || soap_flag_DigestValue > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__ReferenceType(struct soap *soap, const struct ds__ReferenceType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__ReferenceType);
	if (soap_out_ds__ReferenceType(soap, tag?tag:"ds:ReferenceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__ReferenceType * SOAP_FMAC4 soap_get_ds__ReferenceType(struct soap *soap, struct ds__ReferenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__ReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__SignatureMethodType(struct soap *soap, struct ds__SignatureMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->HMACOutputLength = NULL;
	soap_default_string(soap, &a->Algorithm);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__SignatureMethodType(struct soap *soap, const struct ds__SignatureMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->HMACOutputLength);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__SignatureMethodType(struct soap *soap, const char *tag, int id, const struct ds__SignatureMethodType *a, const char *type)
{
	if (a->Algorithm)
		soap_set_attr(soap, "Algorithm", a->Algorithm, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__SignatureMethodType), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "ds:HMACOutputLength", -1, &a->HMACOutputLength, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__SignatureMethodType * SOAP_FMAC4 soap_in_ds__SignatureMethodType(struct soap *soap, const char *tag, struct ds__SignatureMethodType *a, const char *type)
{
	size_t soap_flag_HMACOutputLength = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__SignatureMethodType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__SignatureMethodType, sizeof(struct ds__SignatureMethodType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__SignatureMethodType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 1), &a->Algorithm, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_HMACOutputLength && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ds:HMACOutputLength", &a->HMACOutputLength, "xsd:int"))
				{	soap_flag_HMACOutputLength--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__SignatureMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__SignatureMethodType, 0, sizeof(struct ds__SignatureMethodType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__SignatureMethodType(struct soap *soap, const struct ds__SignatureMethodType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__SignatureMethodType);
	if (soap_out_ds__SignatureMethodType(soap, tag?tag:"ds:SignatureMethodType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__SignatureMethodType * SOAP_FMAC4 soap_get_ds__SignatureMethodType(struct soap *soap, struct ds__SignatureMethodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__SignatureMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__CanonicalizationMethodType(struct soap *soap, struct ds__CanonicalizationMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Algorithm);
	a->c14n__InclusiveNamespaces = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__CanonicalizationMethodType(struct soap *soap, const struct ds__CanonicalizationMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_c14n__InclusiveNamespaces(soap, &a->c14n__InclusiveNamespaces);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__CanonicalizationMethodType(struct soap *soap, const char *tag, int id, const struct ds__CanonicalizationMethodType *a, const char *type)
{
	if (a->Algorithm)
		soap_set_attr(soap, "Algorithm", a->Algorithm, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__CanonicalizationMethodType), type))
		return soap->error;
	if (soap_out_PointerTo_c14n__InclusiveNamespaces(soap, "c14n:InclusiveNamespaces", -1, &a->c14n__InclusiveNamespaces, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__CanonicalizationMethodType * SOAP_FMAC4 soap_in_ds__CanonicalizationMethodType(struct soap *soap, const char *tag, struct ds__CanonicalizationMethodType *a, const char *type)
{
	size_t soap_flag_c14n__InclusiveNamespaces = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__CanonicalizationMethodType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__CanonicalizationMethodType, sizeof(struct ds__CanonicalizationMethodType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__CanonicalizationMethodType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 1), &a->Algorithm, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_c14n__InclusiveNamespaces && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_c14n__InclusiveNamespaces(soap, "c14n:InclusiveNamespaces", &a->c14n__InclusiveNamespaces, ""))
				{	soap_flag_c14n__InclusiveNamespaces--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__CanonicalizationMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__CanonicalizationMethodType, 0, sizeof(struct ds__CanonicalizationMethodType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__CanonicalizationMethodType(struct soap *soap, const struct ds__CanonicalizationMethodType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__CanonicalizationMethodType);
	if (soap_out_ds__CanonicalizationMethodType(soap, tag?tag:"ds:CanonicalizationMethodType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__CanonicalizationMethodType * SOAP_FMAC4 soap_get_ds__CanonicalizationMethodType(struct soap *soap, struct ds__CanonicalizationMethodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__CanonicalizationMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__KeyInfoType(struct soap *soap, struct ds__KeyInfoType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->KeyName);
	a->KeyValue = NULL;
	a->RetrievalMethod = NULL;
	a->X509Data = NULL;
	a->wsse__SecurityTokenReference = NULL;
	soap_default_string(soap, &a->Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__KeyInfoType(struct soap *soap, const struct ds__KeyInfoType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->KeyName);
	soap_serialize_PointerTods__KeyValueType(soap, &a->KeyValue);
	soap_serialize_PointerTods__RetrievalMethodType(soap, &a->RetrievalMethod);
	soap_serialize_PointerTods__X509DataType(soap, &a->X509Data);
	soap_serialize_PointerTo_wsse__SecurityTokenReference(soap, &a->wsse__SecurityTokenReference);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__KeyInfoType(struct soap *soap, const char *tag, int id, const struct ds__KeyInfoType *a, const char *type)
{
	if (a->Id)
		soap_set_attr(soap, "Id", a->Id, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__KeyInfoType), type))
		return soap->error;
	if (soap_out_string(soap, "ds:KeyName", -1, &a->KeyName, ""))
		return soap->error;
	if (soap_out_PointerTods__KeyValueType(soap, "ds:KeyValue", -1, &a->KeyValue, ""))
		return soap->error;
	if (soap_out_PointerTods__RetrievalMethodType(soap, "ds:RetrievalMethod", -1, &a->RetrievalMethod, ""))
		return soap->error;
	if (soap_out_PointerTods__X509DataType(soap, "ds:X509Data", -1, &a->X509Data, ""))
		return soap->error;
	if (soap_out_PointerTo_wsse__SecurityTokenReference(soap, "wsse:SecurityTokenReference", -1, &a->wsse__SecurityTokenReference, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__KeyInfoType * SOAP_FMAC4 soap_in_ds__KeyInfoType(struct soap *soap, const char *tag, struct ds__KeyInfoType *a, const char *type)
{
	size_t soap_flag_KeyName = 1;
	size_t soap_flag_KeyValue = 1;
	size_t soap_flag_RetrievalMethod = 1;
	size_t soap_flag_X509Data = 1;
	size_t soap_flag_wsse__SecurityTokenReference = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__KeyInfoType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__KeyInfoType, sizeof(struct ds__KeyInfoType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__KeyInfoType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 0), &a->Id, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_KeyName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:KeyName", &a->KeyName, "xsd:string"))
				{	soap_flag_KeyName--;
					continue;
				}
			if (soap_flag_KeyValue && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__KeyValueType(soap, "ds:KeyValue", &a->KeyValue, "ds:KeyValueType"))
				{	soap_flag_KeyValue--;
					continue;
				}
			if (soap_flag_RetrievalMethod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__RetrievalMethodType(soap, "ds:RetrievalMethod", &a->RetrievalMethod, "ds:RetrievalMethodType"))
				{	soap_flag_RetrievalMethod--;
					continue;
				}
			if (soap_flag_X509Data && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__X509DataType(soap, "ds:X509Data", &a->X509Data, "ds:X509DataType"))
				{	soap_flag_X509Data--;
					continue;
				}
			if (soap_flag_wsse__SecurityTokenReference && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__SecurityTokenReference(soap, "wsse:SecurityTokenReference", &a->wsse__SecurityTokenReference, ""))
				{	soap_flag_wsse__SecurityTokenReference--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__KeyInfoType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__KeyInfoType, 0, sizeof(struct ds__KeyInfoType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__KeyInfoType(struct soap *soap, const struct ds__KeyInfoType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__KeyInfoType);
	if (soap_out_ds__KeyInfoType(soap, tag?tag:"ds:KeyInfoType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__KeyInfoType * SOAP_FMAC4 soap_get_ds__KeyInfoType(struct soap *soap, struct ds__KeyInfoType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__KeyInfoType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__SignedInfoType(struct soap *soap, struct ds__SignedInfoType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->CanonicalizationMethod = NULL;
	a->SignatureMethod = NULL;
	a->__sizeReference = 0;
	a->Reference = NULL;
	soap_default_string(soap, &a->Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__SignedInfoType(struct soap *soap, const struct ds__SignedInfoType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTods__CanonicalizationMethodType(soap, &a->CanonicalizationMethod);
	soap_serialize_PointerTods__SignatureMethodType(soap, &a->SignatureMethod);
	if (a->Reference)
	{	int i;
		for (i = 0; i < a->__sizeReference; i++)
		{
			soap_serialize_PointerTods__ReferenceType(soap, a->Reference + i);
		}
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__SignedInfoType(struct soap *soap, const char *tag, int id, const struct ds__SignedInfoType *a, const char *type)
{
	if (a->Id)
		soap_set_attr(soap, "Id", a->Id, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__SignedInfoType), type))
		return soap->error;
	if (soap_out_PointerTods__CanonicalizationMethodType(soap, "ds:CanonicalizationMethod", -1, &a->CanonicalizationMethod, ""))
		return soap->error;
	if (soap_out_PointerTods__SignatureMethodType(soap, "ds:SignatureMethod", -1, &a->SignatureMethod, ""))
		return soap->error;
	if (a->Reference)
	{	int i;
		for (i = 0; i < a->__sizeReference; i++)
			if (soap_out_PointerTods__ReferenceType(soap, "ds:Reference", -1, a->Reference + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__SignedInfoType * SOAP_FMAC4 soap_in_ds__SignedInfoType(struct soap *soap, const char *tag, struct ds__SignedInfoType *a, const char *type)
{
	size_t soap_flag_CanonicalizationMethod = 1;
	size_t soap_flag_SignatureMethod = 1;
	struct soap_blist *soap_blist_Reference = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__SignedInfoType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__SignedInfoType, sizeof(struct ds__SignedInfoType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__SignedInfoType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 0), &a->Id, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CanonicalizationMethod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__CanonicalizationMethodType(soap, "ds:CanonicalizationMethod", &a->CanonicalizationMethod, "ds:CanonicalizationMethodType"))
				{	soap_flag_CanonicalizationMethod--;
					continue;
				}
			if (soap_flag_SignatureMethod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__SignatureMethodType(soap, "ds:SignatureMethod", &a->SignatureMethod, "ds:SignatureMethodType"))
				{	soap_flag_SignatureMethod--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ds:Reference", 1, NULL))
			{	if (a->Reference == NULL)
				{	if (soap_blist_Reference == NULL)
						soap_blist_Reference = soap_new_block(soap);
					a->Reference = (struct ds__ReferenceType **)soap_push_block(soap, soap_blist_Reference, sizeof(struct ds__ReferenceType *));
					if (a->Reference == NULL)
						return NULL;
					*a->Reference = NULL;
				}soap_revert(soap);
				if (soap_in_PointerTods__ReferenceType(soap, "ds:Reference", a->Reference, "ds:ReferenceType"))
				{	a->__sizeReference++;
					a->Reference = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Reference)
			soap_pop_block(soap, soap_blist_Reference);
		if (a->__sizeReference)
			a->Reference = (struct ds__ReferenceType **)soap_save_block(soap, soap_blist_Reference, NULL, 1);
		else
		{	a->Reference = NULL;
			if (soap_blist_Reference)
				soap_end_block(soap, soap_blist_Reference);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__SignedInfoType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__SignedInfoType, 0, sizeof(struct ds__SignedInfoType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CanonicalizationMethod > 0 || soap_flag_SignatureMethod > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__SignedInfoType(struct soap *soap, const struct ds__SignedInfoType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__SignedInfoType);
	if (soap_out_ds__SignedInfoType(soap, tag?tag:"ds:SignedInfoType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__SignedInfoType * SOAP_FMAC4 soap_get_ds__SignedInfoType(struct soap *soap, struct ds__SignedInfoType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__SignedInfoType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__SignatureType(struct soap *soap, struct ds__SignatureType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->SignedInfo = NULL;
	soap_default_string(soap, &a->SignatureValue);
	a->KeyInfo = NULL;
	soap_default_string(soap, &a->Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__SignatureType(struct soap *soap, const struct ds__SignatureType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTods__SignedInfoType(soap, &a->SignedInfo);
	soap_serialize_string(soap, &a->SignatureValue);
	soap_serialize_PointerTods__KeyInfoType(soap, &a->KeyInfo);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__SignatureType(struct soap *soap, const char *tag, int id, const struct ds__SignatureType *a, const char *type)
{
	if (a->Id)
		soap_set_attr(soap, "Id", a->Id, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__SignatureType), type))
		return soap->error;
	if (soap_out_PointerTods__SignedInfoType(soap, "ds:SignedInfo", -1, &a->SignedInfo, ""))
		return soap->error;
	if (soap_out_string(soap, "ds:SignatureValue", -1, &a->SignatureValue, ""))
		return soap->error;
	if (soap_out_PointerTods__KeyInfoType(soap, "ds:KeyInfo", -1, &a->KeyInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__SignatureType * SOAP_FMAC4 soap_in_ds__SignatureType(struct soap *soap, const char *tag, struct ds__SignatureType *a, const char *type)
{
	size_t soap_flag_SignedInfo = 1;
	size_t soap_flag_SignatureValue = 1;
	size_t soap_flag_KeyInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__SignatureType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__SignatureType, sizeof(struct ds__SignatureType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__SignatureType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 0), &a->Id, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SignedInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__SignedInfoType(soap, "ds:SignedInfo", &a->SignedInfo, "ds:SignedInfoType"))
				{	soap_flag_SignedInfo--;
					continue;
				}
			if (soap_flag_SignatureValue && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:SignatureValue", &a->SignatureValue, "xsd:string"))
				{	soap_flag_SignatureValue--;
					continue;
				}
			if (soap_flag_KeyInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__KeyInfoType(soap, "ds:KeyInfo", &a->KeyInfo, "ds:KeyInfoType"))
				{	soap_flag_KeyInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__SignatureType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__SignatureType, 0, sizeof(struct ds__SignatureType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__SignatureType(struct soap *soap, const struct ds__SignatureType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__SignatureType);
	if (soap_out_ds__SignatureType(soap, tag?tag:"ds:SignatureType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__SignatureType * SOAP_FMAC4 soap_get_ds__SignatureType(struct soap *soap, struct ds__SignatureType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__SignatureType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__SecurityTokenReference(struct soap *soap, struct _wsse__SecurityTokenReference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Reference = NULL;
	a->KeyIdentifier = NULL;
	a->Embedded = NULL;
	soap_default_string(soap, &a->wsu__Id);
	soap_default_string(soap, &a->Usage);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__SecurityTokenReference(struct soap *soap, const struct _wsse__SecurityTokenReference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_wsse__Reference(soap, &a->Reference);
	soap_serialize_PointerTo_wsse__KeyIdentifier(soap, &a->KeyIdentifier);
	soap_serialize_PointerTo_wsse__Embedded(soap, &a->Embedded);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__SecurityTokenReference(struct soap *soap, const char *tag, int id, const struct _wsse__SecurityTokenReference *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", a->wsu__Id, 1);
	if (a->Usage)
		soap_set_attr(soap, "Usage", a->Usage, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsse__SecurityTokenReference), type))
		return soap->error;
	if (soap_out_PointerTo_wsse__Reference(soap, "wsse:Reference", -1, &a->Reference, ""))
		return soap->error;
	if (soap_out_PointerTo_wsse__KeyIdentifier(soap, "wsse:KeyIdentifier", -1, &a->KeyIdentifier, ""))
		return soap->error;
	if (soap_out_PointerTo_wsse__Embedded(soap, "wsse:Embedded", -1, &a->Embedded, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsse__SecurityTokenReference * SOAP_FMAC4 soap_in__wsse__SecurityTokenReference(struct soap *soap, const char *tag, struct _wsse__SecurityTokenReference *a, const char *type)
{
	size_t soap_flag_Reference = 1;
	size_t soap_flag_KeyIdentifier = 1;
	size_t soap_flag_Embedded = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsse__SecurityTokenReference *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__SecurityTokenReference, sizeof(struct _wsse__SecurityTokenReference), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsse__SecurityTokenReference(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 0), &a->wsu__Id, -1, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Usage", 0), &a->Usage, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Reference && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__Reference(soap, "wsse:Reference", &a->Reference, ""))
				{	soap_flag_Reference--;
					continue;
				}
			if (soap_flag_KeyIdentifier && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__KeyIdentifier(soap, "wsse:KeyIdentifier", &a->KeyIdentifier, ""))
				{	soap_flag_KeyIdentifier--;
					continue;
				}
			if (soap_flag_Embedded && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__Embedded(soap, "wsse:Embedded", &a->Embedded, ""))
				{	soap_flag_Embedded--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsse__SecurityTokenReference *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsse__SecurityTokenReference, 0, sizeof(struct _wsse__SecurityTokenReference), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__SecurityTokenReference(struct soap *soap, const struct _wsse__SecurityTokenReference *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__SecurityTokenReference);
	if (soap_out__wsse__SecurityTokenReference(soap, tag?tag:"wsse:SecurityTokenReference", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__SecurityTokenReference * SOAP_FMAC4 soap_get__wsse__SecurityTokenReference(struct soap *soap, struct _wsse__SecurityTokenReference *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__SecurityTokenReference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__KeyIdentifier(struct soap *soap, struct _wsse__KeyIdentifier *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_string(soap, &a->wsu__Id);
	soap_default_string(soap, &a->ValueType);
	soap_default_string(soap, &a->EncodingType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__KeyIdentifier(struct soap *soap, const struct _wsse__KeyIdentifier *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__KeyIdentifier(struct soap *soap, const char *tag, int id, const struct _wsse__KeyIdentifier *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", a->wsu__Id, 1);
	if (a->ValueType)
		soap_set_attr(soap, "ValueType", a->ValueType, 1);
	if (a->EncodingType)
		soap_set_attr(soap, "EncodingType", a->EncodingType, 1);
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct _wsse__KeyIdentifier * SOAP_FMAC4 soap_in__wsse__KeyIdentifier(struct soap *soap, const char *tag, struct _wsse__KeyIdentifier *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct _wsse__KeyIdentifier *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__KeyIdentifier, sizeof(struct _wsse__KeyIdentifier), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsse__KeyIdentifier(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 0), &a->wsu__Id, -1, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "ValueType", 0), &a->ValueType, -1, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "EncodingType", 0), &a->EncodingType, -1, -1))
		return NULL;
	if (!soap_in_string(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__KeyIdentifier(struct soap *soap, const struct _wsse__KeyIdentifier *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__KeyIdentifier);
	if (soap_out__wsse__KeyIdentifier(soap, tag?tag:"wsse:KeyIdentifier", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__KeyIdentifier * SOAP_FMAC4 soap_get__wsse__KeyIdentifier(struct soap *soap, struct _wsse__KeyIdentifier *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__KeyIdentifier(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__Embedded(struct soap *soap, struct _wsse__Embedded *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->wsu__Id);
	soap_default_string(soap, &a->ValueType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__Embedded(struct soap *soap, const struct _wsse__Embedded *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__Embedded(struct soap *soap, const char *tag, int id, const struct _wsse__Embedded *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", a->wsu__Id, 1);
	if (a->ValueType)
		soap_set_attr(soap, "ValueType", a->ValueType, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsse__Embedded), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsse__Embedded * SOAP_FMAC4 soap_in__wsse__Embedded(struct soap *soap, const char *tag, struct _wsse__Embedded *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsse__Embedded *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__Embedded, sizeof(struct _wsse__Embedded), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsse__Embedded(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 0), &a->wsu__Id, -1, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "ValueType", 0), &a->ValueType, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsse__Embedded *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsse__Embedded, 0, sizeof(struct _wsse__Embedded), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__Embedded(struct soap *soap, const struct _wsse__Embedded *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__Embedded);
	if (soap_out__wsse__Embedded(soap, tag?tag:"wsse:Embedded", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Embedded * SOAP_FMAC4 soap_get__wsse__Embedded(struct soap *soap, struct _wsse__Embedded *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__Embedded(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__Reference(struct soap *soap, struct _wsse__Reference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->URI);
	soap_default_string(soap, &a->ValueType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__Reference(struct soap *soap, const struct _wsse__Reference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__Reference(struct soap *soap, const char *tag, int id, const struct _wsse__Reference *a, const char *type)
{
	if (a->URI)
		soap_set_attr(soap, "URI", a->URI, 1);
	if (a->ValueType)
		soap_set_attr(soap, "ValueType", a->ValueType, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsse__Reference), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsse__Reference * SOAP_FMAC4 soap_in__wsse__Reference(struct soap *soap, const char *tag, struct _wsse__Reference *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsse__Reference *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__Reference, sizeof(struct _wsse__Reference), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsse__Reference(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "URI", 0), &a->URI, -1, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "ValueType", 0), &a->ValueType, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsse__Reference *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsse__Reference, 0, sizeof(struct _wsse__Reference), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__Reference(struct soap *soap, const struct _wsse__Reference *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__Reference);
	if (soap_out__wsse__Reference(soap, tag?tag:"wsse:Reference", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Reference * SOAP_FMAC4 soap_get__wsse__Reference(struct soap *soap, struct _wsse__Reference *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__Reference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__BinarySecurityToken(struct soap *soap, struct _wsse__BinarySecurityToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_string(soap, &a->wsu__Id);
	soap_default_string(soap, &a->ValueType);
	soap_default_string(soap, &a->EncodingType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__BinarySecurityToken(struct soap *soap, const struct _wsse__BinarySecurityToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__BinarySecurityToken(struct soap *soap, const char *tag, int id, const struct _wsse__BinarySecurityToken *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", a->wsu__Id, 1);
	if (a->ValueType)
		soap_set_attr(soap, "ValueType", a->ValueType, 1);
	if (a->EncodingType)
		soap_set_attr(soap, "EncodingType", a->EncodingType, 1);
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct _wsse__BinarySecurityToken * SOAP_FMAC4 soap_in__wsse__BinarySecurityToken(struct soap *soap, const char *tag, struct _wsse__BinarySecurityToken *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct _wsse__BinarySecurityToken *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__BinarySecurityToken, sizeof(struct _wsse__BinarySecurityToken), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsse__BinarySecurityToken(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 0), &a->wsu__Id, -1, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "ValueType", 0), &a->ValueType, -1, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "EncodingType", 0), &a->EncodingType, -1, -1))
		return NULL;
	if (!soap_in_string(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__BinarySecurityToken(struct soap *soap, const struct _wsse__BinarySecurityToken *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__BinarySecurityToken);
	if (soap_out__wsse__BinarySecurityToken(soap, tag?tag:"wsse:BinarySecurityToken", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__BinarySecurityToken * SOAP_FMAC4 soap_get__wsse__BinarySecurityToken(struct soap *soap, struct _wsse__BinarySecurityToken *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__BinarySecurityToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__Password(struct soap *soap, struct _wsse__Password *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_string(soap, &a->Type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__Password(struct soap *soap, const struct _wsse__Password *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->__item);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__Password(struct soap *soap, const char *tag, int id, const struct _wsse__Password *a, const char *type)
{
	if (a->Type)
		soap_set_attr(soap, "Type", a->Type, 1);
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct _wsse__Password * SOAP_FMAC4 soap_in__wsse__Password(struct soap *soap, const char *tag, struct _wsse__Password *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct _wsse__Password *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__Password, sizeof(struct _wsse__Password), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsse__Password(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Type", 0), &a->Type, -1, -1))
		return NULL;
	if (!soap_in_string(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__Password(struct soap *soap, const struct _wsse__Password *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__Password);
	if (soap_out__wsse__Password(soap, tag?tag:"wsse:Password", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Password * SOAP_FMAC4 soap_get__wsse__Password(struct soap *soap, struct _wsse__Password *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__Password(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__UsernameToken(struct soap *soap, struct _wsse__UsernameToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Username);
	a->Password = NULL;
	soap_default_string(soap, &a->Nonce);
	soap_default_string(soap, &a->wsu__Created);
	soap_default_string(soap, &a->wsu__Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__UsernameToken(struct soap *soap, const struct _wsse__UsernameToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Username);
	soap_serialize_PointerTo_wsse__Password(soap, &a->Password);
	soap_serialize_string(soap, &a->Nonce);
	soap_serialize_string(soap, &a->wsu__Created);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__UsernameToken(struct soap *soap, const char *tag, int id, const struct _wsse__UsernameToken *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", a->wsu__Id, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsse__UsernameToken), type))
		return soap->error;
	if (soap_out_string(soap, "wsse:Username", -1, &a->Username, ""))
		return soap->error;
	if (soap_out_PointerTo_wsse__Password(soap, "wsse:Password", -1, &a->Password, ""))
		return soap->error;
	if (soap_out_string(soap, "wsse:Nonce", -1, &a->Nonce, ""))
		return soap->error;
	if (soap_out_string(soap, "wsu:Created", -1, &a->wsu__Created, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsse__UsernameToken * SOAP_FMAC4 soap_in__wsse__UsernameToken(struct soap *soap, const char *tag, struct _wsse__UsernameToken *a, const char *type)
{
	size_t soap_flag_Username = 1;
	size_t soap_flag_Password = 1;
	size_t soap_flag_Nonce = 1;
	size_t soap_flag_wsu__Created = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsse__UsernameToken *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__UsernameToken, sizeof(struct _wsse__UsernameToken), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsse__UsernameToken(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 0), &a->wsu__Id, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsse:Username", &a->Username, "xsd:string"))
				{	soap_flag_Username--;
					continue;
				}
			if (soap_flag_Password && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__Password(soap, "wsse:Password", &a->Password, ""))
				{	soap_flag_Password--;
					continue;
				}
			if (soap_flag_Nonce && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsse:Nonce", &a->Nonce, "xsd:string"))
				{	soap_flag_Nonce--;
					continue;
				}
			if (soap_flag_wsu__Created && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsu:Created", &a->wsu__Created, "xsd:string"))
				{	soap_flag_wsu__Created--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsse__UsernameToken *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsse__UsernameToken, 0, sizeof(struct _wsse__UsernameToken), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__UsernameToken(struct soap *soap, const struct _wsse__UsernameToken *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__UsernameToken);
	if (soap_out__wsse__UsernameToken(soap, tag?tag:"wsse:UsernameToken", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__UsernameToken * SOAP_FMAC4 soap_get__wsse__UsernameToken(struct soap *soap, struct _wsse__UsernameToken *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__UsernameToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsu__Timestamp(struct soap *soap, struct _wsu__Timestamp *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->wsu__Id);
	soap_default_string(soap, &a->Created);
	soap_default_string(soap, &a->Expires);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsu__Timestamp(struct soap *soap, const struct _wsu__Timestamp *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Created);
	soap_serialize_string(soap, &a->Expires);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsu__Timestamp(struct soap *soap, const char *tag, int id, const struct _wsu__Timestamp *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", a->wsu__Id, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsu__Timestamp), type))
		return soap->error;
	if (soap_out_string(soap, "wsu:Created", -1, &a->Created, ""))
		return soap->error;
	if (soap_out_string(soap, "wsu:Expires", -1, &a->Expires, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsu__Timestamp * SOAP_FMAC4 soap_in__wsu__Timestamp(struct soap *soap, const char *tag, struct _wsu__Timestamp *a, const char *type)
{
	size_t soap_flag_Created = 1;
	size_t soap_flag_Expires = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsu__Timestamp *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsu__Timestamp, sizeof(struct _wsu__Timestamp), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsu__Timestamp(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 0), &a->wsu__Id, -1, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Created && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsu:Created", &a->Created, "xsd:string"))
				{	soap_flag_Created--;
					continue;
				}
			if (soap_flag_Expires && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsu:Expires", &a->Expires, "xsd:string"))
				{	soap_flag_Expires--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsu__Timestamp *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsu__Timestamp, 0, sizeof(struct _wsu__Timestamp), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsu__Timestamp(struct soap *soap, const struct _wsu__Timestamp *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsu__Timestamp);
	if (soap_out__wsu__Timestamp(soap, tag?tag:"wsu:Timestamp", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsu__Timestamp * SOAP_FMAC4 soap_get__wsu__Timestamp(struct soap *soap, struct _wsu__Timestamp *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsu__Timestamp(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobmd230__deleteCascadeLinksList(struct soap *soap, struct bmd230__deleteCascadeLinksList *const*a)
{
	if (*a)
		soap_serialize_bmd230__deleteCascadeLinksList(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobmd230__deleteCascadeLinksList(struct soap *soap, const char *tag, int id, struct bmd230__deleteCascadeLinksList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_bmd230__deleteCascadeLinksList);
	if (id < 0)
		return soap->error;
	return soap_out_bmd230__deleteCascadeLinksList(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bmd230__deleteCascadeLinksList ** SOAP_FMAC4 soap_in_PointerTobmd230__deleteCascadeLinksList(struct soap *soap, const char *tag, struct bmd230__deleteCascadeLinksList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bmd230__deleteCascadeLinksList **)soap_malloc(soap, sizeof(struct bmd230__deleteCascadeLinksList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bmd230__deleteCascadeLinksList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bmd230__deleteCascadeLinksList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bmd230__deleteCascadeLinksList, sizeof(struct bmd230__deleteCascadeLinksList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobmd230__deleteCascadeLinksList(struct soap *soap, struct bmd230__deleteCascadeLinksList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobmd230__deleteCascadeLinksList);
	if (soap_out_PointerTobmd230__deleteCascadeLinksList(soap, tag?tag:"bmd230:deleteCascadeLinksList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__deleteCascadeLinksList ** SOAP_FMAC4 soap_get_PointerTobmd230__deleteCascadeLinksList(struct soap *soap, struct bmd230__deleteCascadeLinksList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobmd230__deleteCascadeLinksList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTobmd230__manyCascadeLinksResult(struct soap *soap, struct bmd230__manyCascadeLinksResult **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTobmd230__manyCascadeLinksResult))
		soap_serialize_PointerTobmd230__manyCascadeLinksResult(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTobmd230__manyCascadeLinksResult(struct soap *soap, const char *tag, int id, struct bmd230__manyCascadeLinksResult **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTobmd230__manyCascadeLinksResult);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTobmd230__manyCascadeLinksResult(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bmd230__manyCascadeLinksResult *** SOAP_FMAC4 soap_in_PointerToPointerTobmd230__manyCascadeLinksResult(struct soap *soap, const char *tag, struct bmd230__manyCascadeLinksResult ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bmd230__manyCascadeLinksResult ***)soap_malloc(soap, sizeof(struct bmd230__manyCascadeLinksResult **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTobmd230__manyCascadeLinksResult(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bmd230__manyCascadeLinksResult ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTobmd230__manyCascadeLinksResult, sizeof(struct bmd230__manyCascadeLinksResult *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTobmd230__manyCascadeLinksResult(struct soap *soap, struct bmd230__manyCascadeLinksResult **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTobmd230__manyCascadeLinksResult);
	if (soap_out_PointerToPointerTobmd230__manyCascadeLinksResult(soap, tag?tag:"bmd230:manyCascadeLinksResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__manyCascadeLinksResult *** SOAP_FMAC4 soap_get_PointerToPointerTobmd230__manyCascadeLinksResult(struct soap *soap, struct bmd230__manyCascadeLinksResult ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTobmd230__manyCascadeLinksResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobmd230__manyCascadeLinksResult(struct soap *soap, struct bmd230__manyCascadeLinksResult *const*a)
{
	if (*a)
		soap_serialize_bmd230__manyCascadeLinksResult(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobmd230__manyCascadeLinksResult(struct soap *soap, const char *tag, int id, struct bmd230__manyCascadeLinksResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_bmd230__manyCascadeLinksResult);
	if (id < 0)
		return soap->error;
	return soap_out_bmd230__manyCascadeLinksResult(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bmd230__manyCascadeLinksResult ** SOAP_FMAC4 soap_in_PointerTobmd230__manyCascadeLinksResult(struct soap *soap, const char *tag, struct bmd230__manyCascadeLinksResult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bmd230__manyCascadeLinksResult **)soap_malloc(soap, sizeof(struct bmd230__manyCascadeLinksResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bmd230__manyCascadeLinksResult(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bmd230__manyCascadeLinksResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bmd230__manyCascadeLinksResult, sizeof(struct bmd230__manyCascadeLinksResult), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobmd230__manyCascadeLinksResult(struct soap *soap, struct bmd230__manyCascadeLinksResult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobmd230__manyCascadeLinksResult);
	if (soap_out_PointerTobmd230__manyCascadeLinksResult(soap, tag?tag:"bmd230:manyCascadeLinksResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__manyCascadeLinksResult ** SOAP_FMAC4 soap_get_PointerTobmd230__manyCascadeLinksResult(struct soap *soap, struct bmd230__manyCascadeLinksResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobmd230__manyCascadeLinksResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobmd230__cascadeLinksInfo(struct soap *soap, struct bmd230__cascadeLinksInfo *const*a)
{
	if (*a)
		soap_serialize_bmd230__cascadeLinksInfo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobmd230__cascadeLinksInfo(struct soap *soap, const char *tag, int id, struct bmd230__cascadeLinksInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_bmd230__cascadeLinksInfo);
	if (id < 0)
		return soap->error;
	return soap_out_bmd230__cascadeLinksInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bmd230__cascadeLinksInfo ** SOAP_FMAC4 soap_in_PointerTobmd230__cascadeLinksInfo(struct soap *soap, const char *tag, struct bmd230__cascadeLinksInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bmd230__cascadeLinksInfo **)soap_malloc(soap, sizeof(struct bmd230__cascadeLinksInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bmd230__cascadeLinksInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bmd230__cascadeLinksInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bmd230__cascadeLinksInfo, sizeof(struct bmd230__cascadeLinksInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobmd230__cascadeLinksInfo(struct soap *soap, struct bmd230__cascadeLinksInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobmd230__cascadeLinksInfo);
	if (soap_out_PointerTobmd230__cascadeLinksInfo(soap, tag?tag:"bmd230:cascadeLinksInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__cascadeLinksInfo ** SOAP_FMAC4 soap_get_PointerTobmd230__cascadeLinksInfo(struct soap *soap, struct bmd230__cascadeLinksInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobmd230__cascadeLinksInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobmd230__linksInfo(struct soap *soap, struct bmd230__linksInfo *const*a)
{
	if (*a)
		soap_serialize_bmd230__linksInfo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobmd230__linksInfo(struct soap *soap, const char *tag, int id, struct bmd230__linksInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_bmd230__linksInfo);
	if (id < 0)
		return soap->error;
	return soap_out_bmd230__linksInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bmd230__linksInfo ** SOAP_FMAC4 soap_in_PointerTobmd230__linksInfo(struct soap *soap, const char *tag, struct bmd230__linksInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bmd230__linksInfo **)soap_malloc(soap, sizeof(struct bmd230__linksInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bmd230__linksInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bmd230__linksInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bmd230__linksInfo, sizeof(struct bmd230__linksInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobmd230__linksInfo(struct soap *soap, struct bmd230__linksInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobmd230__linksInfo);
	if (soap_out_PointerTobmd230__linksInfo(soap, tag?tag:"bmd230:linksInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__linksInfo ** SOAP_FMAC4 soap_get_PointerTobmd230__linksInfo(struct soap *soap, struct bmd230__linksInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobmd230__linksInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTobmd230__archPackOut(struct soap *soap, struct bmd230__archPackOut **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTobmd230__archPackOut))
		soap_serialize_PointerTobmd230__archPackOut(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTobmd230__archPackOut(struct soap *soap, const char *tag, int id, struct bmd230__archPackOut **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTobmd230__archPackOut);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTobmd230__archPackOut(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bmd230__archPackOut *** SOAP_FMAC4 soap_in_PointerToPointerTobmd230__archPackOut(struct soap *soap, const char *tag, struct bmd230__archPackOut ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bmd230__archPackOut ***)soap_malloc(soap, sizeof(struct bmd230__archPackOut **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTobmd230__archPackOut(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bmd230__archPackOut ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTobmd230__archPackOut, sizeof(struct bmd230__archPackOut *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTobmd230__archPackOut(struct soap *soap, struct bmd230__archPackOut **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTobmd230__archPackOut);
	if (soap_out_PointerToPointerTobmd230__archPackOut(soap, tag?tag:"bmd230:archPackOut", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__archPackOut *** SOAP_FMAC4 soap_get_PointerToPointerTobmd230__archPackOut(struct soap *soap, struct bmd230__archPackOut ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTobmd230__archPackOut(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobmd230__archPackOut(struct soap *soap, struct bmd230__archPackOut *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bmd230__archPackOut))
		soap_serialize_bmd230__archPackOut(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobmd230__archPackOut(struct soap *soap, const char *tag, int id, struct bmd230__archPackOut *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bmd230__archPackOut);
	if (id < 0)
		return soap->error;
	return soap_out_bmd230__archPackOut(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bmd230__archPackOut ** SOAP_FMAC4 soap_in_PointerTobmd230__archPackOut(struct soap *soap, const char *tag, struct bmd230__archPackOut **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bmd230__archPackOut **)soap_malloc(soap, sizeof(struct bmd230__archPackOut *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bmd230__archPackOut(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bmd230__archPackOut **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bmd230__archPackOut, sizeof(struct bmd230__archPackOut), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobmd230__archPackOut(struct soap *soap, struct bmd230__archPackOut *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobmd230__archPackOut);
	if (soap_out_PointerTobmd230__archPackOut(soap, tag?tag:"bmd230:archPackOut", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__archPackOut ** SOAP_FMAC4 soap_get_PointerTobmd230__archPackOut(struct soap *soap, struct bmd230__archPackOut **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobmd230__archPackOut(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTobmd230__fileInfoList(struct soap *soap, struct bmd230__fileInfoList **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTobmd230__fileInfoList))
		soap_serialize_PointerTobmd230__fileInfoList(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTobmd230__fileInfoList(struct soap *soap, const char *tag, int id, struct bmd230__fileInfoList **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTobmd230__fileInfoList);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTobmd230__fileInfoList(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bmd230__fileInfoList *** SOAP_FMAC4 soap_in_PointerToPointerTobmd230__fileInfoList(struct soap *soap, const char *tag, struct bmd230__fileInfoList ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bmd230__fileInfoList ***)soap_malloc(soap, sizeof(struct bmd230__fileInfoList **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTobmd230__fileInfoList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bmd230__fileInfoList ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTobmd230__fileInfoList, sizeof(struct bmd230__fileInfoList *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTobmd230__fileInfoList(struct soap *soap, struct bmd230__fileInfoList **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTobmd230__fileInfoList);
	if (soap_out_PointerToPointerTobmd230__fileInfoList(soap, tag?tag:"bmd230:fileInfoList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__fileInfoList *** SOAP_FMAC4 soap_get_PointerToPointerTobmd230__fileInfoList(struct soap *soap, struct bmd230__fileInfoList ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTobmd230__fileInfoList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobmd230__fileInfoList(struct soap *soap, struct bmd230__fileInfoList *const*a)
{
	if (*a)
		soap_serialize_bmd230__fileInfoList(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobmd230__fileInfoList(struct soap *soap, const char *tag, int id, struct bmd230__fileInfoList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_bmd230__fileInfoList);
	if (id < 0)
		return soap->error;
	return soap_out_bmd230__fileInfoList(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bmd230__fileInfoList ** SOAP_FMAC4 soap_in_PointerTobmd230__fileInfoList(struct soap *soap, const char *tag, struct bmd230__fileInfoList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bmd230__fileInfoList **)soap_malloc(soap, sizeof(struct bmd230__fileInfoList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bmd230__fileInfoList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bmd230__fileInfoList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bmd230__fileInfoList, sizeof(struct bmd230__fileInfoList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobmd230__fileInfoList(struct soap *soap, struct bmd230__fileInfoList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobmd230__fileInfoList);
	if (soap_out_PointerTobmd230__fileInfoList(soap, tag?tag:"bmd230:fileInfoList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__fileInfoList ** SOAP_FMAC4 soap_get_PointerTobmd230__fileInfoList(struct soap *soap, struct bmd230__fileInfoList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobmd230__fileInfoList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTobmd230__stringList(struct soap *soap, struct bmd230__stringList **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTobmd230__stringList))
		soap_serialize_PointerTobmd230__stringList(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTobmd230__stringList(struct soap *soap, const char *tag, int id, struct bmd230__stringList **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTobmd230__stringList);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTobmd230__stringList(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bmd230__stringList *** SOAP_FMAC4 soap_in_PointerToPointerTobmd230__stringList(struct soap *soap, const char *tag, struct bmd230__stringList ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bmd230__stringList ***)soap_malloc(soap, sizeof(struct bmd230__stringList **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTobmd230__stringList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bmd230__stringList ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTobmd230__stringList, sizeof(struct bmd230__stringList *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTobmd230__stringList(struct soap *soap, struct bmd230__stringList **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTobmd230__stringList);
	if (soap_out_PointerToPointerTobmd230__stringList(soap, tag?tag:"bmd230:stringList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__stringList *** SOAP_FMAC4 soap_get_PointerToPointerTobmd230__stringList(struct soap *soap, struct bmd230__stringList ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTobmd230__stringList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTobmd230__ActionsHistoryList(struct soap *soap, struct bmd230__ActionsHistoryList **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTobmd230__ActionsHistoryList))
		soap_serialize_PointerTobmd230__ActionsHistoryList(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTobmd230__ActionsHistoryList(struct soap *soap, const char *tag, int id, struct bmd230__ActionsHistoryList **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTobmd230__ActionsHistoryList);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTobmd230__ActionsHistoryList(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bmd230__ActionsHistoryList *** SOAP_FMAC4 soap_in_PointerToPointerTobmd230__ActionsHistoryList(struct soap *soap, const char *tag, struct bmd230__ActionsHistoryList ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bmd230__ActionsHistoryList ***)soap_malloc(soap, sizeof(struct bmd230__ActionsHistoryList **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTobmd230__ActionsHistoryList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bmd230__ActionsHistoryList ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTobmd230__ActionsHistoryList, sizeof(struct bmd230__ActionsHistoryList *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTobmd230__ActionsHistoryList(struct soap *soap, struct bmd230__ActionsHistoryList **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTobmd230__ActionsHistoryList);
	if (soap_out_PointerToPointerTobmd230__ActionsHistoryList(soap, tag?tag:"bmd230:ActionsHistoryList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__ActionsHistoryList *** SOAP_FMAC4 soap_get_PointerToPointerTobmd230__ActionsHistoryList(struct soap *soap, struct bmd230__ActionsHistoryList ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTobmd230__ActionsHistoryList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobmd230__ActionsHistoryList(struct soap *soap, struct bmd230__ActionsHistoryList *const*a)
{
	if (*a)
		soap_serialize_bmd230__ActionsHistoryList(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobmd230__ActionsHistoryList(struct soap *soap, const char *tag, int id, struct bmd230__ActionsHistoryList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_bmd230__ActionsHistoryList);
	if (id < 0)
		return soap->error;
	return soap_out_bmd230__ActionsHistoryList(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bmd230__ActionsHistoryList ** SOAP_FMAC4 soap_in_PointerTobmd230__ActionsHistoryList(struct soap *soap, const char *tag, struct bmd230__ActionsHistoryList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bmd230__ActionsHistoryList **)soap_malloc(soap, sizeof(struct bmd230__ActionsHistoryList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bmd230__ActionsHistoryList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bmd230__ActionsHistoryList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bmd230__ActionsHistoryList, sizeof(struct bmd230__ActionsHistoryList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobmd230__ActionsHistoryList(struct soap *soap, struct bmd230__ActionsHistoryList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobmd230__ActionsHistoryList);
	if (soap_out_PointerTobmd230__ActionsHistoryList(soap, tag?tag:"bmd230:ActionsHistoryList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__ActionsHistoryList ** SOAP_FMAC4 soap_get_PointerTobmd230__ActionsHistoryList(struct soap *soap, struct bmd230__ActionsHistoryList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobmd230__ActionsHistoryList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTobmd230__GetVersionsHistoryResultList(struct soap *soap, struct bmd230__GetVersionsHistoryResultList **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTobmd230__GetVersionsHistoryResultList))
		soap_serialize_PointerTobmd230__GetVersionsHistoryResultList(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTobmd230__GetVersionsHistoryResultList(struct soap *soap, const char *tag, int id, struct bmd230__GetVersionsHistoryResultList **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTobmd230__GetVersionsHistoryResultList);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTobmd230__GetVersionsHistoryResultList(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bmd230__GetVersionsHistoryResultList *** SOAP_FMAC4 soap_in_PointerToPointerTobmd230__GetVersionsHistoryResultList(struct soap *soap, const char *tag, struct bmd230__GetVersionsHistoryResultList ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bmd230__GetVersionsHistoryResultList ***)soap_malloc(soap, sizeof(struct bmd230__GetVersionsHistoryResultList **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTobmd230__GetVersionsHistoryResultList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bmd230__GetVersionsHistoryResultList ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTobmd230__GetVersionsHistoryResultList, sizeof(struct bmd230__GetVersionsHistoryResultList *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTobmd230__GetVersionsHistoryResultList(struct soap *soap, struct bmd230__GetVersionsHistoryResultList **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTobmd230__GetVersionsHistoryResultList);
	if (soap_out_PointerToPointerTobmd230__GetVersionsHistoryResultList(soap, tag?tag:"bmd230:GetVersionsHistoryResultList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__GetVersionsHistoryResultList *** SOAP_FMAC4 soap_get_PointerToPointerTobmd230__GetVersionsHistoryResultList(struct soap *soap, struct bmd230__GetVersionsHistoryResultList ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTobmd230__GetVersionsHistoryResultList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobmd230__GetVersionsHistoryResultList(struct soap *soap, struct bmd230__GetVersionsHistoryResultList *const*a)
{
	if (*a)
		soap_serialize_bmd230__GetVersionsHistoryResultList(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobmd230__GetVersionsHistoryResultList(struct soap *soap, const char *tag, int id, struct bmd230__GetVersionsHistoryResultList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_bmd230__GetVersionsHistoryResultList);
	if (id < 0)
		return soap->error;
	return soap_out_bmd230__GetVersionsHistoryResultList(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bmd230__GetVersionsHistoryResultList ** SOAP_FMAC4 soap_in_PointerTobmd230__GetVersionsHistoryResultList(struct soap *soap, const char *tag, struct bmd230__GetVersionsHistoryResultList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bmd230__GetVersionsHistoryResultList **)soap_malloc(soap, sizeof(struct bmd230__GetVersionsHistoryResultList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bmd230__GetVersionsHistoryResultList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bmd230__GetVersionsHistoryResultList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bmd230__GetVersionsHistoryResultList, sizeof(struct bmd230__GetVersionsHistoryResultList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobmd230__GetVersionsHistoryResultList(struct soap *soap, struct bmd230__GetVersionsHistoryResultList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobmd230__GetVersionsHistoryResultList);
	if (soap_out_PointerTobmd230__GetVersionsHistoryResultList(soap, tag?tag:"bmd230:GetVersionsHistoryResultList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__GetVersionsHistoryResultList ** SOAP_FMAC4 soap_get_PointerTobmd230__GetVersionsHistoryResultList(struct soap *soap, struct bmd230__GetVersionsHistoryResultList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobmd230__GetVersionsHistoryResultList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobmd230__LongNumbersList(struct soap *soap, struct bmd230__LongNumbersList *const*a)
{
	if (*a)
		soap_serialize_bmd230__LongNumbersList(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobmd230__LongNumbersList(struct soap *soap, const char *tag, int id, struct bmd230__LongNumbersList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_bmd230__LongNumbersList);
	if (id < 0)
		return soap->error;
	return soap_out_bmd230__LongNumbersList(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bmd230__LongNumbersList ** SOAP_FMAC4 soap_in_PointerTobmd230__LongNumbersList(struct soap *soap, const char *tag, struct bmd230__LongNumbersList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bmd230__LongNumbersList **)soap_malloc(soap, sizeof(struct bmd230__LongNumbersList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bmd230__LongNumbersList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bmd230__LongNumbersList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bmd230__LongNumbersList, sizeof(struct bmd230__LongNumbersList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobmd230__LongNumbersList(struct soap *soap, struct bmd230__LongNumbersList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobmd230__LongNumbersList);
	if (soap_out_PointerTobmd230__LongNumbersList(soap, tag?tag:"bmd230:LongNumbersList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__LongNumbersList ** SOAP_FMAC4 soap_get_PointerTobmd230__LongNumbersList(struct soap *soap, struct bmd230__LongNumbersList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobmd230__LongNumbersList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTobmd230__accessObjectList(struct soap *soap, struct bmd230__accessObjectList **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTobmd230__accessObjectList))
		soap_serialize_PointerTobmd230__accessObjectList(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTobmd230__accessObjectList(struct soap *soap, const char *tag, int id, struct bmd230__accessObjectList **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTobmd230__accessObjectList);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTobmd230__accessObjectList(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bmd230__accessObjectList *** SOAP_FMAC4 soap_in_PointerToPointerTobmd230__accessObjectList(struct soap *soap, const char *tag, struct bmd230__accessObjectList ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bmd230__accessObjectList ***)soap_malloc(soap, sizeof(struct bmd230__accessObjectList **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTobmd230__accessObjectList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bmd230__accessObjectList ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTobmd230__accessObjectList, sizeof(struct bmd230__accessObjectList *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTobmd230__accessObjectList(struct soap *soap, struct bmd230__accessObjectList **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTobmd230__accessObjectList);
	if (soap_out_PointerToPointerTobmd230__accessObjectList(soap, tag?tag:"bmd230:accessObjectList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__accessObjectList *** SOAP_FMAC4 soap_get_PointerToPointerTobmd230__accessObjectList(struct soap *soap, struct bmd230__accessObjectList ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTobmd230__accessObjectList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobmd230__accessObjectList(struct soap *soap, struct bmd230__accessObjectList *const*a)
{
	if (*a)
		soap_serialize_bmd230__accessObjectList(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobmd230__accessObjectList(struct soap *soap, const char *tag, int id, struct bmd230__accessObjectList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_bmd230__accessObjectList);
	if (id < 0)
		return soap->error;
	return soap_out_bmd230__accessObjectList(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bmd230__accessObjectList ** SOAP_FMAC4 soap_in_PointerTobmd230__accessObjectList(struct soap *soap, const char *tag, struct bmd230__accessObjectList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bmd230__accessObjectList **)soap_malloc(soap, sizeof(struct bmd230__accessObjectList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bmd230__accessObjectList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bmd230__accessObjectList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bmd230__accessObjectList, sizeof(struct bmd230__accessObjectList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobmd230__accessObjectList(struct soap *soap, struct bmd230__accessObjectList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobmd230__accessObjectList);
	if (soap_out_PointerTobmd230__accessObjectList(soap, tag?tag:"bmd230:accessObjectList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__accessObjectList ** SOAP_FMAC4 soap_get_PointerTobmd230__accessObjectList(struct soap *soap, struct bmd230__accessObjectList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobmd230__accessObjectList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTobmd230__bmdTimestamp(struct soap *soap, struct bmd230__bmdTimestamp **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTobmd230__bmdTimestamp))
		soap_serialize_PointerTobmd230__bmdTimestamp(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTobmd230__bmdTimestamp(struct soap *soap, const char *tag, int id, struct bmd230__bmdTimestamp **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTobmd230__bmdTimestamp);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTobmd230__bmdTimestamp(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bmd230__bmdTimestamp *** SOAP_FMAC4 soap_in_PointerToPointerTobmd230__bmdTimestamp(struct soap *soap, const char *tag, struct bmd230__bmdTimestamp ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bmd230__bmdTimestamp ***)soap_malloc(soap, sizeof(struct bmd230__bmdTimestamp **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTobmd230__bmdTimestamp(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdTimestamp ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTobmd230__bmdTimestamp, sizeof(struct bmd230__bmdTimestamp *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTobmd230__bmdTimestamp(struct soap *soap, struct bmd230__bmdTimestamp **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTobmd230__bmdTimestamp);
	if (soap_out_PointerToPointerTobmd230__bmdTimestamp(soap, tag?tag:"bmd230:bmdTimestamp", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdTimestamp *** SOAP_FMAC4 soap_get_PointerToPointerTobmd230__bmdTimestamp(struct soap *soap, struct bmd230__bmdTimestamp ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTobmd230__bmdTimestamp(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobmd230__bmdTimestamp(struct soap *soap, struct bmd230__bmdTimestamp *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bmd230__bmdTimestamp))
		soap_serialize_bmd230__bmdTimestamp(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobmd230__bmdTimestamp(struct soap *soap, const char *tag, int id, struct bmd230__bmdTimestamp *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bmd230__bmdTimestamp);
	if (id < 0)
		return soap->error;
	return soap_out_bmd230__bmdTimestamp(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bmd230__bmdTimestamp ** SOAP_FMAC4 soap_in_PointerTobmd230__bmdTimestamp(struct soap *soap, const char *tag, struct bmd230__bmdTimestamp **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bmd230__bmdTimestamp **)soap_malloc(soap, sizeof(struct bmd230__bmdTimestamp *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bmd230__bmdTimestamp(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bmd230__bmdTimestamp **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bmd230__bmdTimestamp, sizeof(struct bmd230__bmdTimestamp), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobmd230__bmdTimestamp(struct soap *soap, struct bmd230__bmdTimestamp *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobmd230__bmdTimestamp);
	if (soap_out_PointerTobmd230__bmdTimestamp(soap, tag?tag:"bmd230:bmdTimestamp", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__bmdTimestamp ** SOAP_FMAC4 soap_get_PointerTobmd230__bmdTimestamp(struct soap *soap, struct bmd230__bmdTimestamp **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobmd230__bmdTimestamp(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTobmd230__PkiFileInfo(struct soap *soap, struct bmd230__PkiFileInfo **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTobmd230__PkiFileInfo))
		soap_serialize_PointerTobmd230__PkiFileInfo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTobmd230__PkiFileInfo(struct soap *soap, const char *tag, int id, struct bmd230__PkiFileInfo **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTobmd230__PkiFileInfo);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTobmd230__PkiFileInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bmd230__PkiFileInfo *** SOAP_FMAC4 soap_in_PointerToPointerTobmd230__PkiFileInfo(struct soap *soap, const char *tag, struct bmd230__PkiFileInfo ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bmd230__PkiFileInfo ***)soap_malloc(soap, sizeof(struct bmd230__PkiFileInfo **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTobmd230__PkiFileInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bmd230__PkiFileInfo ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTobmd230__PkiFileInfo, sizeof(struct bmd230__PkiFileInfo *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTobmd230__PkiFileInfo(struct soap *soap, struct bmd230__PkiFileInfo **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTobmd230__PkiFileInfo);
	if (soap_out_PointerToPointerTobmd230__PkiFileInfo(soap, tag?tag:"bmd230:PkiFileInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__PkiFileInfo *** SOAP_FMAC4 soap_get_PointerToPointerTobmd230__PkiFileInfo(struct soap *soap, struct bmd230__PkiFileInfo ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTobmd230__PkiFileInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobmd230__PkiFileInfo(struct soap *soap, struct bmd230__PkiFileInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bmd230__PkiFileInfo))
		soap_serialize_bmd230__PkiFileInfo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobmd230__PkiFileInfo(struct soap *soap, const char *tag, int id, struct bmd230__PkiFileInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bmd230__PkiFileInfo);
	if (id < 0)
		return soap->error;
	return soap_out_bmd230__PkiFileInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bmd230__PkiFileInfo ** SOAP_FMAC4 soap_in_PointerTobmd230__PkiFileInfo(struct soap *soap, const char *tag, struct bmd230__PkiFileInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bmd230__PkiFileInfo **)soap_malloc(soap, sizeof(struct bmd230__PkiFileInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bmd230__PkiFileInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bmd230__PkiFileInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bmd230__PkiFileInfo, sizeof(struct bmd230__PkiFileInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobmd230__PkiFileInfo(struct soap *soap, struct bmd230__PkiFileInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobmd230__PkiFileInfo);
	if (soap_out_PointerTobmd230__PkiFileInfo(soap, tag?tag:"bmd230:PkiFileInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__PkiFileInfo ** SOAP_FMAC4 soap_get_PointerTobmd230__PkiFileInfo(struct soap *soap, struct bmd230__PkiFileInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobmd230__PkiFileInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTobmd230__securityInfo(struct soap *soap, struct bmd230__securityInfo **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTobmd230__securityInfo))
		soap_serialize_PointerTobmd230__securityInfo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTobmd230__securityInfo(struct soap *soap, const char *tag, int id, struct bmd230__securityInfo **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTobmd230__securityInfo);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTobmd230__securityInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bmd230__securityInfo *** SOAP_FMAC4 soap_in_PointerToPointerTobmd230__securityInfo(struct soap *soap, const char *tag, struct bmd230__securityInfo ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bmd230__securityInfo ***)soap_malloc(soap, sizeof(struct bmd230__securityInfo **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTobmd230__securityInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bmd230__securityInfo ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTobmd230__securityInfo, sizeof(struct bmd230__securityInfo *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTobmd230__securityInfo(struct soap *soap, struct bmd230__securityInfo **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTobmd230__securityInfo);
	if (soap_out_PointerToPointerTobmd230__securityInfo(soap, tag?tag:"bmd230:securityInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__securityInfo *** SOAP_FMAC4 soap_get_PointerToPointerTobmd230__securityInfo(struct soap *soap, struct bmd230__securityInfo ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTobmd230__securityInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobmd230__securityInfo(struct soap *soap, struct bmd230__securityInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bmd230__securityInfo))
		soap_serialize_bmd230__securityInfo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobmd230__securityInfo(struct soap *soap, const char *tag, int id, struct bmd230__securityInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bmd230__securityInfo);
	if (id < 0)
		return soap->error;
	return soap_out_bmd230__securityInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bmd230__securityInfo ** SOAP_FMAC4 soap_in_PointerTobmd230__securityInfo(struct soap *soap, const char *tag, struct bmd230__securityInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bmd230__securityInfo **)soap_malloc(soap, sizeof(struct bmd230__securityInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bmd230__securityInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bmd230__securityInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bmd230__securityInfo, sizeof(struct bmd230__securityInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobmd230__securityInfo(struct soap *soap, struct bmd230__securityInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobmd230__securityInfo);
	if (soap_out_PointerTobmd230__securityInfo(soap, tag?tag:"bmd230:securityInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__securityInfo ** SOAP_FMAC4 soap_get_PointerTobmd230__securityInfo(struct soap *soap, struct bmd230__securityInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobmd230__securityInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTobmd230__classInfo(struct soap *soap, struct bmd230__classInfo **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTobmd230__classInfo))
		soap_serialize_PointerTobmd230__classInfo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTobmd230__classInfo(struct soap *soap, const char *tag, int id, struct bmd230__classInfo **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTobmd230__classInfo);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTobmd230__classInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bmd230__classInfo *** SOAP_FMAC4 soap_in_PointerToPointerTobmd230__classInfo(struct soap *soap, const char *tag, struct bmd230__classInfo ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bmd230__classInfo ***)soap_malloc(soap, sizeof(struct bmd230__classInfo **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTobmd230__classInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bmd230__classInfo ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTobmd230__classInfo, sizeof(struct bmd230__classInfo *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTobmd230__classInfo(struct soap *soap, struct bmd230__classInfo **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTobmd230__classInfo);
	if (soap_out_PointerToPointerTobmd230__classInfo(soap, tag?tag:"bmd230:classInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__classInfo *** SOAP_FMAC4 soap_get_PointerToPointerTobmd230__classInfo(struct soap *soap, struct bmd230__classInfo ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTobmd230__classInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobmd230__classInfo(struct soap *soap, struct bmd230__classInfo *const*a)
{
	if (*a)
		soap_serialize_bmd230__classInfo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobmd230__classInfo(struct soap *soap, const char *tag, int id, struct bmd230__classInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_bmd230__classInfo);
	if (id < 0)
		return soap->error;
	return soap_out_bmd230__classInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bmd230__classInfo ** SOAP_FMAC4 soap_in_PointerTobmd230__classInfo(struct soap *soap, const char *tag, struct bmd230__classInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bmd230__classInfo **)soap_malloc(soap, sizeof(struct bmd230__classInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bmd230__classInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bmd230__classInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bmd230__classInfo, sizeof(struct bmd230__classInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobmd230__classInfo(struct soap *soap, struct bmd230__classInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobmd230__classInfo);
	if (soap_out_PointerTobmd230__classInfo(soap, tag?tag:"bmd230:classInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__classInfo ** SOAP_FMAC4 soap_get_PointerTobmd230__classInfo(struct soap *soap, struct bmd230__classInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobmd230__classInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTobmd230__groupInfo(struct soap *soap, struct bmd230__groupInfo **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTobmd230__groupInfo))
		soap_serialize_PointerTobmd230__groupInfo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTobmd230__groupInfo(struct soap *soap, const char *tag, int id, struct bmd230__groupInfo **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTobmd230__groupInfo);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTobmd230__groupInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bmd230__groupInfo *** SOAP_FMAC4 soap_in_PointerToPointerTobmd230__groupInfo(struct soap *soap, const char *tag, struct bmd230__groupInfo ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bmd230__groupInfo ***)soap_malloc(soap, sizeof(struct bmd230__groupInfo **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTobmd230__groupInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bmd230__groupInfo ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTobmd230__groupInfo, sizeof(struct bmd230__groupInfo *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTobmd230__groupInfo(struct soap *soap, struct bmd230__groupInfo **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTobmd230__groupInfo);
	if (soap_out_PointerToPointerTobmd230__groupInfo(soap, tag?tag:"bmd230:groupInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__groupInfo *** SOAP_FMAC4 soap_get_PointerToPointerTobmd230__groupInfo(struct soap *soap, struct bmd230__groupInfo ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTobmd230__groupInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobmd230__groupInfo(struct soap *soap, struct bmd230__groupInfo *const*a)
{
	if (*a)
		soap_serialize_bmd230__groupInfo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobmd230__groupInfo(struct soap *soap, const char *tag, int id, struct bmd230__groupInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_bmd230__groupInfo);
	if (id < 0)
		return soap->error;
	return soap_out_bmd230__groupInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bmd230__groupInfo ** SOAP_FMAC4 soap_in_PointerTobmd230__groupInfo(struct soap *soap, const char *tag, struct bmd230__groupInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bmd230__groupInfo **)soap_malloc(soap, sizeof(struct bmd230__groupInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bmd230__groupInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bmd230__groupInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bmd230__groupInfo, sizeof(struct bmd230__groupInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobmd230__groupInfo(struct soap *soap, struct bmd230__groupInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobmd230__groupInfo);
	if (soap_out_PointerTobmd230__groupInfo(soap, tag?tag:"bmd230:groupInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__groupInfo ** SOAP_FMAC4 soap_get_PointerTobmd230__groupInfo(struct soap *soap, struct bmd230__groupInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobmd230__groupInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTobmd230__userRoleInfo(struct soap *soap, struct bmd230__userRoleInfo **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTobmd230__userRoleInfo))
		soap_serialize_PointerTobmd230__userRoleInfo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTobmd230__userRoleInfo(struct soap *soap, const char *tag, int id, struct bmd230__userRoleInfo **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTobmd230__userRoleInfo);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTobmd230__userRoleInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bmd230__userRoleInfo *** SOAP_FMAC4 soap_in_PointerToPointerTobmd230__userRoleInfo(struct soap *soap, const char *tag, struct bmd230__userRoleInfo ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bmd230__userRoleInfo ***)soap_malloc(soap, sizeof(struct bmd230__userRoleInfo **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTobmd230__userRoleInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bmd230__userRoleInfo ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTobmd230__userRoleInfo, sizeof(struct bmd230__userRoleInfo *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTobmd230__userRoleInfo(struct soap *soap, struct bmd230__userRoleInfo **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTobmd230__userRoleInfo);
	if (soap_out_PointerToPointerTobmd230__userRoleInfo(soap, tag?tag:"bmd230:userRoleInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__userRoleInfo *** SOAP_FMAC4 soap_get_PointerToPointerTobmd230__userRoleInfo(struct soap *soap, struct bmd230__userRoleInfo ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTobmd230__userRoleInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobmd230__userRoleInfo(struct soap *soap, struct bmd230__userRoleInfo *const*a)
{
	if (*a)
		soap_serialize_bmd230__userRoleInfo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobmd230__userRoleInfo(struct soap *soap, const char *tag, int id, struct bmd230__userRoleInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_bmd230__userRoleInfo);
	if (id < 0)
		return soap->error;
	return soap_out_bmd230__userRoleInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bmd230__userRoleInfo ** SOAP_FMAC4 soap_in_PointerTobmd230__userRoleInfo(struct soap *soap, const char *tag, struct bmd230__userRoleInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bmd230__userRoleInfo **)soap_malloc(soap, sizeof(struct bmd230__userRoleInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bmd230__userRoleInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bmd230__userRoleInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bmd230__userRoleInfo, sizeof(struct bmd230__userRoleInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobmd230__userRoleInfo(struct soap *soap, struct bmd230__userRoleInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobmd230__userRoleInfo);
	if (soap_out_PointerTobmd230__userRoleInfo(soap, tag?tag:"bmd230:userRoleInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__userRoleInfo ** SOAP_FMAC4 soap_get_PointerTobmd230__userRoleInfo(struct soap *soap, struct bmd230__userRoleInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobmd230__userRoleInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTobmd230__userListInfo(struct soap *soap, struct bmd230__userListInfo **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTobmd230__userListInfo))
		soap_serialize_PointerTobmd230__userListInfo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTobmd230__userListInfo(struct soap *soap, const char *tag, int id, struct bmd230__userListInfo **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTobmd230__userListInfo);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTobmd230__userListInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bmd230__userListInfo *** SOAP_FMAC4 soap_in_PointerToPointerTobmd230__userListInfo(struct soap *soap, const char *tag, struct bmd230__userListInfo ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bmd230__userListInfo ***)soap_malloc(soap, sizeof(struct bmd230__userListInfo **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTobmd230__userListInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bmd230__userListInfo ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTobmd230__userListInfo, sizeof(struct bmd230__userListInfo *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTobmd230__userListInfo(struct soap *soap, struct bmd230__userListInfo **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTobmd230__userListInfo);
	if (soap_out_PointerToPointerTobmd230__userListInfo(soap, tag?tag:"bmd230:userListInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__userListInfo *** SOAP_FMAC4 soap_get_PointerToPointerTobmd230__userListInfo(struct soap *soap, struct bmd230__userListInfo ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTobmd230__userListInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobmd230__userListInfo(struct soap *soap, struct bmd230__userListInfo *const*a)
{
	if (*a)
		soap_serialize_bmd230__userListInfo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobmd230__userListInfo(struct soap *soap, const char *tag, int id, struct bmd230__userListInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_bmd230__userListInfo);
	if (id < 0)
		return soap->error;
	return soap_out_bmd230__userListInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bmd230__userListInfo ** SOAP_FMAC4 soap_in_PointerTobmd230__userListInfo(struct soap *soap, const char *tag, struct bmd230__userListInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bmd230__userListInfo **)soap_malloc(soap, sizeof(struct bmd230__userListInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bmd230__userListInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bmd230__userListInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bmd230__userListInfo, sizeof(struct bmd230__userListInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobmd230__userListInfo(struct soap *soap, struct bmd230__userListInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobmd230__userListInfo);
	if (soap_out_PointerTobmd230__userListInfo(soap, tag?tag:"bmd230:userListInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__userListInfo ** SOAP_FMAC4 soap_get_PointerTobmd230__userListInfo(struct soap *soap, struct bmd230__userListInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobmd230__userListInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTobmd230__userRegistrationResult(struct soap *soap, struct bmd230__userRegistrationResult **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTobmd230__userRegistrationResult))
		soap_serialize_PointerTobmd230__userRegistrationResult(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTobmd230__userRegistrationResult(struct soap *soap, const char *tag, int id, struct bmd230__userRegistrationResult **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTobmd230__userRegistrationResult);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTobmd230__userRegistrationResult(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bmd230__userRegistrationResult *** SOAP_FMAC4 soap_in_PointerToPointerTobmd230__userRegistrationResult(struct soap *soap, const char *tag, struct bmd230__userRegistrationResult ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bmd230__userRegistrationResult ***)soap_malloc(soap, sizeof(struct bmd230__userRegistrationResult **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTobmd230__userRegistrationResult(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bmd230__userRegistrationResult ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTobmd230__userRegistrationResult, sizeof(struct bmd230__userRegistrationResult *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTobmd230__userRegistrationResult(struct soap *soap, struct bmd230__userRegistrationResult **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTobmd230__userRegistrationResult);
	if (soap_out_PointerToPointerTobmd230__userRegistrationResult(soap, tag?tag:"bmd230:userRegistrationResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__userRegistrationResult *** SOAP_FMAC4 soap_get_PointerToPointerTobmd230__userRegistrationResult(struct soap *soap, struct bmd230__userRegistrationResult ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTobmd230__userRegistrationResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobmd230__userRegistrationResult(struct soap *soap, struct bmd230__userRegistrationResult *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bmd230__userRegistrationResult))
		soap_serialize_bmd230__userRegistrationResult(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobmd230__userRegistrationResult(struct soap *soap, const char *tag, int id, struct bmd230__userRegistrationResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bmd230__userRegistrationResult);
	if (id < 0)
		return soap->error;
	return soap_out_bmd230__userRegistrationResult(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bmd230__userRegistrationResult ** SOAP_FMAC4 soap_in_PointerTobmd230__userRegistrationResult(struct soap *soap, const char *tag, struct bmd230__userRegistrationResult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bmd230__userRegistrationResult **)soap_malloc(soap, sizeof(struct bmd230__userRegistrationResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bmd230__userRegistrationResult(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bmd230__userRegistrationResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bmd230__userRegistrationResult, sizeof(struct bmd230__userRegistrationResult), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobmd230__userRegistrationResult(struct soap *soap, struct bmd230__userRegistrationResult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobmd230__userRegistrationResult);
	if (soap_out_PointerTobmd230__userRegistrationResult(soap, tag?tag:"bmd230:userRegistrationResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__userRegistrationResult ** SOAP_FMAC4 soap_get_PointerTobmd230__userRegistrationResult(struct soap *soap, struct bmd230__userRegistrationResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobmd230__userRegistrationResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTobmd230__historyResults(struct soap *soap, struct bmd230__historyResults **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTobmd230__historyResults))
		soap_serialize_PointerTobmd230__historyResults(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTobmd230__historyResults(struct soap *soap, const char *tag, int id, struct bmd230__historyResults **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTobmd230__historyResults);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTobmd230__historyResults(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bmd230__historyResults *** SOAP_FMAC4 soap_in_PointerToPointerTobmd230__historyResults(struct soap *soap, const char *tag, struct bmd230__historyResults ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bmd230__historyResults ***)soap_malloc(soap, sizeof(struct bmd230__historyResults **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTobmd230__historyResults(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bmd230__historyResults ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTobmd230__historyResults, sizeof(struct bmd230__historyResults *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTobmd230__historyResults(struct soap *soap, struct bmd230__historyResults **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTobmd230__historyResults);
	if (soap_out_PointerToPointerTobmd230__historyResults(soap, tag?tag:"bmd230:historyResults", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__historyResults *** SOAP_FMAC4 soap_get_PointerToPointerTobmd230__historyResults(struct soap *soap, struct bmd230__historyResults ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTobmd230__historyResults(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobmd230__historyResults(struct soap *soap, struct bmd230__historyResults *const*a)
{
	if (*a)
		soap_serialize_bmd230__historyResults(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobmd230__historyResults(struct soap *soap, const char *tag, int id, struct bmd230__historyResults *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_bmd230__historyResults);
	if (id < 0)
		return soap->error;
	return soap_out_bmd230__historyResults(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bmd230__historyResults ** SOAP_FMAC4 soap_in_PointerTobmd230__historyResults(struct soap *soap, const char *tag, struct bmd230__historyResults **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bmd230__historyResults **)soap_malloc(soap, sizeof(struct bmd230__historyResults *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bmd230__historyResults(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bmd230__historyResults **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bmd230__historyResults, sizeof(struct bmd230__historyResults), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobmd230__historyResults(struct soap *soap, struct bmd230__historyResults *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobmd230__historyResults);
	if (soap_out_PointerTobmd230__historyResults(soap, tag?tag:"bmd230:historyResults", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__historyResults ** SOAP_FMAC4 soap_get_PointerTobmd230__historyResults(struct soap *soap, struct bmd230__historyResults **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobmd230__historyResults(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobmd230__mtdsSearchValues(struct soap *soap, struct bmd230__mtdsSearchValues *const*a)
{
	if (*a)
		soap_serialize_bmd230__mtdsSearchValues(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobmd230__mtdsSearchValues(struct soap *soap, const char *tag, int id, struct bmd230__mtdsSearchValues *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_bmd230__mtdsSearchValues);
	if (id < 0)
		return soap->error;
	return soap_out_bmd230__mtdsSearchValues(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bmd230__mtdsSearchValues ** SOAP_FMAC4 soap_in_PointerTobmd230__mtdsSearchValues(struct soap *soap, const char *tag, struct bmd230__mtdsSearchValues **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bmd230__mtdsSearchValues **)soap_malloc(soap, sizeof(struct bmd230__mtdsSearchValues *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bmd230__mtdsSearchValues(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bmd230__mtdsSearchValues **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bmd230__mtdsSearchValues, sizeof(struct bmd230__mtdsSearchValues), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobmd230__mtdsSearchValues(struct soap *soap, struct bmd230__mtdsSearchValues *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobmd230__mtdsSearchValues);
	if (soap_out_PointerTobmd230__mtdsSearchValues(soap, tag?tag:"bmd230:mtdsSearchValues", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__mtdsSearchValues ** SOAP_FMAC4 soap_get_PointerTobmd230__mtdsSearchValues(struct soap *soap, struct bmd230__mtdsSearchValues **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobmd230__mtdsSearchValues(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTobmd230__fileInfo(struct soap *soap, struct bmd230__fileInfo **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTobmd230__fileInfo))
		soap_serialize_PointerTobmd230__fileInfo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTobmd230__fileInfo(struct soap *soap, const char *tag, int id, struct bmd230__fileInfo **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTobmd230__fileInfo);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTobmd230__fileInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bmd230__fileInfo *** SOAP_FMAC4 soap_in_PointerToPointerTobmd230__fileInfo(struct soap *soap, const char *tag, struct bmd230__fileInfo ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bmd230__fileInfo ***)soap_malloc(soap, sizeof(struct bmd230__fileInfo **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTobmd230__fileInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bmd230__fileInfo ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTobmd230__fileInfo, sizeof(struct bmd230__fileInfo *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTobmd230__fileInfo(struct soap *soap, struct bmd230__fileInfo **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTobmd230__fileInfo);
	if (soap_out_PointerToPointerTobmd230__fileInfo(soap, tag?tag:"bmd230:fileInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__fileInfo *** SOAP_FMAC4 soap_get_PointerToPointerTobmd230__fileInfo(struct soap *soap, struct bmd230__fileInfo ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTobmd230__fileInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTobmd230__searchResults(struct soap *soap, struct bmd230__searchResults **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTobmd230__searchResults))
		soap_serialize_PointerTobmd230__searchResults(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTobmd230__searchResults(struct soap *soap, const char *tag, int id, struct bmd230__searchResults **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTobmd230__searchResults);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTobmd230__searchResults(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bmd230__searchResults *** SOAP_FMAC4 soap_in_PointerToPointerTobmd230__searchResults(struct soap *soap, const char *tag, struct bmd230__searchResults ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bmd230__searchResults ***)soap_malloc(soap, sizeof(struct bmd230__searchResults **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTobmd230__searchResults(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bmd230__searchResults ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTobmd230__searchResults, sizeof(struct bmd230__searchResults *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTobmd230__searchResults(struct soap *soap, struct bmd230__searchResults **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTobmd230__searchResults);
	if (soap_out_PointerToPointerTobmd230__searchResults(soap, tag?tag:"bmd230:searchResults", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__searchResults *** SOAP_FMAC4 soap_get_PointerToPointerTobmd230__searchResults(struct soap *soap, struct bmd230__searchResults ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTobmd230__searchResults(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobmd230__searchResults(struct soap *soap, struct bmd230__searchResults *const*a)
{
	if (*a)
		soap_serialize_bmd230__searchResults(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobmd230__searchResults(struct soap *soap, const char *tag, int id, struct bmd230__searchResults *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_bmd230__searchResults);
	if (id < 0)
		return soap->error;
	return soap_out_bmd230__searchResults(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bmd230__searchResults ** SOAP_FMAC4 soap_in_PointerTobmd230__searchResults(struct soap *soap, const char *tag, struct bmd230__searchResults **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bmd230__searchResults **)soap_malloc(soap, sizeof(struct bmd230__searchResults *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bmd230__searchResults(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bmd230__searchResults **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bmd230__searchResults, sizeof(struct bmd230__searchResults), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobmd230__searchResults(struct soap *soap, struct bmd230__searchResults *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobmd230__searchResults);
	if (soap_out_PointerTobmd230__searchResults(soap, tag?tag:"bmd230:searchResults", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__searchResults ** SOAP_FMAC4 soap_get_PointerTobmd230__searchResults(struct soap *soap, struct bmd230__searchResults **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobmd230__searchResults(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobmd230__searchSortInfoList(struct soap *soap, struct bmd230__searchSortInfoList *const*a)
{
	if (*a)
		soap_serialize_bmd230__searchSortInfoList(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobmd230__searchSortInfoList(struct soap *soap, const char *tag, int id, struct bmd230__searchSortInfoList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_bmd230__searchSortInfoList);
	if (id < 0)
		return soap->error;
	return soap_out_bmd230__searchSortInfoList(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bmd230__searchSortInfoList ** SOAP_FMAC4 soap_in_PointerTobmd230__searchSortInfoList(struct soap *soap, const char *tag, struct bmd230__searchSortInfoList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bmd230__searchSortInfoList **)soap_malloc(soap, sizeof(struct bmd230__searchSortInfoList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bmd230__searchSortInfoList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bmd230__searchSortInfoList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bmd230__searchSortInfoList, sizeof(struct bmd230__searchSortInfoList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobmd230__searchSortInfoList(struct soap *soap, struct bmd230__searchSortInfoList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobmd230__searchSortInfoList);
	if (soap_out_PointerTobmd230__searchSortInfoList(soap, tag?tag:"bmd230:searchSortInfoList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__searchSortInfoList ** SOAP_FMAC4 soap_get_PointerTobmd230__searchSortInfoList(struct soap *soap, struct bmd230__searchSortInfoList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobmd230__searchSortInfoList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTobmd230__loginResponse(struct soap *soap, struct bmd230__loginResponse **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTobmd230__loginResponse))
		soap_serialize_PointerTobmd230__loginResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTobmd230__loginResponse(struct soap *soap, const char *tag, int id, struct bmd230__loginResponse **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTobmd230__loginResponse);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTobmd230__loginResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bmd230__loginResponse *** SOAP_FMAC4 soap_in_PointerToPointerTobmd230__loginResponse(struct soap *soap, const char *tag, struct bmd230__loginResponse ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bmd230__loginResponse ***)soap_malloc(soap, sizeof(struct bmd230__loginResponse **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTobmd230__loginResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bmd230__loginResponse ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTobmd230__loginResponse, sizeof(struct bmd230__loginResponse *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTobmd230__loginResponse(struct soap *soap, struct bmd230__loginResponse **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTobmd230__loginResponse);
	if (soap_out_PointerToPointerTobmd230__loginResponse(soap, tag?tag:"bmd230:loginResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__loginResponse *** SOAP_FMAC4 soap_get_PointerToPointerTobmd230__loginResponse(struct soap *soap, struct bmd230__loginResponse ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTobmd230__loginResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobmd230__loginResponse(struct soap *soap, struct bmd230__loginResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bmd230__loginResponse))
		soap_serialize_bmd230__loginResponse(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobmd230__loginResponse(struct soap *soap, const char *tag, int id, struct bmd230__loginResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bmd230__loginResponse);
	if (id < 0)
		return soap->error;
	return soap_out_bmd230__loginResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bmd230__loginResponse ** SOAP_FMAC4 soap_in_PointerTobmd230__loginResponse(struct soap *soap, const char *tag, struct bmd230__loginResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bmd230__loginResponse **)soap_malloc(soap, sizeof(struct bmd230__loginResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bmd230__loginResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bmd230__loginResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bmd230__loginResponse, sizeof(struct bmd230__loginResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobmd230__loginResponse(struct soap *soap, struct bmd230__loginResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobmd230__loginResponse);
	if (soap_out_PointerTobmd230__loginResponse(soap, tag?tag:"bmd230:loginResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__loginResponse ** SOAP_FMAC4 soap_get_PointerTobmd230__loginResponse(struct soap *soap, struct bmd230__loginResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobmd230__loginResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTobmd230__idList(struct soap *soap, struct bmd230__idList **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTobmd230__idList))
		soap_serialize_PointerTobmd230__idList(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTobmd230__idList(struct soap *soap, const char *tag, int id, struct bmd230__idList **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTobmd230__idList);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTobmd230__idList(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bmd230__idList *** SOAP_FMAC4 soap_in_PointerToPointerTobmd230__idList(struct soap *soap, const char *tag, struct bmd230__idList ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bmd230__idList ***)soap_malloc(soap, sizeof(struct bmd230__idList **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTobmd230__idList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bmd230__idList ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTobmd230__idList, sizeof(struct bmd230__idList *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTobmd230__idList(struct soap *soap, struct bmd230__idList **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTobmd230__idList);
	if (soap_out_PointerToPointerTobmd230__idList(soap, tag?tag:"bmd230:idList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__idList *** SOAP_FMAC4 soap_get_PointerToPointerTobmd230__idList(struct soap *soap, struct bmd230__idList ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTobmd230__idList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobmd230__fileComplexList(struct soap *soap, struct bmd230__fileComplexList *const*a)
{
	if (*a)
		soap_serialize_bmd230__fileComplexList(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobmd230__fileComplexList(struct soap *soap, const char *tag, int id, struct bmd230__fileComplexList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_bmd230__fileComplexList);
	if (id < 0)
		return soap->error;
	return soap_out_bmd230__fileComplexList(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bmd230__fileComplexList ** SOAP_FMAC4 soap_in_PointerTobmd230__fileComplexList(struct soap *soap, const char *tag, struct bmd230__fileComplexList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bmd230__fileComplexList **)soap_malloc(soap, sizeof(struct bmd230__fileComplexList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bmd230__fileComplexList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bmd230__fileComplexList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bmd230__fileComplexList, sizeof(struct bmd230__fileComplexList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobmd230__fileComplexList(struct soap *soap, struct bmd230__fileComplexList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobmd230__fileComplexList);
	if (soap_out_PointerTobmd230__fileComplexList(soap, tag?tag:"bmd230:fileComplexList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__fileComplexList ** SOAP_FMAC4 soap_get_PointerTobmd230__fileComplexList(struct soap *soap, struct bmd230__fileComplexList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobmd230__fileComplexList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostring(struct soap *soap, char **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_string))
		soap_serialize_string(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostring(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_string);
	if (id < 0)
		return soap->error;
	return soap_out_string(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerTostring(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_string, sizeof(char *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostring(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostring);
	if (soap_out_PointerTostring(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTostring(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobmd230__ActionsHistoryElement(struct soap *soap, struct bmd230__ActionsHistoryElement *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bmd230__ActionsHistoryElement))
		soap_serialize_bmd230__ActionsHistoryElement(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobmd230__ActionsHistoryElement(struct soap *soap, const char *tag, int id, struct bmd230__ActionsHistoryElement *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bmd230__ActionsHistoryElement);
	if (id < 0)
		return soap->error;
	return soap_out_bmd230__ActionsHistoryElement(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bmd230__ActionsHistoryElement ** SOAP_FMAC4 soap_in_PointerTobmd230__ActionsHistoryElement(struct soap *soap, const char *tag, struct bmd230__ActionsHistoryElement **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bmd230__ActionsHistoryElement **)soap_malloc(soap, sizeof(struct bmd230__ActionsHistoryElement *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bmd230__ActionsHistoryElement(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bmd230__ActionsHistoryElement **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bmd230__ActionsHistoryElement, sizeof(struct bmd230__ActionsHistoryElement), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobmd230__ActionsHistoryElement(struct soap *soap, struct bmd230__ActionsHistoryElement *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobmd230__ActionsHistoryElement);
	if (soap_out_PointerTobmd230__ActionsHistoryElement(soap, tag?tag:"bmd230:ActionsHistoryElement", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__ActionsHistoryElement ** SOAP_FMAC4 soap_get_PointerTobmd230__ActionsHistoryElement(struct soap *soap, struct bmd230__ActionsHistoryElement **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobmd230__ActionsHistoryElement(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobmd230__GetVersionsHistoryResult(struct soap *soap, struct bmd230__GetVersionsHistoryResult *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bmd230__GetVersionsHistoryResult))
		soap_serialize_bmd230__GetVersionsHistoryResult(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobmd230__GetVersionsHistoryResult(struct soap *soap, const char *tag, int id, struct bmd230__GetVersionsHistoryResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bmd230__GetVersionsHistoryResult);
	if (id < 0)
		return soap->error;
	return soap_out_bmd230__GetVersionsHistoryResult(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bmd230__GetVersionsHistoryResult ** SOAP_FMAC4 soap_in_PointerTobmd230__GetVersionsHistoryResult(struct soap *soap, const char *tag, struct bmd230__GetVersionsHistoryResult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bmd230__GetVersionsHistoryResult **)soap_malloc(soap, sizeof(struct bmd230__GetVersionsHistoryResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bmd230__GetVersionsHistoryResult(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bmd230__GetVersionsHistoryResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bmd230__GetVersionsHistoryResult, sizeof(struct bmd230__GetVersionsHistoryResult), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobmd230__GetVersionsHistoryResult(struct soap *soap, struct bmd230__GetVersionsHistoryResult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobmd230__GetVersionsHistoryResult);
	if (soap_out_PointerTobmd230__GetVersionsHistoryResult(soap, tag?tag:"bmd230:GetVersionsHistoryResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__GetVersionsHistoryResult ** SOAP_FMAC4 soap_get_PointerTobmd230__GetVersionsHistoryResult(struct soap *soap, struct bmd230__GetVersionsHistoryResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobmd230__GetVersionsHistoryResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobmd230__FileVersionInfoList(struct soap *soap, struct bmd230__FileVersionInfoList *const*a)
{
	if (*a)
		soap_serialize_bmd230__FileVersionInfoList(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobmd230__FileVersionInfoList(struct soap *soap, const char *tag, int id, struct bmd230__FileVersionInfoList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_bmd230__FileVersionInfoList);
	if (id < 0)
		return soap->error;
	return soap_out_bmd230__FileVersionInfoList(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bmd230__FileVersionInfoList ** SOAP_FMAC4 soap_in_PointerTobmd230__FileVersionInfoList(struct soap *soap, const char *tag, struct bmd230__FileVersionInfoList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bmd230__FileVersionInfoList **)soap_malloc(soap, sizeof(struct bmd230__FileVersionInfoList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bmd230__FileVersionInfoList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bmd230__FileVersionInfoList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bmd230__FileVersionInfoList, sizeof(struct bmd230__FileVersionInfoList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobmd230__FileVersionInfoList(struct soap *soap, struct bmd230__FileVersionInfoList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobmd230__FileVersionInfoList);
	if (soap_out_PointerTobmd230__FileVersionInfoList(soap, tag?tag:"bmd230:FileVersionInfoList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__FileVersionInfoList ** SOAP_FMAC4 soap_get_PointerTobmd230__FileVersionInfoList(struct soap *soap, struct bmd230__FileVersionInfoList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobmd230__FileVersionInfoList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobmd230__FileVersionInfo(struct soap *soap, struct bmd230__FileVersionInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bmd230__FileVersionInfo))
		soap_serialize_bmd230__FileVersionInfo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobmd230__FileVersionInfo(struct soap *soap, const char *tag, int id, struct bmd230__FileVersionInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bmd230__FileVersionInfo);
	if (id < 0)
		return soap->error;
	return soap_out_bmd230__FileVersionInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bmd230__FileVersionInfo ** SOAP_FMAC4 soap_in_PointerTobmd230__FileVersionInfo(struct soap *soap, const char *tag, struct bmd230__FileVersionInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bmd230__FileVersionInfo **)soap_malloc(soap, sizeof(struct bmd230__FileVersionInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bmd230__FileVersionInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bmd230__FileVersionInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bmd230__FileVersionInfo, sizeof(struct bmd230__FileVersionInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobmd230__FileVersionInfo(struct soap *soap, struct bmd230__FileVersionInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobmd230__FileVersionInfo);
	if (soap_out_PointerTobmd230__FileVersionInfo(soap, tag?tag:"bmd230:FileVersionInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__FileVersionInfo ** SOAP_FMAC4 soap_get_PointerTobmd230__FileVersionInfo(struct soap *soap, struct bmd230__FileVersionInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobmd230__FileVersionInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobmd230__accessObject(struct soap *soap, struct bmd230__accessObject *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bmd230__accessObject))
		soap_serialize_bmd230__accessObject(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobmd230__accessObject(struct soap *soap, const char *tag, int id, struct bmd230__accessObject *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bmd230__accessObject);
	if (id < 0)
		return soap->error;
	return soap_out_bmd230__accessObject(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bmd230__accessObject ** SOAP_FMAC4 soap_in_PointerTobmd230__accessObject(struct soap *soap, const char *tag, struct bmd230__accessObject **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bmd230__accessObject **)soap_malloc(soap, sizeof(struct bmd230__accessObject *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bmd230__accessObject(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bmd230__accessObject **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bmd230__accessObject, sizeof(struct bmd230__accessObject), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobmd230__accessObject(struct soap *soap, struct bmd230__accessObject *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobmd230__accessObject);
	if (soap_out_PointerTobmd230__accessObject(soap, tag?tag:"bmd230:accessObject", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__accessObject ** SOAP_FMAC4 soap_get_PointerTobmd230__accessObject(struct soap *soap, struct bmd230__accessObject **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobmd230__accessObject(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobmd230__deleteCascadeLinksElement(struct soap *soap, struct bmd230__deleteCascadeLinksElement *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bmd230__deleteCascadeLinksElement))
		soap_serialize_bmd230__deleteCascadeLinksElement(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobmd230__deleteCascadeLinksElement(struct soap *soap, const char *tag, int id, struct bmd230__deleteCascadeLinksElement *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bmd230__deleteCascadeLinksElement);
	if (id < 0)
		return soap->error;
	return soap_out_bmd230__deleteCascadeLinksElement(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bmd230__deleteCascadeLinksElement ** SOAP_FMAC4 soap_in_PointerTobmd230__deleteCascadeLinksElement(struct soap *soap, const char *tag, struct bmd230__deleteCascadeLinksElement **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bmd230__deleteCascadeLinksElement **)soap_malloc(soap, sizeof(struct bmd230__deleteCascadeLinksElement *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bmd230__deleteCascadeLinksElement(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bmd230__deleteCascadeLinksElement **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bmd230__deleteCascadeLinksElement, sizeof(struct bmd230__deleteCascadeLinksElement), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobmd230__deleteCascadeLinksElement(struct soap *soap, struct bmd230__deleteCascadeLinksElement *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobmd230__deleteCascadeLinksElement);
	if (soap_out_PointerTobmd230__deleteCascadeLinksElement(soap, tag?tag:"bmd230:deleteCascadeLinksElement", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__deleteCascadeLinksElement ** SOAP_FMAC4 soap_get_PointerTobmd230__deleteCascadeLinksElement(struct soap *soap, struct bmd230__deleteCascadeLinksElement **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobmd230__deleteCascadeLinksElement(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobmd230__manyCascadeLinksElement(struct soap *soap, struct bmd230__manyCascadeLinksElement *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bmd230__manyCascadeLinksElement))
		soap_serialize_bmd230__manyCascadeLinksElement(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobmd230__manyCascadeLinksElement(struct soap *soap, const char *tag, int id, struct bmd230__manyCascadeLinksElement *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bmd230__manyCascadeLinksElement);
	if (id < 0)
		return soap->error;
	return soap_out_bmd230__manyCascadeLinksElement(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bmd230__manyCascadeLinksElement ** SOAP_FMAC4 soap_in_PointerTobmd230__manyCascadeLinksElement(struct soap *soap, const char *tag, struct bmd230__manyCascadeLinksElement **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bmd230__manyCascadeLinksElement **)soap_malloc(soap, sizeof(struct bmd230__manyCascadeLinksElement *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bmd230__manyCascadeLinksElement(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bmd230__manyCascadeLinksElement **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bmd230__manyCascadeLinksElement, sizeof(struct bmd230__manyCascadeLinksElement), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobmd230__manyCascadeLinksElement(struct soap *soap, struct bmd230__manyCascadeLinksElement *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobmd230__manyCascadeLinksElement);
	if (soap_out_PointerTobmd230__manyCascadeLinksElement(soap, tag?tag:"bmd230:manyCascadeLinksElement", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__manyCascadeLinksElement ** SOAP_FMAC4 soap_get_PointerTobmd230__manyCascadeLinksElement(struct soap *soap, struct bmd230__manyCascadeLinksElement **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobmd230__manyCascadeLinksElement(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobmd230__idList(struct soap *soap, struct bmd230__idList *const*a)
{
	if (*a)
		soap_serialize_bmd230__idList(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobmd230__idList(struct soap *soap, const char *tag, int id, struct bmd230__idList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_bmd230__idList);
	if (id < 0)
		return soap->error;
	return soap_out_bmd230__idList(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bmd230__idList ** SOAP_FMAC4 soap_in_PointerTobmd230__idList(struct soap *soap, const char *tag, struct bmd230__idList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bmd230__idList **)soap_malloc(soap, sizeof(struct bmd230__idList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bmd230__idList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bmd230__idList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bmd230__idList, sizeof(struct bmd230__idList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobmd230__idList(struct soap *soap, struct bmd230__idList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobmd230__idList);
	if (soap_out_PointerTobmd230__idList(soap, tag?tag:"bmd230:idList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__idList ** SOAP_FMAC4 soap_get_PointerTobmd230__idList(struct soap *soap, struct bmd230__idList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobmd230__idList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobmd230__singleCascadeLinkInfo(struct soap *soap, struct bmd230__singleCascadeLinkInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bmd230__singleCascadeLinkInfo))
		soap_serialize_bmd230__singleCascadeLinkInfo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobmd230__singleCascadeLinkInfo(struct soap *soap, const char *tag, int id, struct bmd230__singleCascadeLinkInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bmd230__singleCascadeLinkInfo);
	if (id < 0)
		return soap->error;
	return soap_out_bmd230__singleCascadeLinkInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bmd230__singleCascadeLinkInfo ** SOAP_FMAC4 soap_in_PointerTobmd230__singleCascadeLinkInfo(struct soap *soap, const char *tag, struct bmd230__singleCascadeLinkInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bmd230__singleCascadeLinkInfo **)soap_malloc(soap, sizeof(struct bmd230__singleCascadeLinkInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bmd230__singleCascadeLinkInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bmd230__singleCascadeLinkInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bmd230__singleCascadeLinkInfo, sizeof(struct bmd230__singleCascadeLinkInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobmd230__singleCascadeLinkInfo(struct soap *soap, struct bmd230__singleCascadeLinkInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobmd230__singleCascadeLinkInfo);
	if (soap_out_PointerTobmd230__singleCascadeLinkInfo(soap, tag?tag:"bmd230:singleCascadeLinkInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__singleCascadeLinkInfo ** SOAP_FMAC4 soap_get_PointerTobmd230__singleCascadeLinkInfo(struct soap *soap, struct bmd230__singleCascadeLinkInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobmd230__singleCascadeLinkInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobmd230__singleLinkInfo(struct soap *soap, struct bmd230__singleLinkInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bmd230__singleLinkInfo))
		soap_serialize_bmd230__singleLinkInfo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobmd230__singleLinkInfo(struct soap *soap, const char *tag, int id, struct bmd230__singleLinkInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bmd230__singleLinkInfo);
	if (id < 0)
		return soap->error;
	return soap_out_bmd230__singleLinkInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bmd230__singleLinkInfo ** SOAP_FMAC4 soap_in_PointerTobmd230__singleLinkInfo(struct soap *soap, const char *tag, struct bmd230__singleLinkInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bmd230__singleLinkInfo **)soap_malloc(soap, sizeof(struct bmd230__singleLinkInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bmd230__singleLinkInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bmd230__singleLinkInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bmd230__singleLinkInfo, sizeof(struct bmd230__singleLinkInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobmd230__singleLinkInfo(struct soap *soap, struct bmd230__singleLinkInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobmd230__singleLinkInfo);
	if (soap_out_PointerTobmd230__singleLinkInfo(soap, tag?tag:"bmd230:singleLinkInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__singleLinkInfo ** SOAP_FMAC4 soap_get_PointerTobmd230__singleLinkInfo(struct soap *soap, struct bmd230__singleLinkInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobmd230__singleLinkInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobmd230__DateTime(struct soap *soap, struct bmd230__DateTime *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bmd230__DateTime))
		soap_serialize_bmd230__DateTime(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobmd230__DateTime(struct soap *soap, const char *tag, int id, struct bmd230__DateTime *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bmd230__DateTime);
	if (id < 0)
		return soap->error;
	return soap_out_bmd230__DateTime(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bmd230__DateTime ** SOAP_FMAC4 soap_in_PointerTobmd230__DateTime(struct soap *soap, const char *tag, struct bmd230__DateTime **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bmd230__DateTime **)soap_malloc(soap, sizeof(struct bmd230__DateTime *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bmd230__DateTime(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bmd230__DateTime **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bmd230__DateTime, sizeof(struct bmd230__DateTime), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobmd230__DateTime(struct soap *soap, struct bmd230__DateTime *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobmd230__DateTime);
	if (soap_out_PointerTobmd230__DateTime(soap, tag?tag:"bmd230:DateTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__DateTime ** SOAP_FMAC4 soap_get_PointerTobmd230__DateTime(struct soap *soap, struct bmd230__DateTime **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobmd230__DateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobmd230__secLevelInfo(struct soap *soap, struct bmd230__secLevelInfo *const*a)
{
	if (*a)
		soap_serialize_bmd230__secLevelInfo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobmd230__secLevelInfo(struct soap *soap, const char *tag, int id, struct bmd230__secLevelInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_bmd230__secLevelInfo);
	if (id < 0)
		return soap->error;
	return soap_out_bmd230__secLevelInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bmd230__secLevelInfo ** SOAP_FMAC4 soap_in_PointerTobmd230__secLevelInfo(struct soap *soap, const char *tag, struct bmd230__secLevelInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bmd230__secLevelInfo **)soap_malloc(soap, sizeof(struct bmd230__secLevelInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bmd230__secLevelInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bmd230__secLevelInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bmd230__secLevelInfo, sizeof(struct bmd230__secLevelInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobmd230__secLevelInfo(struct soap *soap, struct bmd230__secLevelInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobmd230__secLevelInfo);
	if (soap_out_PointerTobmd230__secLevelInfo(soap, tag?tag:"bmd230:secLevelInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__secLevelInfo ** SOAP_FMAC4 soap_get_PointerTobmd230__secLevelInfo(struct soap *soap, struct bmd230__secLevelInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobmd230__secLevelInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobmd230__secCategoryInfo(struct soap *soap, struct bmd230__secCategoryInfo *const*a)
{
	if (*a)
		soap_serialize_bmd230__secCategoryInfo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobmd230__secCategoryInfo(struct soap *soap, const char *tag, int id, struct bmd230__secCategoryInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_bmd230__secCategoryInfo);
	if (id < 0)
		return soap->error;
	return soap_out_bmd230__secCategoryInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bmd230__secCategoryInfo ** SOAP_FMAC4 soap_in_PointerTobmd230__secCategoryInfo(struct soap *soap, const char *tag, struct bmd230__secCategoryInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bmd230__secCategoryInfo **)soap_malloc(soap, sizeof(struct bmd230__secCategoryInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bmd230__secCategoryInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bmd230__secCategoryInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bmd230__secCategoryInfo, sizeof(struct bmd230__secCategoryInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobmd230__secCategoryInfo(struct soap *soap, struct bmd230__secCategoryInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobmd230__secCategoryInfo);
	if (soap_out_PointerTobmd230__secCategoryInfo(soap, tag?tag:"bmd230:secCategoryInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__secCategoryInfo ** SOAP_FMAC4 soap_get_PointerTobmd230__secCategoryInfo(struct soap *soap, struct bmd230__secCategoryInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobmd230__secCategoryInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobmd230__singleSecLevelInfo(struct soap *soap, struct bmd230__singleSecLevelInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bmd230__singleSecLevelInfo))
		soap_serialize_bmd230__singleSecLevelInfo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobmd230__singleSecLevelInfo(struct soap *soap, const char *tag, int id, struct bmd230__singleSecLevelInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bmd230__singleSecLevelInfo);
	if (id < 0)
		return soap->error;
	return soap_out_bmd230__singleSecLevelInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bmd230__singleSecLevelInfo ** SOAP_FMAC4 soap_in_PointerTobmd230__singleSecLevelInfo(struct soap *soap, const char *tag, struct bmd230__singleSecLevelInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bmd230__singleSecLevelInfo **)soap_malloc(soap, sizeof(struct bmd230__singleSecLevelInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bmd230__singleSecLevelInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bmd230__singleSecLevelInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bmd230__singleSecLevelInfo, sizeof(struct bmd230__singleSecLevelInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobmd230__singleSecLevelInfo(struct soap *soap, struct bmd230__singleSecLevelInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobmd230__singleSecLevelInfo);
	if (soap_out_PointerTobmd230__singleSecLevelInfo(soap, tag?tag:"bmd230:singleSecLevelInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__singleSecLevelInfo ** SOAP_FMAC4 soap_get_PointerTobmd230__singleSecLevelInfo(struct soap *soap, struct bmd230__singleSecLevelInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobmd230__singleSecLevelInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobmd230__singleSecCategoryInfo(struct soap *soap, struct bmd230__singleSecCategoryInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bmd230__singleSecCategoryInfo))
		soap_serialize_bmd230__singleSecCategoryInfo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobmd230__singleSecCategoryInfo(struct soap *soap, const char *tag, int id, struct bmd230__singleSecCategoryInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bmd230__singleSecCategoryInfo);
	if (id < 0)
		return soap->error;
	return soap_out_bmd230__singleSecCategoryInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bmd230__singleSecCategoryInfo ** SOAP_FMAC4 soap_in_PointerTobmd230__singleSecCategoryInfo(struct soap *soap, const char *tag, struct bmd230__singleSecCategoryInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bmd230__singleSecCategoryInfo **)soap_malloc(soap, sizeof(struct bmd230__singleSecCategoryInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bmd230__singleSecCategoryInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bmd230__singleSecCategoryInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bmd230__singleSecCategoryInfo, sizeof(struct bmd230__singleSecCategoryInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobmd230__singleSecCategoryInfo(struct soap *soap, struct bmd230__singleSecCategoryInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobmd230__singleSecCategoryInfo);
	if (soap_out_PointerTobmd230__singleSecCategoryInfo(soap, tag?tag:"bmd230:singleSecCategoryInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__singleSecCategoryInfo ** SOAP_FMAC4 soap_get_PointerTobmd230__singleSecCategoryInfo(struct soap *soap, struct bmd230__singleSecCategoryInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobmd230__singleSecCategoryInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobmd230__singleClassInfo(struct soap *soap, struct bmd230__singleClassInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bmd230__singleClassInfo))
		soap_serialize_bmd230__singleClassInfo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobmd230__singleClassInfo(struct soap *soap, const char *tag, int id, struct bmd230__singleClassInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bmd230__singleClassInfo);
	if (id < 0)
		return soap->error;
	return soap_out_bmd230__singleClassInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bmd230__singleClassInfo ** SOAP_FMAC4 soap_in_PointerTobmd230__singleClassInfo(struct soap *soap, const char *tag, struct bmd230__singleClassInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bmd230__singleClassInfo **)soap_malloc(soap, sizeof(struct bmd230__singleClassInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bmd230__singleClassInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bmd230__singleClassInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bmd230__singleClassInfo, sizeof(struct bmd230__singleClassInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobmd230__singleClassInfo(struct soap *soap, struct bmd230__singleClassInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobmd230__singleClassInfo);
	if (soap_out_PointerTobmd230__singleClassInfo(soap, tag?tag:"bmd230:singleClassInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__singleClassInfo ** SOAP_FMAC4 soap_get_PointerTobmd230__singleClassInfo(struct soap *soap, struct bmd230__singleClassInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobmd230__singleClassInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobmd230__singleGroupInfo(struct soap *soap, struct bmd230__singleGroupInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bmd230__singleGroupInfo))
		soap_serialize_bmd230__singleGroupInfo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobmd230__singleGroupInfo(struct soap *soap, const char *tag, int id, struct bmd230__singleGroupInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bmd230__singleGroupInfo);
	if (id < 0)
		return soap->error;
	return soap_out_bmd230__singleGroupInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bmd230__singleGroupInfo ** SOAP_FMAC4 soap_in_PointerTobmd230__singleGroupInfo(struct soap *soap, const char *tag, struct bmd230__singleGroupInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bmd230__singleGroupInfo **)soap_malloc(soap, sizeof(struct bmd230__singleGroupInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bmd230__singleGroupInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bmd230__singleGroupInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bmd230__singleGroupInfo, sizeof(struct bmd230__singleGroupInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobmd230__singleGroupInfo(struct soap *soap, struct bmd230__singleGroupInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobmd230__singleGroupInfo);
	if (soap_out_PointerTobmd230__singleGroupInfo(soap, tag?tag:"bmd230:singleGroupInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__singleGroupInfo ** SOAP_FMAC4 soap_get_PointerTobmd230__singleGroupInfo(struct soap *soap, struct bmd230__singleGroupInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobmd230__singleGroupInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobmd230__singleRoleInfo(struct soap *soap, struct bmd230__singleRoleInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bmd230__singleRoleInfo))
		soap_serialize_bmd230__singleRoleInfo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobmd230__singleRoleInfo(struct soap *soap, const char *tag, int id, struct bmd230__singleRoleInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bmd230__singleRoleInfo);
	if (id < 0)
		return soap->error;
	return soap_out_bmd230__singleRoleInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bmd230__singleRoleInfo ** SOAP_FMAC4 soap_in_PointerTobmd230__singleRoleInfo(struct soap *soap, const char *tag, struct bmd230__singleRoleInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bmd230__singleRoleInfo **)soap_malloc(soap, sizeof(struct bmd230__singleRoleInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bmd230__singleRoleInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bmd230__singleRoleInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bmd230__singleRoleInfo, sizeof(struct bmd230__singleRoleInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobmd230__singleRoleInfo(struct soap *soap, struct bmd230__singleRoleInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobmd230__singleRoleInfo);
	if (soap_out_PointerTobmd230__singleRoleInfo(soap, tag?tag:"bmd230:singleRoleInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__singleRoleInfo ** SOAP_FMAC4 soap_get_PointerTobmd230__singleRoleInfo(struct soap *soap, struct bmd230__singleRoleInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobmd230__singleRoleInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobmd230__mtdsInfo(struct soap *soap, struct bmd230__mtdsInfo *const*a)
{
	if (*a)
		soap_serialize_bmd230__mtdsInfo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobmd230__mtdsInfo(struct soap *soap, const char *tag, int id, struct bmd230__mtdsInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_bmd230__mtdsInfo);
	if (id < 0)
		return soap->error;
	return soap_out_bmd230__mtdsInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bmd230__mtdsInfo ** SOAP_FMAC4 soap_in_PointerTobmd230__mtdsInfo(struct soap *soap, const char *tag, struct bmd230__mtdsInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bmd230__mtdsInfo **)soap_malloc(soap, sizeof(struct bmd230__mtdsInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bmd230__mtdsInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bmd230__mtdsInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bmd230__mtdsInfo, sizeof(struct bmd230__mtdsInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobmd230__mtdsInfo(struct soap *soap, struct bmd230__mtdsInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobmd230__mtdsInfo);
	if (soap_out_PointerTobmd230__mtdsInfo(soap, tag?tag:"bmd230:mtdsInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__mtdsInfo ** SOAP_FMAC4 soap_get_PointerTobmd230__mtdsInfo(struct soap *soap, struct bmd230__mtdsInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobmd230__mtdsInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobmd230__singleUserInfo(struct soap *soap, struct bmd230__singleUserInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bmd230__singleUserInfo))
		soap_serialize_bmd230__singleUserInfo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobmd230__singleUserInfo(struct soap *soap, const char *tag, int id, struct bmd230__singleUserInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bmd230__singleUserInfo);
	if (id < 0)
		return soap->error;
	return soap_out_bmd230__singleUserInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bmd230__singleUserInfo ** SOAP_FMAC4 soap_in_PointerTobmd230__singleUserInfo(struct soap *soap, const char *tag, struct bmd230__singleUserInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bmd230__singleUserInfo **)soap_malloc(soap, sizeof(struct bmd230__singleUserInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bmd230__singleUserInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bmd230__singleUserInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bmd230__singleUserInfo, sizeof(struct bmd230__singleUserInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobmd230__singleUserInfo(struct soap *soap, struct bmd230__singleUserInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobmd230__singleUserInfo);
	if (soap_out_PointerTobmd230__singleUserInfo(soap, tag?tag:"bmd230:singleUserInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__singleUserInfo ** SOAP_FMAC4 soap_get_PointerTobmd230__singleUserInfo(struct soap *soap, struct bmd230__singleUserInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobmd230__singleUserInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobmd230__userNewGroupInfo(struct soap *soap, struct bmd230__userNewGroupInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bmd230__userNewGroupInfo))
		soap_serialize_bmd230__userNewGroupInfo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobmd230__userNewGroupInfo(struct soap *soap, const char *tag, int id, struct bmd230__userNewGroupInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bmd230__userNewGroupInfo);
	if (id < 0)
		return soap->error;
	return soap_out_bmd230__userNewGroupInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bmd230__userNewGroupInfo ** SOAP_FMAC4 soap_in_PointerTobmd230__userNewGroupInfo(struct soap *soap, const char *tag, struct bmd230__userNewGroupInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bmd230__userNewGroupInfo **)soap_malloc(soap, sizeof(struct bmd230__userNewGroupInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bmd230__userNewGroupInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bmd230__userNewGroupInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bmd230__userNewGroupInfo, sizeof(struct bmd230__userNewGroupInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobmd230__userNewGroupInfo(struct soap *soap, struct bmd230__userNewGroupInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobmd230__userNewGroupInfo);
	if (soap_out_PointerTobmd230__userNewGroupInfo(soap, tag?tag:"bmd230:userNewGroupInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__userNewGroupInfo ** SOAP_FMAC4 soap_get_PointerTobmd230__userNewGroupInfo(struct soap *soap, struct bmd230__userNewGroupInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobmd230__userNewGroupInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobmd230__stringList(struct soap *soap, struct bmd230__stringList *const*a)
{
	if (*a)
		soap_serialize_bmd230__stringList(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobmd230__stringList(struct soap *soap, const char *tag, int id, struct bmd230__stringList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_bmd230__stringList);
	if (id < 0)
		return soap->error;
	return soap_out_bmd230__stringList(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bmd230__stringList ** SOAP_FMAC4 soap_in_PointerTobmd230__stringList(struct soap *soap, const char *tag, struct bmd230__stringList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bmd230__stringList **)soap_malloc(soap, sizeof(struct bmd230__stringList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bmd230__stringList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bmd230__stringList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bmd230__stringList, sizeof(struct bmd230__stringList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobmd230__stringList(struct soap *soap, struct bmd230__stringList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobmd230__stringList);
	if (soap_out_PointerTobmd230__stringList(soap, tag?tag:"bmd230:stringList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__stringList ** SOAP_FMAC4 soap_get_PointerTobmd230__stringList(struct soap *soap, struct bmd230__stringList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobmd230__stringList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__string(struct soap *soap, char **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__string))
		soap_serialize_xsd__string(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__string(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__string);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerToxsd__string(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__string, sizeof(char *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__string(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__string);
	if (soap_out_PointerToxsd__string(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerToxsd__string(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobmd230__mtdSearchSingleValue(struct soap *soap, struct bmd230__mtdSearchSingleValue *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bmd230__mtdSearchSingleValue))
		soap_serialize_bmd230__mtdSearchSingleValue(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobmd230__mtdSearchSingleValue(struct soap *soap, const char *tag, int id, struct bmd230__mtdSearchSingleValue *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bmd230__mtdSearchSingleValue);
	if (id < 0)
		return soap->error;
	return soap_out_bmd230__mtdSearchSingleValue(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bmd230__mtdSearchSingleValue ** SOAP_FMAC4 soap_in_PointerTobmd230__mtdSearchSingleValue(struct soap *soap, const char *tag, struct bmd230__mtdSearchSingleValue **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bmd230__mtdSearchSingleValue **)soap_malloc(soap, sizeof(struct bmd230__mtdSearchSingleValue *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bmd230__mtdSearchSingleValue(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bmd230__mtdSearchSingleValue **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bmd230__mtdSearchSingleValue, sizeof(struct bmd230__mtdSearchSingleValue), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobmd230__mtdSearchSingleValue(struct soap *soap, struct bmd230__mtdSearchSingleValue *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobmd230__mtdSearchSingleValue);
	if (soap_out_PointerTobmd230__mtdSearchSingleValue(soap, tag?tag:"bmd230:mtdSearchSingleValue", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__mtdSearchSingleValue ** SOAP_FMAC4 soap_get_PointerTobmd230__mtdSearchSingleValue(struct soap *soap, struct bmd230__mtdSearchSingleValue **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobmd230__mtdSearchSingleValue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobmd230__historySingleResult(struct soap *soap, struct bmd230__historySingleResult *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bmd230__historySingleResult))
		soap_serialize_bmd230__historySingleResult(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobmd230__historySingleResult(struct soap *soap, const char *tag, int id, struct bmd230__historySingleResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bmd230__historySingleResult);
	if (id < 0)
		return soap->error;
	return soap_out_bmd230__historySingleResult(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bmd230__historySingleResult ** SOAP_FMAC4 soap_in_PointerTobmd230__historySingleResult(struct soap *soap, const char *tag, struct bmd230__historySingleResult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bmd230__historySingleResult **)soap_malloc(soap, sizeof(struct bmd230__historySingleResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bmd230__historySingleResult(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bmd230__historySingleResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bmd230__historySingleResult, sizeof(struct bmd230__historySingleResult), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobmd230__historySingleResult(struct soap *soap, struct bmd230__historySingleResult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobmd230__historySingleResult);
	if (soap_out_PointerTobmd230__historySingleResult(soap, tag?tag:"bmd230:historySingleResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__historySingleResult ** SOAP_FMAC4 soap_get_PointerTobmd230__historySingleResult(struct soap *soap, struct bmd230__historySingleResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobmd230__historySingleResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobmd230__searchSingleResult(struct soap *soap, struct bmd230__searchSingleResult *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bmd230__searchSingleResult))
		soap_serialize_bmd230__searchSingleResult(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobmd230__searchSingleResult(struct soap *soap, const char *tag, int id, struct bmd230__searchSingleResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bmd230__searchSingleResult);
	if (id < 0)
		return soap->error;
	return soap_out_bmd230__searchSingleResult(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bmd230__searchSingleResult ** SOAP_FMAC4 soap_in_PointerTobmd230__searchSingleResult(struct soap *soap, const char *tag, struct bmd230__searchSingleResult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bmd230__searchSingleResult **)soap_malloc(soap, sizeof(struct bmd230__searchSingleResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bmd230__searchSingleResult(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bmd230__searchSingleResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bmd230__searchSingleResult, sizeof(struct bmd230__searchSingleResult), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobmd230__searchSingleResult(struct soap *soap, struct bmd230__searchSingleResult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobmd230__searchSingleResult);
	if (soap_out_PointerTobmd230__searchSingleResult(soap, tag?tag:"bmd230:searchSingleResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__searchSingleResult ** SOAP_FMAC4 soap_get_PointerTobmd230__searchSingleResult(struct soap *soap, struct bmd230__searchSingleResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobmd230__searchSingleResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobmd230__mtdSingleInfo(struct soap *soap, struct bmd230__mtdSingleInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bmd230__mtdSingleInfo))
		soap_serialize_bmd230__mtdSingleInfo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobmd230__mtdSingleInfo(struct soap *soap, const char *tag, int id, struct bmd230__mtdSingleInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bmd230__mtdSingleInfo);
	if (id < 0)
		return soap->error;
	return soap_out_bmd230__mtdSingleInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bmd230__mtdSingleInfo ** SOAP_FMAC4 soap_in_PointerTobmd230__mtdSingleInfo(struct soap *soap, const char *tag, struct bmd230__mtdSingleInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bmd230__mtdSingleInfo **)soap_malloc(soap, sizeof(struct bmd230__mtdSingleInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bmd230__mtdSingleInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bmd230__mtdSingleInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bmd230__mtdSingleInfo, sizeof(struct bmd230__mtdSingleInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobmd230__mtdSingleInfo(struct soap *soap, struct bmd230__mtdSingleInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobmd230__mtdSingleInfo);
	if (soap_out_PointerTobmd230__mtdSingleInfo(soap, tag?tag:"bmd230:mtdSingleInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__mtdSingleInfo ** SOAP_FMAC4 soap_get_PointerTobmd230__mtdSingleInfo(struct soap *soap, struct bmd230__mtdSingleInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobmd230__mtdSingleInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobmd230__searchSortInfo(struct soap *soap, struct bmd230__searchSortInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bmd230__searchSortInfo))
		soap_serialize_bmd230__searchSortInfo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobmd230__searchSortInfo(struct soap *soap, const char *tag, int id, struct bmd230__searchSortInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bmd230__searchSortInfo);
	if (id < 0)
		return soap->error;
	return soap_out_bmd230__searchSortInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bmd230__searchSortInfo ** SOAP_FMAC4 soap_in_PointerTobmd230__searchSortInfo(struct soap *soap, const char *tag, struct bmd230__searchSortInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bmd230__searchSortInfo **)soap_malloc(soap, sizeof(struct bmd230__searchSortInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bmd230__searchSortInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bmd230__searchSortInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bmd230__searchSortInfo, sizeof(struct bmd230__searchSortInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobmd230__searchSortInfo(struct soap *soap, struct bmd230__searchSortInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobmd230__searchSortInfo);
	if (soap_out_PointerTobmd230__searchSortInfo(soap, tag?tag:"bmd230:searchSortInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__searchSortInfo ** SOAP_FMAC4 soap_get_PointerTobmd230__searchSortInfo(struct soap *soap, struct bmd230__searchSortInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobmd230__searchSortInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobmd230__fileComplex(struct soap *soap, struct bmd230__fileComplex *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bmd230__fileComplex))
		soap_serialize_bmd230__fileComplex(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobmd230__fileComplex(struct soap *soap, const char *tag, int id, struct bmd230__fileComplex *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bmd230__fileComplex);
	if (id < 0)
		return soap->error;
	return soap_out_bmd230__fileComplex(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bmd230__fileComplex ** SOAP_FMAC4 soap_in_PointerTobmd230__fileComplex(struct soap *soap, const char *tag, struct bmd230__fileComplex **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bmd230__fileComplex **)soap_malloc(soap, sizeof(struct bmd230__fileComplex *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bmd230__fileComplex(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bmd230__fileComplex **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bmd230__fileComplex, sizeof(struct bmd230__fileComplex), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobmd230__fileComplex(struct soap *soap, struct bmd230__fileComplex *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobmd230__fileComplex);
	if (soap_out_PointerTobmd230__fileComplex(soap, tag?tag:"bmd230:fileComplex", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__fileComplex ** SOAP_FMAC4 soap_get_PointerTobmd230__fileComplex(struct soap *soap, struct bmd230__fileComplex **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobmd230__fileComplex(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobmd230__mtdsValues(struct soap *soap, struct bmd230__mtdsValues *const*a)
{
	if (*a)
		soap_serialize_bmd230__mtdsValues(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobmd230__mtdsValues(struct soap *soap, const char *tag, int id, struct bmd230__mtdsValues *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_bmd230__mtdsValues);
	if (id < 0)
		return soap->error;
	return soap_out_bmd230__mtdsValues(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bmd230__mtdsValues ** SOAP_FMAC4 soap_in_PointerTobmd230__mtdsValues(struct soap *soap, const char *tag, struct bmd230__mtdsValues **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bmd230__mtdsValues **)soap_malloc(soap, sizeof(struct bmd230__mtdsValues *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bmd230__mtdsValues(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bmd230__mtdsValues **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bmd230__mtdsValues, sizeof(struct bmd230__mtdsValues), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobmd230__mtdsValues(struct soap *soap, struct bmd230__mtdsValues *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobmd230__mtdsValues);
	if (soap_out_PointerTobmd230__mtdsValues(soap, tag?tag:"bmd230:mtdsValues", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__mtdsValues ** SOAP_FMAC4 soap_get_PointerTobmd230__mtdsValues(struct soap *soap, struct bmd230__mtdsValues **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobmd230__mtdsValues(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobmd230__mtdSingleValue(struct soap *soap, struct bmd230__mtdSingleValue *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bmd230__mtdSingleValue))
		soap_serialize_bmd230__mtdSingleValue(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobmd230__mtdSingleValue(struct soap *soap, const char *tag, int id, struct bmd230__mtdSingleValue *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bmd230__mtdSingleValue);
	if (id < 0)
		return soap->error;
	return soap_out_bmd230__mtdSingleValue(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bmd230__mtdSingleValue ** SOAP_FMAC4 soap_in_PointerTobmd230__mtdSingleValue(struct soap *soap, const char *tag, struct bmd230__mtdSingleValue **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bmd230__mtdSingleValue **)soap_malloc(soap, sizeof(struct bmd230__mtdSingleValue *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bmd230__mtdSingleValue(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bmd230__mtdSingleValue **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bmd230__mtdSingleValue, sizeof(struct bmd230__mtdSingleValue), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobmd230__mtdSingleValue(struct soap *soap, struct bmd230__mtdSingleValue *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobmd230__mtdSingleValue);
	if (soap_out_PointerTobmd230__mtdSingleValue(soap, tag?tag:"bmd230:mtdSingleValue", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__mtdSingleValue ** SOAP_FMAC4 soap_get_PointerTobmd230__mtdSingleValue(struct soap *soap, struct bmd230__mtdSingleValue **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobmd230__mtdSingleValue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobmd230__fileInfo(struct soap *soap, struct bmd230__fileInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bmd230__fileInfo))
		soap_serialize_bmd230__fileInfo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobmd230__fileInfo(struct soap *soap, const char *tag, int id, struct bmd230__fileInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bmd230__fileInfo);
	if (id < 0)
		return soap->error;
	return soap_out_bmd230__fileInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bmd230__fileInfo ** SOAP_FMAC4 soap_in_PointerTobmd230__fileInfo(struct soap *soap, const char *tag, struct bmd230__fileInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bmd230__fileInfo **)soap_malloc(soap, sizeof(struct bmd230__fileInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bmd230__fileInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bmd230__fileInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bmd230__fileInfo, sizeof(struct bmd230__fileInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobmd230__fileInfo(struct soap *soap, struct bmd230__fileInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobmd230__fileInfo);
	if (soap_out_PointerTobmd230__fileInfo(soap, tag?tag:"bmd230:fileInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__fileInfo ** SOAP_FMAC4 soap_get_PointerTobmd230__fileInfo(struct soap *soap, struct bmd230__fileInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobmd230__fileInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobmd230__myBinaryDataType(struct soap *soap, struct bmd230__myBinaryDataType *const*a)
{
	if (*a)
		soap_serialize_bmd230__myBinaryDataType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobmd230__myBinaryDataType(struct soap *soap, const char *tag, int id, struct bmd230__myBinaryDataType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_bmd230__myBinaryDataType);
	if (id < 0)
		return soap->error;
	return soap_out_bmd230__myBinaryDataType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bmd230__myBinaryDataType ** SOAP_FMAC4 soap_in_PointerTobmd230__myBinaryDataType(struct soap *soap, const char *tag, struct bmd230__myBinaryDataType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bmd230__myBinaryDataType **)soap_malloc(soap, sizeof(struct bmd230__myBinaryDataType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bmd230__myBinaryDataType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bmd230__myBinaryDataType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bmd230__myBinaryDataType, sizeof(struct bmd230__myBinaryDataType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobmd230__myBinaryDataType(struct soap *soap, struct bmd230__myBinaryDataType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobmd230__myBinaryDataType);
	if (soap_out_PointerTobmd230__myBinaryDataType(soap, tag?tag:"bmd230:myBinaryDataType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__myBinaryDataType ** SOAP_FMAC4 soap_get_PointerTobmd230__myBinaryDataType(struct soap *soap, struct bmd230__myBinaryDataType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobmd230__myBinaryDataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobmd230__SignatureList(struct soap *soap, struct bmd230__SignatureList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bmd230__SignatureList))
		soap_serialize_bmd230__SignatureList(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobmd230__SignatureList(struct soap *soap, const char *tag, int id, struct bmd230__SignatureList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bmd230__SignatureList);
	if (id < 0)
		return soap->error;
	return soap_out_bmd230__SignatureList(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bmd230__SignatureList ** SOAP_FMAC4 soap_in_PointerTobmd230__SignatureList(struct soap *soap, const char *tag, struct bmd230__SignatureList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bmd230__SignatureList **)soap_malloc(soap, sizeof(struct bmd230__SignatureList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bmd230__SignatureList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bmd230__SignatureList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bmd230__SignatureList, sizeof(struct bmd230__SignatureList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobmd230__SignatureList(struct soap *soap, struct bmd230__SignatureList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobmd230__SignatureList);
	if (soap_out_PointerTobmd230__SignatureList(soap, tag?tag:"bmd230:SignatureList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__SignatureList ** SOAP_FMAC4 soap_get_PointerTobmd230__SignatureList(struct soap *soap, struct bmd230__SignatureList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobmd230__SignatureList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobmd230__SignatureSingle(struct soap *soap, struct bmd230__SignatureSingle *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bmd230__SignatureSingle))
		soap_serialize_bmd230__SignatureSingle(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobmd230__SignatureSingle(struct soap *soap, const char *tag, int id, struct bmd230__SignatureSingle *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bmd230__SignatureSingle);
	if (id < 0)
		return soap->error;
	return soap_out_bmd230__SignatureSingle(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bmd230__SignatureSingle ** SOAP_FMAC4 soap_in_PointerTobmd230__SignatureSingle(struct soap *soap, const char *tag, struct bmd230__SignatureSingle **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bmd230__SignatureSingle **)soap_malloc(soap, sizeof(struct bmd230__SignatureSingle *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bmd230__SignatureSingle(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bmd230__SignatureSingle **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bmd230__SignatureSingle, sizeof(struct bmd230__SignatureSingle), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobmd230__SignatureSingle(struct soap *soap, struct bmd230__SignatureSingle *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobmd230__SignatureSingle);
	if (soap_out_PointerTobmd230__SignatureSingle(soap, tag?tag:"bmd230:SignatureSingle", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__SignatureSingle ** SOAP_FMAC4 soap_get_PointerTobmd230__SignatureSingle(struct soap *soap, struct bmd230__SignatureSingle **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobmd230__SignatureSingle(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobmd230__DVCSSingle(struct soap *soap, struct bmd230__DVCSSingle *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bmd230__DVCSSingle))
		soap_serialize_bmd230__DVCSSingle(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobmd230__DVCSSingle(struct soap *soap, const char *tag, int id, struct bmd230__DVCSSingle *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bmd230__DVCSSingle);
	if (id < 0)
		return soap->error;
	return soap_out_bmd230__DVCSSingle(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bmd230__DVCSSingle ** SOAP_FMAC4 soap_in_PointerTobmd230__DVCSSingle(struct soap *soap, const char *tag, struct bmd230__DVCSSingle **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bmd230__DVCSSingle **)soap_malloc(soap, sizeof(struct bmd230__DVCSSingle *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bmd230__DVCSSingle(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bmd230__DVCSSingle **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bmd230__DVCSSingle, sizeof(struct bmd230__DVCSSingle), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobmd230__DVCSSingle(struct soap *soap, struct bmd230__DVCSSingle *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobmd230__DVCSSingle);
	if (soap_out_PointerTobmd230__DVCSSingle(soap, tag?tag:"bmd230:DVCSSingle", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__DVCSSingle ** SOAP_FMAC4 soap_get_PointerTobmd230__DVCSSingle(struct soap *soap, struct bmd230__DVCSSingle **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobmd230__DVCSSingle(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobmd230__TimestampSingle(struct soap *soap, struct bmd230__TimestampSingle *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bmd230__TimestampSingle))
		soap_serialize_bmd230__TimestampSingle(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobmd230__TimestampSingle(struct soap *soap, const char *tag, int id, struct bmd230__TimestampSingle *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bmd230__TimestampSingle);
	if (id < 0)
		return soap->error;
	return soap_out_bmd230__TimestampSingle(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bmd230__TimestampSingle ** SOAP_FMAC4 soap_in_PointerTobmd230__TimestampSingle(struct soap *soap, const char *tag, struct bmd230__TimestampSingle **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bmd230__TimestampSingle **)soap_malloc(soap, sizeof(struct bmd230__TimestampSingle *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bmd230__TimestampSingle(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bmd230__TimestampSingle **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bmd230__TimestampSingle, sizeof(struct bmd230__TimestampSingle), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobmd230__TimestampSingle(struct soap *soap, struct bmd230__TimestampSingle *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobmd230__TimestampSingle);
	if (soap_out_PointerTobmd230__TimestampSingle(soap, tag?tag:"bmd230:TimestampSingle", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__TimestampSingle ** SOAP_FMAC4 soap_get_PointerTobmd230__TimestampSingle(struct soap *soap, struct bmd230__TimestampSingle **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobmd230__TimestampSingle(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobmd230__DVCSList(struct soap *soap, struct bmd230__DVCSList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bmd230__DVCSList))
		soap_serialize_bmd230__DVCSList(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobmd230__DVCSList(struct soap *soap, const char *tag, int id, struct bmd230__DVCSList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bmd230__DVCSList);
	if (id < 0)
		return soap->error;
	return soap_out_bmd230__DVCSList(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bmd230__DVCSList ** SOAP_FMAC4 soap_in_PointerTobmd230__DVCSList(struct soap *soap, const char *tag, struct bmd230__DVCSList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bmd230__DVCSList **)soap_malloc(soap, sizeof(struct bmd230__DVCSList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bmd230__DVCSList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bmd230__DVCSList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bmd230__DVCSList, sizeof(struct bmd230__DVCSList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobmd230__DVCSList(struct soap *soap, struct bmd230__DVCSList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobmd230__DVCSList);
	if (soap_out_PointerTobmd230__DVCSList(soap, tag?tag:"bmd230:DVCSList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__DVCSList ** SOAP_FMAC4 soap_get_PointerTobmd230__DVCSList(struct soap *soap, struct bmd230__DVCSList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobmd230__DVCSList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobmd230__TimestampList(struct soap *soap, struct bmd230__TimestampList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_bmd230__TimestampList))
		soap_serialize_bmd230__TimestampList(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobmd230__TimestampList(struct soap *soap, const char *tag, int id, struct bmd230__TimestampList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bmd230__TimestampList);
	if (id < 0)
		return soap->error;
	return soap_out_bmd230__TimestampList(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct bmd230__TimestampList ** SOAP_FMAC4 soap_in_PointerTobmd230__TimestampList(struct soap *soap, const char *tag, struct bmd230__TimestampList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct bmd230__TimestampList **)soap_malloc(soap, sizeof(struct bmd230__TimestampList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bmd230__TimestampList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct bmd230__TimestampList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bmd230__TimestampList, sizeof(struct bmd230__TimestampList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobmd230__TimestampList(struct soap *soap, struct bmd230__TimestampList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobmd230__TimestampList);
	if (soap_out_PointerTobmd230__TimestampList(soap, tag?tag:"bmd230:TimestampList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct bmd230__TimestampList ** SOAP_FMAC4 soap_get_PointerTobmd230__TimestampList(struct soap *soap, struct bmd230__TimestampList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobmd230__TimestampList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__base64Binary(struct soap *soap, struct xsd__base64Binary *const*a)
{
	if (*a)
		soap_serialize_xsd__base64Binary(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__base64Binary(struct soap *soap, const char *tag, int id, struct xsd__base64Binary *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_xsd__base64Binary);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__base64Binary(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct xsd__base64Binary ** SOAP_FMAC4 soap_in_PointerToxsd__base64Binary(struct soap *soap, const char *tag, struct xsd__base64Binary **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct xsd__base64Binary **)soap_malloc(soap, sizeof(struct xsd__base64Binary *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__base64Binary(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct xsd__base64Binary **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__base64Binary, sizeof(struct xsd__base64Binary), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__base64Binary(struct soap *soap, struct xsd__base64Binary *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__base64Binary);
	if (soap_out_PointerToxsd__base64Binary(soap, tag?tag:"xsd:base64Binary", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xsd__base64Binary ** SOAP_FMAC4 soap_get_PointerToxsd__base64Binary(struct soap *soap, struct xsd__base64Binary **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__base64Binary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTolong(struct soap *soap, long *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_long);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTolong(struct soap *soap, const char *tag, int id, long *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_long);
	if (id < 0)
		return soap->error;
	return soap_out_long(soap, tag, id, *a, type);
}

SOAP_FMAC3 long ** SOAP_FMAC4 soap_in_PointerTolong(struct soap *soap, const char *tag, long **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (long **)soap_malloc(soap, sizeof(long *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_long(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (long **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_long, sizeof(long), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTolong(struct soap *soap, long *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTolong);
	if (soap_out_PointerTolong(soap, tag?tag:"long", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 long ** SOAP_FMAC4 soap_get_PointerTolong(struct soap *soap, long **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTolong(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTounsignedByte(struct soap *soap, unsigned char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_unsignedByte);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTounsignedByte(struct soap *soap, const char *tag, int id, unsigned char *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_unsignedByte);
	if (id < 0)
		return soap->error;
	return soap_out_unsignedByte(soap, tag, id, *a, type);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_in_PointerTounsignedByte(struct soap *soap, const char *tag, unsigned char **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (unsigned char **)soap_malloc(soap, sizeof(unsigned char *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_unsignedByte(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (unsigned char **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_unsignedByte, sizeof(unsigned char), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTounsignedByte(struct soap *soap, unsigned char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTounsignedByte);
	if (soap_out_PointerTounsignedByte(soap, tag?tag:"unsignedByte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_get_PointerTounsignedByte(struct soap *soap, unsigned char **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTounsignedByte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__string, 1, -1, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__string);
	if (soap_out_xsd__string(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__Security(struct soap *soap, struct _wsse__Security *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__Security))
		soap_serialize__wsse__Security(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__Security(struct soap *soap, const char *tag, int id, struct _wsse__Security *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__Security);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__Security(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__Security ** SOAP_FMAC4 soap_in_PointerTo_wsse__Security(struct soap *soap, const char *tag, struct _wsse__Security **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__Security **)soap_malloc(soap, sizeof(struct _wsse__Security *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__Security(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__Security **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__Security, sizeof(struct _wsse__Security), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__Security(struct soap *soap, struct _wsse__Security *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsse__Security);
	if (soap_out_PointerTo_wsse__Security(soap, tag?tag:"wsse:Security", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Security ** SOAP_FMAC4 soap_get_PointerTo_wsse__Security(struct soap *soap, struct _wsse__Security **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__Security(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__SignatureType(struct soap *soap, struct ds__SignatureType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__SignatureType))
		soap_serialize_ds__SignatureType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__SignatureType(struct soap *soap, const char *tag, int id, struct ds__SignatureType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__SignatureType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__SignatureType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__SignatureType ** SOAP_FMAC4 soap_in_PointerTods__SignatureType(struct soap *soap, const char *tag, struct ds__SignatureType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__SignatureType **)soap_malloc(soap, sizeof(struct ds__SignatureType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__SignatureType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__SignatureType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__SignatureType, sizeof(struct ds__SignatureType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__SignatureType(struct soap *soap, struct ds__SignatureType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__SignatureType);
	if (soap_out_PointerTods__SignatureType(soap, tag?tag:"ds:SignatureType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__SignatureType ** SOAP_FMAC4 soap_get_PointerTods__SignatureType(struct soap *soap, struct ds__SignatureType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__SignatureType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__BinarySecurityToken(struct soap *soap, struct _wsse__BinarySecurityToken *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__BinarySecurityToken))
		soap_serialize__wsse__BinarySecurityToken(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__BinarySecurityToken(struct soap *soap, const char *tag, int id, struct _wsse__BinarySecurityToken *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__BinarySecurityToken);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__BinarySecurityToken(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__BinarySecurityToken ** SOAP_FMAC4 soap_in_PointerTo_wsse__BinarySecurityToken(struct soap *soap, const char *tag, struct _wsse__BinarySecurityToken **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__BinarySecurityToken **)soap_malloc(soap, sizeof(struct _wsse__BinarySecurityToken *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__BinarySecurityToken(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__BinarySecurityToken **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__BinarySecurityToken, sizeof(struct _wsse__BinarySecurityToken), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__BinarySecurityToken(struct soap *soap, struct _wsse__BinarySecurityToken *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsse__BinarySecurityToken);
	if (soap_out_PointerTo_wsse__BinarySecurityToken(soap, tag?tag:"wsse:BinarySecurityToken", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__BinarySecurityToken ** SOAP_FMAC4 soap_get_PointerTo_wsse__BinarySecurityToken(struct soap *soap, struct _wsse__BinarySecurityToken **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__BinarySecurityToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__UsernameToken(struct soap *soap, struct _wsse__UsernameToken *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__UsernameToken))
		soap_serialize__wsse__UsernameToken(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__UsernameToken(struct soap *soap, const char *tag, int id, struct _wsse__UsernameToken *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__UsernameToken);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__UsernameToken(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__UsernameToken ** SOAP_FMAC4 soap_in_PointerTo_wsse__UsernameToken(struct soap *soap, const char *tag, struct _wsse__UsernameToken **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__UsernameToken **)soap_malloc(soap, sizeof(struct _wsse__UsernameToken *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__UsernameToken(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__UsernameToken **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__UsernameToken, sizeof(struct _wsse__UsernameToken), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__UsernameToken(struct soap *soap, struct _wsse__UsernameToken *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsse__UsernameToken);
	if (soap_out_PointerTo_wsse__UsernameToken(soap, tag?tag:"wsse:UsernameToken", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__UsernameToken ** SOAP_FMAC4 soap_get_PointerTo_wsse__UsernameToken(struct soap *soap, struct _wsse__UsernameToken **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__UsernameToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsu__Timestamp(struct soap *soap, struct _wsu__Timestamp *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsu__Timestamp))
		soap_serialize__wsu__Timestamp(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsu__Timestamp(struct soap *soap, const char *tag, int id, struct _wsu__Timestamp *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsu__Timestamp);
	if (id < 0)
		return soap->error;
	return soap_out__wsu__Timestamp(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsu__Timestamp ** SOAP_FMAC4 soap_in_PointerTo_wsu__Timestamp(struct soap *soap, const char *tag, struct _wsu__Timestamp **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsu__Timestamp **)soap_malloc(soap, sizeof(struct _wsu__Timestamp *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsu__Timestamp(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsu__Timestamp **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsu__Timestamp, sizeof(struct _wsu__Timestamp), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsu__Timestamp(struct soap *soap, struct _wsu__Timestamp *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsu__Timestamp);
	if (soap_out_PointerTo_wsu__Timestamp(soap, tag?tag:"wsu:Timestamp", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsu__Timestamp ** SOAP_FMAC4 soap_get_PointerTo_wsu__Timestamp(struct soap *soap, struct _wsu__Timestamp **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsu__Timestamp(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__X509IssuerSerialType(struct soap *soap, struct ds__X509IssuerSerialType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__X509IssuerSerialType))
		soap_serialize_ds__X509IssuerSerialType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__X509IssuerSerialType(struct soap *soap, const char *tag, int id, struct ds__X509IssuerSerialType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__X509IssuerSerialType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__X509IssuerSerialType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__X509IssuerSerialType ** SOAP_FMAC4 soap_in_PointerTods__X509IssuerSerialType(struct soap *soap, const char *tag, struct ds__X509IssuerSerialType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__X509IssuerSerialType **)soap_malloc(soap, sizeof(struct ds__X509IssuerSerialType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__X509IssuerSerialType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__X509IssuerSerialType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__X509IssuerSerialType, sizeof(struct ds__X509IssuerSerialType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__X509IssuerSerialType(struct soap *soap, struct ds__X509IssuerSerialType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__X509IssuerSerialType);
	if (soap_out_PointerTods__X509IssuerSerialType(soap, tag?tag:"ds:X509IssuerSerialType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__X509IssuerSerialType ** SOAP_FMAC4 soap_get_PointerTods__X509IssuerSerialType(struct soap *soap, struct ds__X509IssuerSerialType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__X509IssuerSerialType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__RSAKeyValueType(struct soap *soap, struct ds__RSAKeyValueType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__RSAKeyValueType))
		soap_serialize_ds__RSAKeyValueType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__RSAKeyValueType(struct soap *soap, const char *tag, int id, struct ds__RSAKeyValueType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__RSAKeyValueType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__RSAKeyValueType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__RSAKeyValueType ** SOAP_FMAC4 soap_in_PointerTods__RSAKeyValueType(struct soap *soap, const char *tag, struct ds__RSAKeyValueType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__RSAKeyValueType **)soap_malloc(soap, sizeof(struct ds__RSAKeyValueType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__RSAKeyValueType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__RSAKeyValueType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__RSAKeyValueType, sizeof(struct ds__RSAKeyValueType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__RSAKeyValueType(struct soap *soap, struct ds__RSAKeyValueType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__RSAKeyValueType);
	if (soap_out_PointerTods__RSAKeyValueType(soap, tag?tag:"ds:RSAKeyValueType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__RSAKeyValueType ** SOAP_FMAC4 soap_get_PointerTods__RSAKeyValueType(struct soap *soap, struct ds__RSAKeyValueType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__RSAKeyValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__DSAKeyValueType(struct soap *soap, struct ds__DSAKeyValueType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__DSAKeyValueType))
		soap_serialize_ds__DSAKeyValueType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__DSAKeyValueType(struct soap *soap, const char *tag, int id, struct ds__DSAKeyValueType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__DSAKeyValueType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__DSAKeyValueType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__DSAKeyValueType ** SOAP_FMAC4 soap_in_PointerTods__DSAKeyValueType(struct soap *soap, const char *tag, struct ds__DSAKeyValueType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__DSAKeyValueType **)soap_malloc(soap, sizeof(struct ds__DSAKeyValueType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__DSAKeyValueType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__DSAKeyValueType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__DSAKeyValueType, sizeof(struct ds__DSAKeyValueType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__DSAKeyValueType(struct soap *soap, struct ds__DSAKeyValueType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__DSAKeyValueType);
	if (soap_out_PointerTods__DSAKeyValueType(soap, tag?tag:"ds:DSAKeyValueType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__DSAKeyValueType ** SOAP_FMAC4 soap_get_PointerTods__DSAKeyValueType(struct soap *soap, struct ds__DSAKeyValueType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__DSAKeyValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__TransformType(struct soap *soap, struct ds__TransformType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__TransformType))
		soap_serialize_ds__TransformType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__TransformType(struct soap *soap, const char *tag, int id, struct ds__TransformType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__TransformType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__TransformType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__TransformType ** SOAP_FMAC4 soap_in_PointerTods__TransformType(struct soap *soap, const char *tag, struct ds__TransformType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__TransformType **)soap_malloc(soap, sizeof(struct ds__TransformType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__TransformType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__TransformType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__TransformType, sizeof(struct ds__TransformType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__TransformType(struct soap *soap, struct ds__TransformType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__TransformType);
	if (soap_out_PointerTods__TransformType(soap, tag?tag:"ds:TransformType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__TransformType ** SOAP_FMAC4 soap_get_PointerTods__TransformType(struct soap *soap, struct ds__TransformType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__TransformType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__DigestMethodType(struct soap *soap, struct ds__DigestMethodType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__DigestMethodType))
		soap_serialize_ds__DigestMethodType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__DigestMethodType(struct soap *soap, const char *tag, int id, struct ds__DigestMethodType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__DigestMethodType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__DigestMethodType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__DigestMethodType ** SOAP_FMAC4 soap_in_PointerTods__DigestMethodType(struct soap *soap, const char *tag, struct ds__DigestMethodType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__DigestMethodType **)soap_malloc(soap, sizeof(struct ds__DigestMethodType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__DigestMethodType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__DigestMethodType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__DigestMethodType, sizeof(struct ds__DigestMethodType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__DigestMethodType(struct soap *soap, struct ds__DigestMethodType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__DigestMethodType);
	if (soap_out_PointerTods__DigestMethodType(soap, tag?tag:"ds:DigestMethodType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__DigestMethodType ** SOAP_FMAC4 soap_get_PointerTods__DigestMethodType(struct soap *soap, struct ds__DigestMethodType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__DigestMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__TransformsType(struct soap *soap, struct ds__TransformsType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__TransformsType))
		soap_serialize_ds__TransformsType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__TransformsType(struct soap *soap, const char *tag, int id, struct ds__TransformsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__TransformsType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__TransformsType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__TransformsType ** SOAP_FMAC4 soap_in_PointerTods__TransformsType(struct soap *soap, const char *tag, struct ds__TransformsType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__TransformsType **)soap_malloc(soap, sizeof(struct ds__TransformsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__TransformsType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__TransformsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__TransformsType, sizeof(struct ds__TransformsType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__TransformsType(struct soap *soap, struct ds__TransformsType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__TransformsType);
	if (soap_out_PointerTods__TransformsType(soap, tag?tag:"ds:TransformsType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__TransformsType ** SOAP_FMAC4 soap_get_PointerTods__TransformsType(struct soap *soap, struct ds__TransformsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__TransformsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToint(struct soap *soap, int *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToint(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_int);
	if (id < 0)
		return soap->error;
	return soap_out_int(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_in_PointerToint(struct soap *soap, const char *tag, int **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_int(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_int, sizeof(int), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToint(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToint);
	if (soap_out_PointerToint(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerToint(struct soap *soap, int **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTods__ReferenceType(struct soap *soap, struct ds__ReferenceType **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTods__ReferenceType))
		soap_serialize_PointerTods__ReferenceType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTods__ReferenceType(struct soap *soap, const char *tag, int id, struct ds__ReferenceType **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTods__ReferenceType);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTods__ReferenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__ReferenceType *** SOAP_FMAC4 soap_in_PointerToPointerTods__ReferenceType(struct soap *soap, const char *tag, struct ds__ReferenceType ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__ReferenceType ***)soap_malloc(soap, sizeof(struct ds__ReferenceType **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTods__ReferenceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__ReferenceType ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTods__ReferenceType, sizeof(struct ds__ReferenceType *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTods__ReferenceType(struct soap *soap, struct ds__ReferenceType **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTods__ReferenceType);
	if (soap_out_PointerToPointerTods__ReferenceType(soap, tag?tag:"ds:ReferenceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__ReferenceType *** SOAP_FMAC4 soap_get_PointerToPointerTods__ReferenceType(struct soap *soap, struct ds__ReferenceType ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTods__ReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__ReferenceType(struct soap *soap, struct ds__ReferenceType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__ReferenceType))
		soap_serialize_ds__ReferenceType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__ReferenceType(struct soap *soap, const char *tag, int id, struct ds__ReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__ReferenceType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__ReferenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__ReferenceType ** SOAP_FMAC4 soap_in_PointerTods__ReferenceType(struct soap *soap, const char *tag, struct ds__ReferenceType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__ReferenceType **)soap_malloc(soap, sizeof(struct ds__ReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__ReferenceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__ReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__ReferenceType, sizeof(struct ds__ReferenceType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__ReferenceType(struct soap *soap, struct ds__ReferenceType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__ReferenceType);
	if (soap_out_PointerTods__ReferenceType(soap, tag?tag:"ds:ReferenceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__ReferenceType ** SOAP_FMAC4 soap_get_PointerTods__ReferenceType(struct soap *soap, struct ds__ReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__ReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__SignatureMethodType(struct soap *soap, struct ds__SignatureMethodType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__SignatureMethodType))
		soap_serialize_ds__SignatureMethodType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__SignatureMethodType(struct soap *soap, const char *tag, int id, struct ds__SignatureMethodType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__SignatureMethodType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__SignatureMethodType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__SignatureMethodType ** SOAP_FMAC4 soap_in_PointerTods__SignatureMethodType(struct soap *soap, const char *tag, struct ds__SignatureMethodType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__SignatureMethodType **)soap_malloc(soap, sizeof(struct ds__SignatureMethodType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__SignatureMethodType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__SignatureMethodType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__SignatureMethodType, sizeof(struct ds__SignatureMethodType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__SignatureMethodType(struct soap *soap, struct ds__SignatureMethodType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__SignatureMethodType);
	if (soap_out_PointerTods__SignatureMethodType(soap, tag?tag:"ds:SignatureMethodType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__SignatureMethodType ** SOAP_FMAC4 soap_get_PointerTods__SignatureMethodType(struct soap *soap, struct ds__SignatureMethodType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__SignatureMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__CanonicalizationMethodType(struct soap *soap, struct ds__CanonicalizationMethodType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__CanonicalizationMethodType))
		soap_serialize_ds__CanonicalizationMethodType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__CanonicalizationMethodType(struct soap *soap, const char *tag, int id, struct ds__CanonicalizationMethodType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__CanonicalizationMethodType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__CanonicalizationMethodType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__CanonicalizationMethodType ** SOAP_FMAC4 soap_in_PointerTods__CanonicalizationMethodType(struct soap *soap, const char *tag, struct ds__CanonicalizationMethodType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__CanonicalizationMethodType **)soap_malloc(soap, sizeof(struct ds__CanonicalizationMethodType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__CanonicalizationMethodType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__CanonicalizationMethodType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__CanonicalizationMethodType, sizeof(struct ds__CanonicalizationMethodType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__CanonicalizationMethodType(struct soap *soap, struct ds__CanonicalizationMethodType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__CanonicalizationMethodType);
	if (soap_out_PointerTods__CanonicalizationMethodType(soap, tag?tag:"ds:CanonicalizationMethodType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__CanonicalizationMethodType ** SOAP_FMAC4 soap_get_PointerTods__CanonicalizationMethodType(struct soap *soap, struct ds__CanonicalizationMethodType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__CanonicalizationMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__SecurityTokenReference(struct soap *soap, struct _wsse__SecurityTokenReference *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__SecurityTokenReference))
		soap_serialize__wsse__SecurityTokenReference(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__SecurityTokenReference(struct soap *soap, const char *tag, int id, struct _wsse__SecurityTokenReference *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__SecurityTokenReference);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__SecurityTokenReference(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__SecurityTokenReference ** SOAP_FMAC4 soap_in_PointerTo_wsse__SecurityTokenReference(struct soap *soap, const char *tag, struct _wsse__SecurityTokenReference **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__SecurityTokenReference **)soap_malloc(soap, sizeof(struct _wsse__SecurityTokenReference *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__SecurityTokenReference(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__SecurityTokenReference **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__SecurityTokenReference, sizeof(struct _wsse__SecurityTokenReference), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__SecurityTokenReference(struct soap *soap, struct _wsse__SecurityTokenReference *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsse__SecurityTokenReference);
	if (soap_out_PointerTo_wsse__SecurityTokenReference(soap, tag?tag:"wsse:SecurityTokenReference", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__SecurityTokenReference ** SOAP_FMAC4 soap_get_PointerTo_wsse__SecurityTokenReference(struct soap *soap, struct _wsse__SecurityTokenReference **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__SecurityTokenReference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__X509DataType(struct soap *soap, struct ds__X509DataType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__X509DataType))
		soap_serialize_ds__X509DataType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__X509DataType(struct soap *soap, const char *tag, int id, struct ds__X509DataType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__X509DataType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__X509DataType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__X509DataType ** SOAP_FMAC4 soap_in_PointerTods__X509DataType(struct soap *soap, const char *tag, struct ds__X509DataType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__X509DataType **)soap_malloc(soap, sizeof(struct ds__X509DataType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__X509DataType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__X509DataType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__X509DataType, sizeof(struct ds__X509DataType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__X509DataType(struct soap *soap, struct ds__X509DataType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__X509DataType);
	if (soap_out_PointerTods__X509DataType(soap, tag?tag:"ds:X509DataType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__X509DataType ** SOAP_FMAC4 soap_get_PointerTods__X509DataType(struct soap *soap, struct ds__X509DataType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__X509DataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__RetrievalMethodType(struct soap *soap, struct ds__RetrievalMethodType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__RetrievalMethodType))
		soap_serialize_ds__RetrievalMethodType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__RetrievalMethodType(struct soap *soap, const char *tag, int id, struct ds__RetrievalMethodType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__RetrievalMethodType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__RetrievalMethodType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__RetrievalMethodType ** SOAP_FMAC4 soap_in_PointerTods__RetrievalMethodType(struct soap *soap, const char *tag, struct ds__RetrievalMethodType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__RetrievalMethodType **)soap_malloc(soap, sizeof(struct ds__RetrievalMethodType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__RetrievalMethodType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__RetrievalMethodType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__RetrievalMethodType, sizeof(struct ds__RetrievalMethodType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__RetrievalMethodType(struct soap *soap, struct ds__RetrievalMethodType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__RetrievalMethodType);
	if (soap_out_PointerTods__RetrievalMethodType(soap, tag?tag:"ds:RetrievalMethodType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__RetrievalMethodType ** SOAP_FMAC4 soap_get_PointerTods__RetrievalMethodType(struct soap *soap, struct ds__RetrievalMethodType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__RetrievalMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__KeyValueType(struct soap *soap, struct ds__KeyValueType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__KeyValueType))
		soap_serialize_ds__KeyValueType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__KeyValueType(struct soap *soap, const char *tag, int id, struct ds__KeyValueType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__KeyValueType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__KeyValueType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__KeyValueType ** SOAP_FMAC4 soap_in_PointerTods__KeyValueType(struct soap *soap, const char *tag, struct ds__KeyValueType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__KeyValueType **)soap_malloc(soap, sizeof(struct ds__KeyValueType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__KeyValueType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__KeyValueType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__KeyValueType, sizeof(struct ds__KeyValueType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__KeyValueType(struct soap *soap, struct ds__KeyValueType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__KeyValueType);
	if (soap_out_PointerTods__KeyValueType(soap, tag?tag:"ds:KeyValueType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__KeyValueType ** SOAP_FMAC4 soap_get_PointerTods__KeyValueType(struct soap *soap, struct ds__KeyValueType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__KeyValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_c14n__InclusiveNamespaces(struct soap *soap, struct _c14n__InclusiveNamespaces *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__c14n__InclusiveNamespaces))
		soap_serialize__c14n__InclusiveNamespaces(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_c14n__InclusiveNamespaces(struct soap *soap, const char *tag, int id, struct _c14n__InclusiveNamespaces *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__c14n__InclusiveNamespaces);
	if (id < 0)
		return soap->error;
	return soap_out__c14n__InclusiveNamespaces(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _c14n__InclusiveNamespaces ** SOAP_FMAC4 soap_in_PointerTo_c14n__InclusiveNamespaces(struct soap *soap, const char *tag, struct _c14n__InclusiveNamespaces **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _c14n__InclusiveNamespaces **)soap_malloc(soap, sizeof(struct _c14n__InclusiveNamespaces *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__c14n__InclusiveNamespaces(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _c14n__InclusiveNamespaces **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__c14n__InclusiveNamespaces, sizeof(struct _c14n__InclusiveNamespaces), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_c14n__InclusiveNamespaces(struct soap *soap, struct _c14n__InclusiveNamespaces *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_c14n__InclusiveNamespaces);
	if (soap_out_PointerTo_c14n__InclusiveNamespaces(soap, tag?tag:"c14n:InclusiveNamespaces", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _c14n__InclusiveNamespaces ** SOAP_FMAC4 soap_get_PointerTo_c14n__InclusiveNamespaces(struct soap *soap, struct _c14n__InclusiveNamespaces **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_c14n__InclusiveNamespaces(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__KeyInfoType(struct soap *soap, struct ds__KeyInfoType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__KeyInfoType))
		soap_serialize_ds__KeyInfoType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__KeyInfoType(struct soap *soap, const char *tag, int id, struct ds__KeyInfoType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__KeyInfoType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__KeyInfoType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__KeyInfoType ** SOAP_FMAC4 soap_in_PointerTods__KeyInfoType(struct soap *soap, const char *tag, struct ds__KeyInfoType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__KeyInfoType **)soap_malloc(soap, sizeof(struct ds__KeyInfoType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__KeyInfoType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__KeyInfoType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__KeyInfoType, sizeof(struct ds__KeyInfoType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__KeyInfoType(struct soap *soap, struct ds__KeyInfoType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__KeyInfoType);
	if (soap_out_PointerTods__KeyInfoType(soap, tag?tag:"ds:KeyInfoType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__KeyInfoType ** SOAP_FMAC4 soap_get_PointerTods__KeyInfoType(struct soap *soap, struct ds__KeyInfoType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__KeyInfoType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__SignedInfoType(struct soap *soap, struct ds__SignedInfoType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__SignedInfoType))
		soap_serialize_ds__SignedInfoType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__SignedInfoType(struct soap *soap, const char *tag, int id, struct ds__SignedInfoType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__SignedInfoType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__SignedInfoType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__SignedInfoType ** SOAP_FMAC4 soap_in_PointerTods__SignedInfoType(struct soap *soap, const char *tag, struct ds__SignedInfoType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__SignedInfoType **)soap_malloc(soap, sizeof(struct ds__SignedInfoType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__SignedInfoType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__SignedInfoType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__SignedInfoType, sizeof(struct ds__SignedInfoType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__SignedInfoType(struct soap *soap, struct ds__SignedInfoType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__SignedInfoType);
	if (soap_out_PointerTods__SignedInfoType(soap, tag?tag:"ds:SignedInfoType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__SignedInfoType ** SOAP_FMAC4 soap_get_PointerTods__SignedInfoType(struct soap *soap, struct ds__SignedInfoType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__SignedInfoType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__Embedded(struct soap *soap, struct _wsse__Embedded *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__Embedded))
		soap_serialize__wsse__Embedded(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__Embedded(struct soap *soap, const char *tag, int id, struct _wsse__Embedded *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__Embedded);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__Embedded(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__Embedded ** SOAP_FMAC4 soap_in_PointerTo_wsse__Embedded(struct soap *soap, const char *tag, struct _wsse__Embedded **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__Embedded **)soap_malloc(soap, sizeof(struct _wsse__Embedded *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__Embedded(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__Embedded **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__Embedded, sizeof(struct _wsse__Embedded), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__Embedded(struct soap *soap, struct _wsse__Embedded *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsse__Embedded);
	if (soap_out_PointerTo_wsse__Embedded(soap, tag?tag:"wsse:Embedded", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Embedded ** SOAP_FMAC4 soap_get_PointerTo_wsse__Embedded(struct soap *soap, struct _wsse__Embedded **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__Embedded(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__KeyIdentifier(struct soap *soap, struct _wsse__KeyIdentifier *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__KeyIdentifier))
		soap_serialize__wsse__KeyIdentifier(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__KeyIdentifier(struct soap *soap, const char *tag, int id, struct _wsse__KeyIdentifier *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__KeyIdentifier);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__KeyIdentifier(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__KeyIdentifier ** SOAP_FMAC4 soap_in_PointerTo_wsse__KeyIdentifier(struct soap *soap, const char *tag, struct _wsse__KeyIdentifier **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__KeyIdentifier **)soap_malloc(soap, sizeof(struct _wsse__KeyIdentifier *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__KeyIdentifier(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__KeyIdentifier **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__KeyIdentifier, sizeof(struct _wsse__KeyIdentifier), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__KeyIdentifier(struct soap *soap, struct _wsse__KeyIdentifier *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsse__KeyIdentifier);
	if (soap_out_PointerTo_wsse__KeyIdentifier(soap, tag?tag:"wsse:KeyIdentifier", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__KeyIdentifier ** SOAP_FMAC4 soap_get_PointerTo_wsse__KeyIdentifier(struct soap *soap, struct _wsse__KeyIdentifier **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__KeyIdentifier(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__Reference(struct soap *soap, struct _wsse__Reference *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__Reference))
		soap_serialize__wsse__Reference(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__Reference(struct soap *soap, const char *tag, int id, struct _wsse__Reference *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__Reference);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__Reference(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__Reference ** SOAP_FMAC4 soap_in_PointerTo_wsse__Reference(struct soap *soap, const char *tag, struct _wsse__Reference **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__Reference **)soap_malloc(soap, sizeof(struct _wsse__Reference *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__Reference(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__Reference **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__Reference, sizeof(struct _wsse__Reference), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__Reference(struct soap *soap, struct _wsse__Reference *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsse__Reference);
	if (soap_out_PointerTo_wsse__Reference(soap, tag?tag:"wsse:Reference", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Reference ** SOAP_FMAC4 soap_get_PointerTo_wsse__Reference(struct soap *soap, struct _wsse__Reference **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__Reference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__Password(struct soap *soap, struct _wsse__Password *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__Password))
		soap_serialize__wsse__Password(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__Password(struct soap *soap, const char *tag, int id, struct _wsse__Password *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__Password);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__Password(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__Password ** SOAP_FMAC4 soap_in_PointerTo_wsse__Password(struct soap *soap, const char *tag, struct _wsse__Password **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__Password **)soap_malloc(soap, sizeof(struct _wsse__Password *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__Password(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__Password **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__Password, sizeof(struct _wsse__Password), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__Password(struct soap *soap, struct _wsse__Password *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsse__Password);
	if (soap_out_PointerTo_wsse__Password(soap, tag?tag:"wsse:Password", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Password ** SOAP_FMAC4 soap_get_PointerTo_wsse__Password(struct soap *soap, struct _wsse__Password **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__Password(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, -1, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, -1, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifdef __cplusplus
}
#endif

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of bmd230C.c */
