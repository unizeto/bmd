/* soapC.c
   Generated by gSOAP 2.7.9f from soap_mail_sender.h
   Copyright(C) 2000-2006, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#include "soapH.h"

#ifdef __cplusplus
extern "C" {
#endif

SOAP_SOURCE_STAMP("@(#) soapC.c ver 2.7.9f 2011-02-28 10:31:53 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL);
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = (struct SOAP_ENV__Fault*)soap_malloc(soap, sizeof(struct SOAP_ENV__Fault));
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = (struct SOAP_ENV__Reason*)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason));
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	for (;;)
		if (!soap_getelement(soap, &t))
			if (soap->error || soap_ignore_element(soap))
				break;
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_xsd__int:
		return soap_in_xsd__int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_long:
		return soap_in_long(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_unsignedByte:
		return soap_in_unsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedInt:
		return soap_in_unsignedInt(soap, NULL, NULL, "xsd:unsignedInt");
	case SOAP_TYPE_ns__removeAdviceDispatchSetting:
		return soap_in_ns__removeAdviceDispatchSetting(soap, NULL, NULL, "ns:removeAdviceDispatchSetting");
	case SOAP_TYPE_ns__removeAdviceDispatchSettingResponse:
		return soap_in_ns__removeAdviceDispatchSettingResponse(soap, NULL, NULL, "ns:removeAdviceDispatchSettingResponse");
	case SOAP_TYPE_ns__changeAdviceDispatchSetting:
		return soap_in_ns__changeAdviceDispatchSetting(soap, NULL, NULL, "ns:changeAdviceDispatchSetting");
	case SOAP_TYPE_ns__changeAdviceDispatchSettingResponse:
		return soap_in_ns__changeAdviceDispatchSettingResponse(soap, NULL, NULL, "ns:changeAdviceDispatchSettingResponse");
	case SOAP_TYPE_ns__addAdviceDispatchSetting:
		return soap_in_ns__addAdviceDispatchSetting(soap, NULL, NULL, "ns:addAdviceDispatchSetting");
	case SOAP_TYPE_ns__addAdviceDispatchSettingResponse:
		return soap_in_ns__addAdviceDispatchSettingResponse(soap, NULL, NULL, "ns:addAdviceDispatchSettingResponse");
	case SOAP_TYPE_ns__awizoSendSMS:
		return soap_in_ns__awizoSendSMS(soap, NULL, NULL, "ns:awizoSendSMS");
	case SOAP_TYPE_ns__awizoSendSMSResponse:
		return soap_in_ns__awizoSendSMSResponse(soap, NULL, NULL, "ns:awizoSendSMSResponse");
	case SOAP_TYPE_ns__changeConfiguration:
		return soap_in_ns__changeConfiguration(soap, NULL, NULL, "ns:changeConfiguration");
	case SOAP_TYPE_ns__changeConfigurationResponse:
		return soap_in_ns__changeConfigurationResponse(soap, NULL, NULL, "ns:changeConfigurationResponse");
	case SOAP_TYPE_ns__stopSendingProcess:
		return soap_in_ns__stopSendingProcess(soap, NULL, NULL, "ns:stopSendingProcess");
	case SOAP_TYPE_ns__stopSendingProcessResponse:
		return soap_in_ns__stopSendingProcessResponse(soap, NULL, NULL, "ns:stopSendingProcessResponse");
	case SOAP_TYPE_ns__countMailFromQueue:
		return soap_in_ns__countMailFromQueue(soap, NULL, NULL, "ns:countMailFromQueue");
	case SOAP_TYPE_ns__countMailFromQueueResponse:
		return soap_in_ns__countMailFromQueueResponse(soap, NULL, NULL, "ns:countMailFromQueueResponse");
	case SOAP_TYPE_ns__clearMailQueue:
		return soap_in_ns__clearMailQueue(soap, NULL, NULL, "ns:clearMailQueue");
	case SOAP_TYPE_ns__clearMailQueueResponse:
		return soap_in_ns__clearMailQueueResponse(soap, NULL, NULL, "ns:clearMailQueueResponse");
	case SOAP_TYPE_ns__clearCache:
		return soap_in_ns__clearCache(soap, NULL, NULL, "ns:clearCache");
	case SOAP_TYPE_ns__clearCacheResponse:
		return soap_in_ns__clearCacheResponse(soap, NULL, NULL, "ns:clearCacheResponse");
	case SOAP_TYPE_ns__awizoSetFromMsgQueueSend:
		return soap_in_ns__awizoSetFromMsgQueueSend(soap, NULL, NULL, "ns:awizoSetFromMsgQueueSend");
	case SOAP_TYPE_ns__awizoSetFromMsgQueueSendResponse:
		return soap_in_ns__awizoSetFromMsgQueueSendResponse(soap, NULL, NULL, "ns:awizoSetFromMsgQueueSendResponse");
	case SOAP_TYPE_ns__awizoSend:
		return soap_in_ns__awizoSend(soap, NULL, NULL, "ns:awizoSend");
	case SOAP_TYPE_ns__awizoSendResponse:
		return soap_in_ns__awizoSendResponse(soap, NULL, NULL, "ns:awizoSendResponse");
	case SOAP_TYPE_ns__awizoChangeSenderInfo:
		return soap_in_ns__awizoChangeSenderInfo(soap, NULL, NULL, "ns:awizoChangeSenderInfo");
	case SOAP_TYPE_ns__awizoChangeSenderInfoResponse:
		return soap_in_ns__awizoChangeSenderInfoResponse(soap, NULL, NULL, "ns:awizoChangeSenderInfoResponse");
	case SOAP_TYPE_ns__awizoGetSenderInfo:
		return soap_in_ns__awizoGetSenderInfo(soap, NULL, NULL, "ns:awizoGetSenderInfo");
	case SOAP_TYPE_ns__awizoGetSenderInfoResponse:
		return soap_in_ns__awizoGetSenderInfoResponse(soap, NULL, NULL, "ns:awizoGetSenderInfoResponse");
	case SOAP_TYPE_ns__awizoDeleteSender:
		return soap_in_ns__awizoDeleteSender(soap, NULL, NULL, "ns:awizoDeleteSender");
	case SOAP_TYPE_ns__awizoDeleteSenderResponse:
		return soap_in_ns__awizoDeleteSenderResponse(soap, NULL, NULL, "ns:awizoDeleteSenderResponse");
	case SOAP_TYPE_ns__awizoInsertSender:
		return soap_in_ns__awizoInsertSender(soap, NULL, NULL, "ns:awizoInsertSender");
	case SOAP_TYPE_ns__awizoInsertSenderResponse:
		return soap_in_ns__awizoInsertSenderResponse(soap, NULL, NULL, "ns:awizoInsertSenderResponse");
	case SOAP_TYPE_ns__awizoChangeAttachmentInfo:
		return soap_in_ns__awizoChangeAttachmentInfo(soap, NULL, NULL, "ns:awizoChangeAttachmentInfo");
	case SOAP_TYPE_ns__awizoChangeAttachmentInfoResponse:
		return soap_in_ns__awizoChangeAttachmentInfoResponse(soap, NULL, NULL, "ns:awizoChangeAttachmentInfoResponse");
	case SOAP_TYPE_ns__awizoDownloadAttachment:
		return soap_in_ns__awizoDownloadAttachment(soap, NULL, NULL, "ns:awizoDownloadAttachment");
	case SOAP_TYPE_ns__awizoDownloadAttachmentResponse:
		return soap_in_ns__awizoDownloadAttachmentResponse(soap, NULL, NULL, "ns:awizoDownloadAttachmentResponse");
	case SOAP_TYPE_ns__awizoDeleteAttachment:
		return soap_in_ns__awizoDeleteAttachment(soap, NULL, NULL, "ns:awizoDeleteAttachment");
	case SOAP_TYPE_ns__awizoDeleteAttachmentResponse:
		return soap_in_ns__awizoDeleteAttachmentResponse(soap, NULL, NULL, "ns:awizoDeleteAttachmentResponse");
	case SOAP_TYPE_ns__awizoInsertAttachment:
		return soap_in_ns__awizoInsertAttachment(soap, NULL, NULL, "ns:awizoInsertAttachment");
	case SOAP_TYPE_ns__awizoInsertAttachmentResponse:
		return soap_in_ns__awizoInsertAttachmentResponse(soap, NULL, NULL, "ns:awizoInsertAttachmentResponse");
	case SOAP_TYPE_ns__awizoChangeTemplateInfo:
		return soap_in_ns__awizoChangeTemplateInfo(soap, NULL, NULL, "ns:awizoChangeTemplateInfo");
	case SOAP_TYPE_ns__awizoChangeTemplateInfoResponse:
		return soap_in_ns__awizoChangeTemplateInfoResponse(soap, NULL, NULL, "ns:awizoChangeTemplateInfoResponse");
	case SOAP_TYPE_ns__awizoDownloadTemplate:
		return soap_in_ns__awizoDownloadTemplate(soap, NULL, NULL, "ns:awizoDownloadTemplate");
	case SOAP_TYPE_ns__awizoDownloadTemplateResponse:
		return soap_in_ns__awizoDownloadTemplateResponse(soap, NULL, NULL, "ns:awizoDownloadTemplateResponse");
	case SOAP_TYPE_ns__awizoDeleteTemplate:
		return soap_in_ns__awizoDeleteTemplate(soap, NULL, NULL, "ns:awizoDeleteTemplate");
	case SOAP_TYPE_ns__awizoDeleteTemplateResponse:
		return soap_in_ns__awizoDeleteTemplateResponse(soap, NULL, NULL, "ns:awizoDeleteTemplateResponse");
	case SOAP_TYPE_ns__awizoInsertTemplate:
		return soap_in_ns__awizoInsertTemplate(soap, NULL, NULL, "ns:awizoInsertTemplate");
	case SOAP_TYPE_ns__awizoInsertTemplateResponse:
		return soap_in_ns__awizoInsertTemplateResponse(soap, NULL, NULL, "ns:awizoInsertTemplateResponse");
	case SOAP_TYPE_ns__awizoGetSendersList:
		return soap_in_ns__awizoGetSendersList(soap, NULL, NULL, "ns:awizoGetSendersList");
	case SOAP_TYPE_ns__awizoGetSendersListResponse:
		return soap_in_ns__awizoGetSendersListResponse(soap, NULL, NULL, "ns:awizoGetSendersListResponse");
	case SOAP_TYPE_ns__senderComplexList:
		return soap_in_ns__senderComplexList(soap, NULL, NULL, "ns:senderComplexList");
	case SOAP_TYPE_ns__attachmentComplex:
		return soap_in_ns__attachmentComplex(soap, NULL, NULL, "ns:attachmentComplex");
	case SOAP_TYPE_ns__templateComplex:
		return soap_in_ns__templateComplex(soap, NULL, NULL, "ns:templateComplex");
	case SOAP_TYPE_ns__senderComplex:
		return soap_in_ns__senderComplex(soap, NULL, NULL, "ns:senderComplex");
	case SOAP_TYPE_ns__dateTimeComplexList:
		return soap_in_ns__dateTimeComplexList(soap, NULL, NULL, "ns:dateTimeComplexList");
	case SOAP_TYPE_ns_dateTime:
		return soap_in_ns_dateTime(soap, NULL, NULL, "ns-dateTime");
	case SOAP_TYPE_ns__awizoMessage:
		return soap_in_ns__awizoMessage(soap, NULL, NULL, "ns:awizoMessage");
	case SOAP_TYPE_ns__awizoConfig:
		return soap_in_ns__awizoConfig(soap, NULL, NULL, "ns:awizoConfig");
	case SOAP_TYPE_xsd__base64Binary:
		return soap_in_xsd__base64Binary(soap, NULL, NULL, "xsd:base64Binary");
	case SOAP_TYPE_PointerTons__dateTimeComplexList:
		return soap_in_PointerTons__dateTimeComplexList(soap, NULL, NULL, "ns:dateTimeComplexList");
	case SOAP_TYPE_PointerTons__awizoConfig:
		return soap_in_PointerTons__awizoConfig(soap, NULL, NULL, "ns:awizoConfig");
	case SOAP_TYPE_PointerTostring:
		return soap_in_PointerTostring(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerTons__awizoMessage:
		return soap_in_PointerTons__awizoMessage(soap, NULL, NULL, "ns:awizoMessage");
	case SOAP_TYPE_PointerToPointerTons__senderComplex:
		return soap_in_PointerToPointerTons__senderComplex(soap, NULL, NULL, "ns:senderComplex");
	case SOAP_TYPE_PointerToPointerTons__attachmentComplex:
		return soap_in_PointerToPointerTons__attachmentComplex(soap, NULL, NULL, "ns:attachmentComplex");
	case SOAP_TYPE_PointerTons__attachmentComplex:
		return soap_in_PointerTons__attachmentComplex(soap, NULL, NULL, "ns:attachmentComplex");
	case SOAP_TYPE_PointerToPointerTons__templateComplex:
		return soap_in_PointerToPointerTons__templateComplex(soap, NULL, NULL, "ns:templateComplex");
	case SOAP_TYPE_PointerTolong:
		return soap_in_PointerTolong(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_PointerTons__templateComplex:
		return soap_in_PointerTons__templateComplex(soap, NULL, NULL, "ns:templateComplex");
	case SOAP_TYPE_PointerToPointerTons__senderComplexList:
		return soap_in_PointerToPointerTons__senderComplexList(soap, NULL, NULL, "ns:senderComplexList");
	case SOAP_TYPE_PointerTons__senderComplexList:
		return soap_in_PointerTons__senderComplexList(soap, NULL, NULL, "ns:senderComplexList");
	case SOAP_TYPE_PointerTons__senderComplex:
		return soap_in_PointerTons__senderComplex(soap, NULL, NULL, "ns:senderComplex");
	case SOAP_TYPE_PointerTons_dateTime:
		return soap_in_PointerTons_dateTime(soap, NULL, NULL, "ns-dateTime");
	case SOAP_TYPE_PointerToxsd__base64Binary:
		return soap_in_PointerToxsd__base64Binary(soap, NULL, NULL, "xsd:base64Binary");
	case SOAP_TYPE_PointerTounsignedByte:
		return soap_in_PointerTounsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
	case SOAP_TYPE_xsd__string:
	{	char **s;
		s = soap_in_xsd__string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_xsd__int;
			return soap_in_xsd__int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_long;
			return soap_in_long(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedByte"))
		{	*type = SOAP_TYPE_unsignedByte;
			return soap_in_unsignedByte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedInt"))
		{	*type = SOAP_TYPE_unsignedInt;
			return soap_in_unsignedInt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:removeAdviceDispatchSetting"))
		{	*type = SOAP_TYPE_ns__removeAdviceDispatchSetting;
			return soap_in_ns__removeAdviceDispatchSetting(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:removeAdviceDispatchSettingResponse"))
		{	*type = SOAP_TYPE_ns__removeAdviceDispatchSettingResponse;
			return soap_in_ns__removeAdviceDispatchSettingResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:changeAdviceDispatchSetting"))
		{	*type = SOAP_TYPE_ns__changeAdviceDispatchSetting;
			return soap_in_ns__changeAdviceDispatchSetting(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:changeAdviceDispatchSettingResponse"))
		{	*type = SOAP_TYPE_ns__changeAdviceDispatchSettingResponse;
			return soap_in_ns__changeAdviceDispatchSettingResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:addAdviceDispatchSetting"))
		{	*type = SOAP_TYPE_ns__addAdviceDispatchSetting;
			return soap_in_ns__addAdviceDispatchSetting(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:addAdviceDispatchSettingResponse"))
		{	*type = SOAP_TYPE_ns__addAdviceDispatchSettingResponse;
			return soap_in_ns__addAdviceDispatchSettingResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:awizoSendSMS"))
		{	*type = SOAP_TYPE_ns__awizoSendSMS;
			return soap_in_ns__awizoSendSMS(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:awizoSendSMSResponse"))
		{	*type = SOAP_TYPE_ns__awizoSendSMSResponse;
			return soap_in_ns__awizoSendSMSResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:changeConfiguration"))
		{	*type = SOAP_TYPE_ns__changeConfiguration;
			return soap_in_ns__changeConfiguration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:changeConfigurationResponse"))
		{	*type = SOAP_TYPE_ns__changeConfigurationResponse;
			return soap_in_ns__changeConfigurationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:stopSendingProcess"))
		{	*type = SOAP_TYPE_ns__stopSendingProcess;
			return soap_in_ns__stopSendingProcess(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:stopSendingProcessResponse"))
		{	*type = SOAP_TYPE_ns__stopSendingProcessResponse;
			return soap_in_ns__stopSendingProcessResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:countMailFromQueue"))
		{	*type = SOAP_TYPE_ns__countMailFromQueue;
			return soap_in_ns__countMailFromQueue(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:countMailFromQueueResponse"))
		{	*type = SOAP_TYPE_ns__countMailFromQueueResponse;
			return soap_in_ns__countMailFromQueueResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:clearMailQueue"))
		{	*type = SOAP_TYPE_ns__clearMailQueue;
			return soap_in_ns__clearMailQueue(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:clearMailQueueResponse"))
		{	*type = SOAP_TYPE_ns__clearMailQueueResponse;
			return soap_in_ns__clearMailQueueResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:clearCache"))
		{	*type = SOAP_TYPE_ns__clearCache;
			return soap_in_ns__clearCache(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:clearCacheResponse"))
		{	*type = SOAP_TYPE_ns__clearCacheResponse;
			return soap_in_ns__clearCacheResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:awizoSetFromMsgQueueSend"))
		{	*type = SOAP_TYPE_ns__awizoSetFromMsgQueueSend;
			return soap_in_ns__awizoSetFromMsgQueueSend(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:awizoSetFromMsgQueueSendResponse"))
		{	*type = SOAP_TYPE_ns__awizoSetFromMsgQueueSendResponse;
			return soap_in_ns__awizoSetFromMsgQueueSendResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:awizoSend"))
		{	*type = SOAP_TYPE_ns__awizoSend;
			return soap_in_ns__awizoSend(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:awizoSendResponse"))
		{	*type = SOAP_TYPE_ns__awizoSendResponse;
			return soap_in_ns__awizoSendResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:awizoChangeSenderInfo"))
		{	*type = SOAP_TYPE_ns__awizoChangeSenderInfo;
			return soap_in_ns__awizoChangeSenderInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:awizoChangeSenderInfoResponse"))
		{	*type = SOAP_TYPE_ns__awizoChangeSenderInfoResponse;
			return soap_in_ns__awizoChangeSenderInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:awizoGetSenderInfo"))
		{	*type = SOAP_TYPE_ns__awizoGetSenderInfo;
			return soap_in_ns__awizoGetSenderInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:awizoGetSenderInfoResponse"))
		{	*type = SOAP_TYPE_ns__awizoGetSenderInfoResponse;
			return soap_in_ns__awizoGetSenderInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:awizoDeleteSender"))
		{	*type = SOAP_TYPE_ns__awizoDeleteSender;
			return soap_in_ns__awizoDeleteSender(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:awizoDeleteSenderResponse"))
		{	*type = SOAP_TYPE_ns__awizoDeleteSenderResponse;
			return soap_in_ns__awizoDeleteSenderResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:awizoInsertSender"))
		{	*type = SOAP_TYPE_ns__awizoInsertSender;
			return soap_in_ns__awizoInsertSender(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:awizoInsertSenderResponse"))
		{	*type = SOAP_TYPE_ns__awizoInsertSenderResponse;
			return soap_in_ns__awizoInsertSenderResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:awizoChangeAttachmentInfo"))
		{	*type = SOAP_TYPE_ns__awizoChangeAttachmentInfo;
			return soap_in_ns__awizoChangeAttachmentInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:awizoChangeAttachmentInfoResponse"))
		{	*type = SOAP_TYPE_ns__awizoChangeAttachmentInfoResponse;
			return soap_in_ns__awizoChangeAttachmentInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:awizoDownloadAttachment"))
		{	*type = SOAP_TYPE_ns__awizoDownloadAttachment;
			return soap_in_ns__awizoDownloadAttachment(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:awizoDownloadAttachmentResponse"))
		{	*type = SOAP_TYPE_ns__awizoDownloadAttachmentResponse;
			return soap_in_ns__awizoDownloadAttachmentResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:awizoDeleteAttachment"))
		{	*type = SOAP_TYPE_ns__awizoDeleteAttachment;
			return soap_in_ns__awizoDeleteAttachment(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:awizoDeleteAttachmentResponse"))
		{	*type = SOAP_TYPE_ns__awizoDeleteAttachmentResponse;
			return soap_in_ns__awizoDeleteAttachmentResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:awizoInsertAttachment"))
		{	*type = SOAP_TYPE_ns__awizoInsertAttachment;
			return soap_in_ns__awizoInsertAttachment(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:awizoInsertAttachmentResponse"))
		{	*type = SOAP_TYPE_ns__awizoInsertAttachmentResponse;
			return soap_in_ns__awizoInsertAttachmentResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:awizoChangeTemplateInfo"))
		{	*type = SOAP_TYPE_ns__awizoChangeTemplateInfo;
			return soap_in_ns__awizoChangeTemplateInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:awizoChangeTemplateInfoResponse"))
		{	*type = SOAP_TYPE_ns__awizoChangeTemplateInfoResponse;
			return soap_in_ns__awizoChangeTemplateInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:awizoDownloadTemplate"))
		{	*type = SOAP_TYPE_ns__awizoDownloadTemplate;
			return soap_in_ns__awizoDownloadTemplate(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:awizoDownloadTemplateResponse"))
		{	*type = SOAP_TYPE_ns__awizoDownloadTemplateResponse;
			return soap_in_ns__awizoDownloadTemplateResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:awizoDeleteTemplate"))
		{	*type = SOAP_TYPE_ns__awizoDeleteTemplate;
			return soap_in_ns__awizoDeleteTemplate(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:awizoDeleteTemplateResponse"))
		{	*type = SOAP_TYPE_ns__awizoDeleteTemplateResponse;
			return soap_in_ns__awizoDeleteTemplateResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:awizoInsertTemplate"))
		{	*type = SOAP_TYPE_ns__awizoInsertTemplate;
			return soap_in_ns__awizoInsertTemplate(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:awizoInsertTemplateResponse"))
		{	*type = SOAP_TYPE_ns__awizoInsertTemplateResponse;
			return soap_in_ns__awizoInsertTemplateResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:awizoGetSendersList"))
		{	*type = SOAP_TYPE_ns__awizoGetSendersList;
			return soap_in_ns__awizoGetSendersList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:awizoGetSendersListResponse"))
		{	*type = SOAP_TYPE_ns__awizoGetSendersListResponse;
			return soap_in_ns__awizoGetSendersListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:senderComplexList"))
		{	*type = SOAP_TYPE_ns__senderComplexList;
			return soap_in_ns__senderComplexList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:attachmentComplex"))
		{	*type = SOAP_TYPE_ns__attachmentComplex;
			return soap_in_ns__attachmentComplex(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:templateComplex"))
		{	*type = SOAP_TYPE_ns__templateComplex;
			return soap_in_ns__templateComplex(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:senderComplex"))
		{	*type = SOAP_TYPE_ns__senderComplex;
			return soap_in_ns__senderComplex(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:dateTimeComplexList"))
		{	*type = SOAP_TYPE_ns__dateTimeComplexList;
			return soap_in_ns__dateTimeComplexList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns-dateTime"))
		{	*type = SOAP_TYPE_ns_dateTime;
			return soap_in_ns_dateTime(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:awizoMessage"))
		{	*type = SOAP_TYPE_ns__awizoMessage;
			return soap_in_ns__awizoMessage(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns:awizoConfig"))
		{	*type = SOAP_TYPE_ns__awizoConfig;
			return soap_in_ns__awizoConfig(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:base64Binary"))
		{	*type = SOAP_TYPE_xsd__base64Binary;
			return soap_in_xsd__base64Binary(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_xsd__string;
			s = soap_in_xsd__string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unknown element '%s' (level=%u, %d)\n", soap->tag, soap->level, soap->body));
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_xsd__int:
		return soap_out_xsd__int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_long:
		return soap_out_long(soap, tag, id, (const long *)ptr, "xsd:long");
	case SOAP_TYPE_unsignedByte:
		return soap_out_unsignedByte(soap, tag, id, (const unsigned char *)ptr, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedInt:
		return soap_out_unsignedInt(soap, tag, id, (const unsigned int *)ptr, "xsd:unsignedInt");
	case SOAP_TYPE_ns__removeAdviceDispatchSetting:
		return soap_out_ns__removeAdviceDispatchSetting(soap, tag, id, (const struct ns__removeAdviceDispatchSetting *)ptr, "ns:removeAdviceDispatchSetting");
	case SOAP_TYPE_ns__removeAdviceDispatchSettingResponse:
		return soap_out_ns__removeAdviceDispatchSettingResponse(soap, tag, id, (const struct ns__removeAdviceDispatchSettingResponse *)ptr, "ns:removeAdviceDispatchSettingResponse");
	case SOAP_TYPE_ns__changeAdviceDispatchSetting:
		return soap_out_ns__changeAdviceDispatchSetting(soap, tag, id, (const struct ns__changeAdviceDispatchSetting *)ptr, "ns:changeAdviceDispatchSetting");
	case SOAP_TYPE_ns__changeAdviceDispatchSettingResponse:
		return soap_out_ns__changeAdviceDispatchSettingResponse(soap, tag, id, (const struct ns__changeAdviceDispatchSettingResponse *)ptr, "ns:changeAdviceDispatchSettingResponse");
	case SOAP_TYPE_ns__addAdviceDispatchSetting:
		return soap_out_ns__addAdviceDispatchSetting(soap, tag, id, (const struct ns__addAdviceDispatchSetting *)ptr, "ns:addAdviceDispatchSetting");
	case SOAP_TYPE_ns__addAdviceDispatchSettingResponse:
		return soap_out_ns__addAdviceDispatchSettingResponse(soap, tag, id, (const struct ns__addAdviceDispatchSettingResponse *)ptr, "ns:addAdviceDispatchSettingResponse");
	case SOAP_TYPE_ns__awizoSendSMS:
		return soap_out_ns__awizoSendSMS(soap, tag, id, (const struct ns__awizoSendSMS *)ptr, "ns:awizoSendSMS");
	case SOAP_TYPE_ns__awizoSendSMSResponse:
		return soap_out_ns__awizoSendSMSResponse(soap, tag, id, (const struct ns__awizoSendSMSResponse *)ptr, "ns:awizoSendSMSResponse");
	case SOAP_TYPE_ns__changeConfiguration:
		return soap_out_ns__changeConfiguration(soap, tag, id, (const struct ns__changeConfiguration *)ptr, "ns:changeConfiguration");
	case SOAP_TYPE_ns__changeConfigurationResponse:
		return soap_out_ns__changeConfigurationResponse(soap, tag, id, (const struct ns__changeConfigurationResponse *)ptr, "ns:changeConfigurationResponse");
	case SOAP_TYPE_ns__stopSendingProcess:
		return soap_out_ns__stopSendingProcess(soap, tag, id, (const struct ns__stopSendingProcess *)ptr, "ns:stopSendingProcess");
	case SOAP_TYPE_ns__stopSendingProcessResponse:
		return soap_out_ns__stopSendingProcessResponse(soap, tag, id, (const struct ns__stopSendingProcessResponse *)ptr, "ns:stopSendingProcessResponse");
	case SOAP_TYPE_ns__countMailFromQueue:
		return soap_out_ns__countMailFromQueue(soap, tag, id, (const struct ns__countMailFromQueue *)ptr, "ns:countMailFromQueue");
	case SOAP_TYPE_ns__countMailFromQueueResponse:
		return soap_out_ns__countMailFromQueueResponse(soap, tag, id, (const struct ns__countMailFromQueueResponse *)ptr, "ns:countMailFromQueueResponse");
	case SOAP_TYPE_ns__clearMailQueue:
		return soap_out_ns__clearMailQueue(soap, tag, id, (const struct ns__clearMailQueue *)ptr, "ns:clearMailQueue");
	case SOAP_TYPE_ns__clearMailQueueResponse:
		return soap_out_ns__clearMailQueueResponse(soap, tag, id, (const struct ns__clearMailQueueResponse *)ptr, "ns:clearMailQueueResponse");
	case SOAP_TYPE_ns__clearCache:
		return soap_out_ns__clearCache(soap, tag, id, (const struct ns__clearCache *)ptr, "ns:clearCache");
	case SOAP_TYPE_ns__clearCacheResponse:
		return soap_out_ns__clearCacheResponse(soap, tag, id, (const struct ns__clearCacheResponse *)ptr, "ns:clearCacheResponse");
	case SOAP_TYPE_ns__awizoSetFromMsgQueueSend:
		return soap_out_ns__awizoSetFromMsgQueueSend(soap, tag, id, (const struct ns__awizoSetFromMsgQueueSend *)ptr, "ns:awizoSetFromMsgQueueSend");
	case SOAP_TYPE_ns__awizoSetFromMsgQueueSendResponse:
		return soap_out_ns__awizoSetFromMsgQueueSendResponse(soap, tag, id, (const struct ns__awizoSetFromMsgQueueSendResponse *)ptr, "ns:awizoSetFromMsgQueueSendResponse");
	case SOAP_TYPE_ns__awizoSend:
		return soap_out_ns__awizoSend(soap, tag, id, (const struct ns__awizoSend *)ptr, "ns:awizoSend");
	case SOAP_TYPE_ns__awizoSendResponse:
		return soap_out_ns__awizoSendResponse(soap, tag, id, (const struct ns__awizoSendResponse *)ptr, "ns:awizoSendResponse");
	case SOAP_TYPE_ns__awizoChangeSenderInfo:
		return soap_out_ns__awizoChangeSenderInfo(soap, tag, id, (const struct ns__awizoChangeSenderInfo *)ptr, "ns:awizoChangeSenderInfo");
	case SOAP_TYPE_ns__awizoChangeSenderInfoResponse:
		return soap_out_ns__awizoChangeSenderInfoResponse(soap, tag, id, (const struct ns__awizoChangeSenderInfoResponse *)ptr, "ns:awizoChangeSenderInfoResponse");
	case SOAP_TYPE_ns__awizoGetSenderInfo:
		return soap_out_ns__awizoGetSenderInfo(soap, tag, id, (const struct ns__awizoGetSenderInfo *)ptr, "ns:awizoGetSenderInfo");
	case SOAP_TYPE_ns__awizoGetSenderInfoResponse:
		return soap_out_ns__awizoGetSenderInfoResponse(soap, tag, id, (const struct ns__awizoGetSenderInfoResponse *)ptr, "ns:awizoGetSenderInfoResponse");
	case SOAP_TYPE_ns__awizoDeleteSender:
		return soap_out_ns__awizoDeleteSender(soap, tag, id, (const struct ns__awizoDeleteSender *)ptr, "ns:awizoDeleteSender");
	case SOAP_TYPE_ns__awizoDeleteSenderResponse:
		return soap_out_ns__awizoDeleteSenderResponse(soap, tag, id, (const struct ns__awizoDeleteSenderResponse *)ptr, "ns:awizoDeleteSenderResponse");
	case SOAP_TYPE_ns__awizoInsertSender:
		return soap_out_ns__awizoInsertSender(soap, tag, id, (const struct ns__awizoInsertSender *)ptr, "ns:awizoInsertSender");
	case SOAP_TYPE_ns__awizoInsertSenderResponse:
		return soap_out_ns__awizoInsertSenderResponse(soap, tag, id, (const struct ns__awizoInsertSenderResponse *)ptr, "ns:awizoInsertSenderResponse");
	case SOAP_TYPE_ns__awizoChangeAttachmentInfo:
		return soap_out_ns__awizoChangeAttachmentInfo(soap, tag, id, (const struct ns__awizoChangeAttachmentInfo *)ptr, "ns:awizoChangeAttachmentInfo");
	case SOAP_TYPE_ns__awizoChangeAttachmentInfoResponse:
		return soap_out_ns__awizoChangeAttachmentInfoResponse(soap, tag, id, (const struct ns__awizoChangeAttachmentInfoResponse *)ptr, "ns:awizoChangeAttachmentInfoResponse");
	case SOAP_TYPE_ns__awizoDownloadAttachment:
		return soap_out_ns__awizoDownloadAttachment(soap, tag, id, (const struct ns__awizoDownloadAttachment *)ptr, "ns:awizoDownloadAttachment");
	case SOAP_TYPE_ns__awizoDownloadAttachmentResponse:
		return soap_out_ns__awizoDownloadAttachmentResponse(soap, tag, id, (const struct ns__awizoDownloadAttachmentResponse *)ptr, "ns:awizoDownloadAttachmentResponse");
	case SOAP_TYPE_ns__awizoDeleteAttachment:
		return soap_out_ns__awizoDeleteAttachment(soap, tag, id, (const struct ns__awizoDeleteAttachment *)ptr, "ns:awizoDeleteAttachment");
	case SOAP_TYPE_ns__awizoDeleteAttachmentResponse:
		return soap_out_ns__awizoDeleteAttachmentResponse(soap, tag, id, (const struct ns__awizoDeleteAttachmentResponse *)ptr, "ns:awizoDeleteAttachmentResponse");
	case SOAP_TYPE_ns__awizoInsertAttachment:
		return soap_out_ns__awizoInsertAttachment(soap, tag, id, (const struct ns__awizoInsertAttachment *)ptr, "ns:awizoInsertAttachment");
	case SOAP_TYPE_ns__awizoInsertAttachmentResponse:
		return soap_out_ns__awizoInsertAttachmentResponse(soap, tag, id, (const struct ns__awizoInsertAttachmentResponse *)ptr, "ns:awizoInsertAttachmentResponse");
	case SOAP_TYPE_ns__awizoChangeTemplateInfo:
		return soap_out_ns__awizoChangeTemplateInfo(soap, tag, id, (const struct ns__awizoChangeTemplateInfo *)ptr, "ns:awizoChangeTemplateInfo");
	case SOAP_TYPE_ns__awizoChangeTemplateInfoResponse:
		return soap_out_ns__awizoChangeTemplateInfoResponse(soap, tag, id, (const struct ns__awizoChangeTemplateInfoResponse *)ptr, "ns:awizoChangeTemplateInfoResponse");
	case SOAP_TYPE_ns__awizoDownloadTemplate:
		return soap_out_ns__awizoDownloadTemplate(soap, tag, id, (const struct ns__awizoDownloadTemplate *)ptr, "ns:awizoDownloadTemplate");
	case SOAP_TYPE_ns__awizoDownloadTemplateResponse:
		return soap_out_ns__awizoDownloadTemplateResponse(soap, tag, id, (const struct ns__awizoDownloadTemplateResponse *)ptr, "ns:awizoDownloadTemplateResponse");
	case SOAP_TYPE_ns__awizoDeleteTemplate:
		return soap_out_ns__awizoDeleteTemplate(soap, tag, id, (const struct ns__awizoDeleteTemplate *)ptr, "ns:awizoDeleteTemplate");
	case SOAP_TYPE_ns__awizoDeleteTemplateResponse:
		return soap_out_ns__awizoDeleteTemplateResponse(soap, tag, id, (const struct ns__awizoDeleteTemplateResponse *)ptr, "ns:awizoDeleteTemplateResponse");
	case SOAP_TYPE_ns__awizoInsertTemplate:
		return soap_out_ns__awizoInsertTemplate(soap, tag, id, (const struct ns__awizoInsertTemplate *)ptr, "ns:awizoInsertTemplate");
	case SOAP_TYPE_ns__awizoInsertTemplateResponse:
		return soap_out_ns__awizoInsertTemplateResponse(soap, tag, id, (const struct ns__awizoInsertTemplateResponse *)ptr, "ns:awizoInsertTemplateResponse");
	case SOAP_TYPE_ns__awizoGetSendersList:
		return soap_out_ns__awizoGetSendersList(soap, tag, id, (const struct ns__awizoGetSendersList *)ptr, "ns:awizoGetSendersList");
	case SOAP_TYPE_ns__awizoGetSendersListResponse:
		return soap_out_ns__awizoGetSendersListResponse(soap, tag, id, (const struct ns__awizoGetSendersListResponse *)ptr, "ns:awizoGetSendersListResponse");
	case SOAP_TYPE_ns__senderComplexList:
		return soap_out_ns__senderComplexList(soap, tag, id, (const struct ns__senderComplexList *)ptr, "ns:senderComplexList");
	case SOAP_TYPE_ns__attachmentComplex:
		return soap_out_ns__attachmentComplex(soap, tag, id, (const struct ns__attachmentComplex *)ptr, "ns:attachmentComplex");
	case SOAP_TYPE_ns__templateComplex:
		return soap_out_ns__templateComplex(soap, tag, id, (const struct ns__templateComplex *)ptr, "ns:templateComplex");
	case SOAP_TYPE_ns__senderComplex:
		return soap_out_ns__senderComplex(soap, tag, id, (const struct ns__senderComplex *)ptr, "ns:senderComplex");
	case SOAP_TYPE_ns__dateTimeComplexList:
		return soap_out_ns__dateTimeComplexList(soap, tag, id, (const struct ns__dateTimeComplexList *)ptr, "ns:dateTimeComplexList");
	case SOAP_TYPE_ns_dateTime:
		return soap_out_ns_dateTime(soap, tag, id, (const struct ns_dateTime *)ptr, "ns-dateTime");
	case SOAP_TYPE_ns__awizoMessage:
		return soap_out_ns__awizoMessage(soap, tag, id, (const struct ns__awizoMessage *)ptr, "ns:awizoMessage");
	case SOAP_TYPE_ns__awizoConfig:
		return soap_out_ns__awizoConfig(soap, tag, id, (const struct ns__awizoConfig *)ptr, "ns:awizoConfig");
	case SOAP_TYPE_xsd__base64Binary:
		return soap_out_xsd__base64Binary(soap, tag, id, (const struct xsd__base64Binary *)ptr, "xsd:base64Binary");
	case SOAP_TYPE_PointerTons__dateTimeComplexList:
		return soap_out_PointerTons__dateTimeComplexList(soap, tag, id, (struct ns__dateTimeComplexList *const*)ptr, "ns:dateTimeComplexList");
	case SOAP_TYPE_PointerTons__awizoConfig:
		return soap_out_PointerTons__awizoConfig(soap, tag, id, (struct ns__awizoConfig *const*)ptr, "ns:awizoConfig");
	case SOAP_TYPE_PointerTostring:
		return soap_out_PointerTostring(soap, tag, id, (char **const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerTons__awizoMessage:
		return soap_out_PointerTons__awizoMessage(soap, tag, id, (struct ns__awizoMessage *const*)ptr, "ns:awizoMessage");
	case SOAP_TYPE_PointerToPointerTons__senderComplex:
		return soap_out_PointerToPointerTons__senderComplex(soap, tag, id, (struct ns__senderComplex **const*)ptr, "ns:senderComplex");
	case SOAP_TYPE_PointerToPointerTons__attachmentComplex:
		return soap_out_PointerToPointerTons__attachmentComplex(soap, tag, id, (struct ns__attachmentComplex **const*)ptr, "ns:attachmentComplex");
	case SOAP_TYPE_PointerTons__attachmentComplex:
		return soap_out_PointerTons__attachmentComplex(soap, tag, id, (struct ns__attachmentComplex *const*)ptr, "ns:attachmentComplex");
	case SOAP_TYPE_PointerToPointerTons__templateComplex:
		return soap_out_PointerToPointerTons__templateComplex(soap, tag, id, (struct ns__templateComplex **const*)ptr, "ns:templateComplex");
	case SOAP_TYPE_PointerTolong:
		return soap_out_PointerTolong(soap, tag, id, (long *const*)ptr, "xsd:long");
	case SOAP_TYPE_PointerTons__templateComplex:
		return soap_out_PointerTons__templateComplex(soap, tag, id, (struct ns__templateComplex *const*)ptr, "ns:templateComplex");
	case SOAP_TYPE_PointerToPointerTons__senderComplexList:
		return soap_out_PointerToPointerTons__senderComplexList(soap, tag, id, (struct ns__senderComplexList **const*)ptr, "ns:senderComplexList");
	case SOAP_TYPE_PointerTons__senderComplexList:
		return soap_out_PointerTons__senderComplexList(soap, tag, id, (struct ns__senderComplexList *const*)ptr, "ns:senderComplexList");
	case SOAP_TYPE_PointerTons__senderComplex:
		return soap_out_PointerTons__senderComplex(soap, tag, id, (struct ns__senderComplex *const*)ptr, "ns:senderComplex");
	case SOAP_TYPE_PointerTons_dateTime:
		return soap_out_PointerTons_dateTime(soap, tag, id, (struct ns_dateTime *const*)ptr, "ns-dateTime");
	case SOAP_TYPE_PointerToxsd__base64Binary:
		return soap_out_PointerToxsd__base64Binary(soap, tag, id, (struct xsd__base64Binary *const*)ptr, "xsd:base64Binary");
	case SOAP_TYPE_PointerTounsignedByte:
		return soap_out_PointerTounsignedByte(soap, tag, id, (unsigned char *const*)ptr, "xsd:unsignedByte");
	case SOAP_TYPE_xsd__string:
		return soap_out_string(soap, tag, id, (char**)&ptr, "xsd:string");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, "xsd:QName", id, (char**)&ptr, NULL);
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char**)&ptr, "xsd:string");
	}
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_ns__removeAdviceDispatchSetting:
		soap_serialize_ns__removeAdviceDispatchSetting(soap, (const struct ns__removeAdviceDispatchSetting *)ptr);
		break;
	case SOAP_TYPE_ns__removeAdviceDispatchSettingResponse:
		soap_serialize_ns__removeAdviceDispatchSettingResponse(soap, (const struct ns__removeAdviceDispatchSettingResponse *)ptr);
		break;
	case SOAP_TYPE_ns__changeAdviceDispatchSetting:
		soap_serialize_ns__changeAdviceDispatchSetting(soap, (const struct ns__changeAdviceDispatchSetting *)ptr);
		break;
	case SOAP_TYPE_ns__changeAdviceDispatchSettingResponse:
		soap_serialize_ns__changeAdviceDispatchSettingResponse(soap, (const struct ns__changeAdviceDispatchSettingResponse *)ptr);
		break;
	case SOAP_TYPE_ns__addAdviceDispatchSetting:
		soap_serialize_ns__addAdviceDispatchSetting(soap, (const struct ns__addAdviceDispatchSetting *)ptr);
		break;
	case SOAP_TYPE_ns__addAdviceDispatchSettingResponse:
		soap_serialize_ns__addAdviceDispatchSettingResponse(soap, (const struct ns__addAdviceDispatchSettingResponse *)ptr);
		break;
	case SOAP_TYPE_ns__awizoSendSMS:
		soap_serialize_ns__awizoSendSMS(soap, (const struct ns__awizoSendSMS *)ptr);
		break;
	case SOAP_TYPE_ns__awizoSendSMSResponse:
		soap_serialize_ns__awizoSendSMSResponse(soap, (const struct ns__awizoSendSMSResponse *)ptr);
		break;
	case SOAP_TYPE_ns__changeConfiguration:
		soap_serialize_ns__changeConfiguration(soap, (const struct ns__changeConfiguration *)ptr);
		break;
	case SOAP_TYPE_ns__changeConfigurationResponse:
		soap_serialize_ns__changeConfigurationResponse(soap, (const struct ns__changeConfigurationResponse *)ptr);
		break;
	case SOAP_TYPE_ns__stopSendingProcess:
		soap_serialize_ns__stopSendingProcess(soap, (const struct ns__stopSendingProcess *)ptr);
		break;
	case SOAP_TYPE_ns__stopSendingProcessResponse:
		soap_serialize_ns__stopSendingProcessResponse(soap, (const struct ns__stopSendingProcessResponse *)ptr);
		break;
	case SOAP_TYPE_ns__countMailFromQueue:
		soap_serialize_ns__countMailFromQueue(soap, (const struct ns__countMailFromQueue *)ptr);
		break;
	case SOAP_TYPE_ns__countMailFromQueueResponse:
		soap_serialize_ns__countMailFromQueueResponse(soap, (const struct ns__countMailFromQueueResponse *)ptr);
		break;
	case SOAP_TYPE_ns__clearMailQueue:
		soap_serialize_ns__clearMailQueue(soap, (const struct ns__clearMailQueue *)ptr);
		break;
	case SOAP_TYPE_ns__clearMailQueueResponse:
		soap_serialize_ns__clearMailQueueResponse(soap, (const struct ns__clearMailQueueResponse *)ptr);
		break;
	case SOAP_TYPE_ns__clearCache:
		soap_serialize_ns__clearCache(soap, (const struct ns__clearCache *)ptr);
		break;
	case SOAP_TYPE_ns__clearCacheResponse:
		soap_serialize_ns__clearCacheResponse(soap, (const struct ns__clearCacheResponse *)ptr);
		break;
	case SOAP_TYPE_ns__awizoSetFromMsgQueueSend:
		soap_serialize_ns__awizoSetFromMsgQueueSend(soap, (const struct ns__awizoSetFromMsgQueueSend *)ptr);
		break;
	case SOAP_TYPE_ns__awizoSetFromMsgQueueSendResponse:
		soap_serialize_ns__awizoSetFromMsgQueueSendResponse(soap, (const struct ns__awizoSetFromMsgQueueSendResponse *)ptr);
		break;
	case SOAP_TYPE_ns__awizoSend:
		soap_serialize_ns__awizoSend(soap, (const struct ns__awizoSend *)ptr);
		break;
	case SOAP_TYPE_ns__awizoSendResponse:
		soap_serialize_ns__awizoSendResponse(soap, (const struct ns__awizoSendResponse *)ptr);
		break;
	case SOAP_TYPE_ns__awizoChangeSenderInfo:
		soap_serialize_ns__awizoChangeSenderInfo(soap, (const struct ns__awizoChangeSenderInfo *)ptr);
		break;
	case SOAP_TYPE_ns__awizoChangeSenderInfoResponse:
		soap_serialize_ns__awizoChangeSenderInfoResponse(soap, (const struct ns__awizoChangeSenderInfoResponse *)ptr);
		break;
	case SOAP_TYPE_ns__awizoGetSenderInfo:
		soap_serialize_ns__awizoGetSenderInfo(soap, (const struct ns__awizoGetSenderInfo *)ptr);
		break;
	case SOAP_TYPE_ns__awizoGetSenderInfoResponse:
		soap_serialize_ns__awizoGetSenderInfoResponse(soap, (const struct ns__awizoGetSenderInfoResponse *)ptr);
		break;
	case SOAP_TYPE_ns__awizoDeleteSender:
		soap_serialize_ns__awizoDeleteSender(soap, (const struct ns__awizoDeleteSender *)ptr);
		break;
	case SOAP_TYPE_ns__awizoDeleteSenderResponse:
		soap_serialize_ns__awizoDeleteSenderResponse(soap, (const struct ns__awizoDeleteSenderResponse *)ptr);
		break;
	case SOAP_TYPE_ns__awizoInsertSender:
		soap_serialize_ns__awizoInsertSender(soap, (const struct ns__awizoInsertSender *)ptr);
		break;
	case SOAP_TYPE_ns__awizoInsertSenderResponse:
		soap_serialize_ns__awizoInsertSenderResponse(soap, (const struct ns__awizoInsertSenderResponse *)ptr);
		break;
	case SOAP_TYPE_ns__awizoChangeAttachmentInfo:
		soap_serialize_ns__awizoChangeAttachmentInfo(soap, (const struct ns__awizoChangeAttachmentInfo *)ptr);
		break;
	case SOAP_TYPE_ns__awizoChangeAttachmentInfoResponse:
		soap_serialize_ns__awizoChangeAttachmentInfoResponse(soap, (const struct ns__awizoChangeAttachmentInfoResponse *)ptr);
		break;
	case SOAP_TYPE_ns__awizoDownloadAttachment:
		soap_serialize_ns__awizoDownloadAttachment(soap, (const struct ns__awizoDownloadAttachment *)ptr);
		break;
	case SOAP_TYPE_ns__awizoDownloadAttachmentResponse:
		soap_serialize_ns__awizoDownloadAttachmentResponse(soap, (const struct ns__awizoDownloadAttachmentResponse *)ptr);
		break;
	case SOAP_TYPE_ns__awizoDeleteAttachment:
		soap_serialize_ns__awizoDeleteAttachment(soap, (const struct ns__awizoDeleteAttachment *)ptr);
		break;
	case SOAP_TYPE_ns__awizoDeleteAttachmentResponse:
		soap_serialize_ns__awizoDeleteAttachmentResponse(soap, (const struct ns__awizoDeleteAttachmentResponse *)ptr);
		break;
	case SOAP_TYPE_ns__awizoInsertAttachment:
		soap_serialize_ns__awizoInsertAttachment(soap, (const struct ns__awizoInsertAttachment *)ptr);
		break;
	case SOAP_TYPE_ns__awizoInsertAttachmentResponse:
		soap_serialize_ns__awizoInsertAttachmentResponse(soap, (const struct ns__awizoInsertAttachmentResponse *)ptr);
		break;
	case SOAP_TYPE_ns__awizoChangeTemplateInfo:
		soap_serialize_ns__awizoChangeTemplateInfo(soap, (const struct ns__awizoChangeTemplateInfo *)ptr);
		break;
	case SOAP_TYPE_ns__awizoChangeTemplateInfoResponse:
		soap_serialize_ns__awizoChangeTemplateInfoResponse(soap, (const struct ns__awizoChangeTemplateInfoResponse *)ptr);
		break;
	case SOAP_TYPE_ns__awizoDownloadTemplate:
		soap_serialize_ns__awizoDownloadTemplate(soap, (const struct ns__awizoDownloadTemplate *)ptr);
		break;
	case SOAP_TYPE_ns__awizoDownloadTemplateResponse:
		soap_serialize_ns__awizoDownloadTemplateResponse(soap, (const struct ns__awizoDownloadTemplateResponse *)ptr);
		break;
	case SOAP_TYPE_ns__awizoDeleteTemplate:
		soap_serialize_ns__awizoDeleteTemplate(soap, (const struct ns__awizoDeleteTemplate *)ptr);
		break;
	case SOAP_TYPE_ns__awizoDeleteTemplateResponse:
		soap_serialize_ns__awizoDeleteTemplateResponse(soap, (const struct ns__awizoDeleteTemplateResponse *)ptr);
		break;
	case SOAP_TYPE_ns__awizoInsertTemplate:
		soap_serialize_ns__awizoInsertTemplate(soap, (const struct ns__awizoInsertTemplate *)ptr);
		break;
	case SOAP_TYPE_ns__awizoInsertTemplateResponse:
		soap_serialize_ns__awizoInsertTemplateResponse(soap, (const struct ns__awizoInsertTemplateResponse *)ptr);
		break;
	case SOAP_TYPE_ns__awizoGetSendersList:
		soap_serialize_ns__awizoGetSendersList(soap, (const struct ns__awizoGetSendersList *)ptr);
		break;
	case SOAP_TYPE_ns__awizoGetSendersListResponse:
		soap_serialize_ns__awizoGetSendersListResponse(soap, (const struct ns__awizoGetSendersListResponse *)ptr);
		break;
	case SOAP_TYPE_ns__senderComplexList:
		soap_serialize_ns__senderComplexList(soap, (const struct ns__senderComplexList *)ptr);
		break;
	case SOAP_TYPE_ns__attachmentComplex:
		soap_serialize_ns__attachmentComplex(soap, (const struct ns__attachmentComplex *)ptr);
		break;
	case SOAP_TYPE_ns__templateComplex:
		soap_serialize_ns__templateComplex(soap, (const struct ns__templateComplex *)ptr);
		break;
	case SOAP_TYPE_ns__senderComplex:
		soap_serialize_ns__senderComplex(soap, (const struct ns__senderComplex *)ptr);
		break;
	case SOAP_TYPE_ns__dateTimeComplexList:
		soap_serialize_ns__dateTimeComplexList(soap, (const struct ns__dateTimeComplexList *)ptr);
		break;
	case SOAP_TYPE_ns_dateTime:
		soap_serialize_ns_dateTime(soap, (const struct ns_dateTime *)ptr);
		break;
	case SOAP_TYPE_ns__awizoMessage:
		soap_serialize_ns__awizoMessage(soap, (const struct ns__awizoMessage *)ptr);
		break;
	case SOAP_TYPE_ns__awizoConfig:
		soap_serialize_ns__awizoConfig(soap, (const struct ns__awizoConfig *)ptr);
		break;
	case SOAP_TYPE_xsd__base64Binary:
		soap_serialize_xsd__base64Binary(soap, (const struct xsd__base64Binary *)ptr);
		break;
	case SOAP_TYPE_PointerTons__dateTimeComplexList:
		soap_serialize_PointerTons__dateTimeComplexList(soap, (struct ns__dateTimeComplexList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons__awizoConfig:
		soap_serialize_PointerTons__awizoConfig(soap, (struct ns__awizoConfig *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostring:
		soap_serialize_PointerTostring(soap, (char **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons__awizoMessage:
		soap_serialize_PointerTons__awizoMessage(soap, (struct ns__awizoMessage *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons__senderComplex:
		soap_serialize_PointerToPointerTons__senderComplex(soap, (struct ns__senderComplex **const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons__attachmentComplex:
		soap_serialize_PointerToPointerTons__attachmentComplex(soap, (struct ns__attachmentComplex **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons__attachmentComplex:
		soap_serialize_PointerTons__attachmentComplex(soap, (struct ns__attachmentComplex *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons__templateComplex:
		soap_serialize_PointerToPointerTons__templateComplex(soap, (struct ns__templateComplex **const*)ptr);
		break;
	case SOAP_TYPE_PointerTolong:
		soap_serialize_PointerTolong(soap, (long *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons__templateComplex:
		soap_serialize_PointerTons__templateComplex(soap, (struct ns__templateComplex *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons__senderComplexList:
		soap_serialize_PointerToPointerTons__senderComplexList(soap, (struct ns__senderComplexList **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons__senderComplexList:
		soap_serialize_PointerTons__senderComplexList(soap, (struct ns__senderComplexList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons__senderComplex:
		soap_serialize_PointerTons__senderComplex(soap, (struct ns__senderComplex *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons_dateTime:
		soap_serialize_PointerTons_dateTime(soap, (struct ns_dateTime *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__base64Binary:
		soap_serialize_PointerToxsd__base64Binary(soap, (struct xsd__base64Binary *const*)ptr);
		break;
	case SOAP_TYPE_PointerTounsignedByte:
		soap_serialize_PointerTounsignedByte(soap, (unsigned char *const*)ptr);
		break;
	case SOAP_TYPE_xsd__string:
		soap_serialize_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char**)&ptr);
		break;
	}
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	return soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__int(struct soap *soap, int *a)
{	soap_default_int(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__int);
	if (soap_out_xsd__int(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_xsd__int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_xsd__int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__int(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_xsd__int(struct soap *soap, const char *tag, int *a, const char *type)
{
	return soap_inint(soap, tag, a, type, SOAP_TYPE_xsd__int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	return soap_inint(soap, tag, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_long(struct soap *soap, long *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_long
	*a = SOAP_DEFAULT_long;
#else
	*a = (long)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_long(struct soap *soap, const long *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_long);
	if (soap_out_long(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_long(struct soap *soap, const char *tag, int id, const long *a, const char *type)
{
	return soap_outlong(soap, tag, id, a, type, SOAP_TYPE_long);
}

SOAP_FMAC3 long * SOAP_FMAC4 soap_get_long(struct soap *soap, long *p, const char *tag, const char *type)
{
	if ((p = soap_in_long(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 long * SOAP_FMAC4 soap_in_long(struct soap *soap, const char *tag, long *a, const char *type)
{
	return soap_inlong(soap, tag, a, type, SOAP_TYPE_long);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedByte(struct soap *soap, unsigned char *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedByte
	*a = SOAP_DEFAULT_unsignedByte;
#else
	*a = (unsigned char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedByte(struct soap *soap, const unsigned char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedByte);
	if (soap_out_unsignedByte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedByte(struct soap *soap, const char *tag, int id, const unsigned char *a, const char *type)
{
	return soap_outunsignedByte(soap, tag, id, a, type, SOAP_TYPE_unsignedByte);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_get_unsignedByte(struct soap *soap, unsigned char *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedByte(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_in_unsignedByte(struct soap *soap, const char *tag, unsigned char *a, const char *type)
{
	return soap_inunsignedByte(soap, tag, a, type, SOAP_TYPE_unsignedByte);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedInt(struct soap *soap, unsigned int *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedInt
	*a = SOAP_DEFAULT_unsignedInt;
#else
	*a = (unsigned int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedInt(struct soap *soap, const unsigned int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedInt);
	if (soap_out_unsignedInt(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedInt(struct soap *soap, const char *tag, int id, const unsigned int *a, const char *type)
{
	return soap_outunsignedInt(soap, tag, id, a, type, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_get_unsignedInt(struct soap *soap, unsigned int *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedInt(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_in_unsignedInt(struct soap *soap, const char *tag, unsigned int *a, const char *type)
{
	return soap_inunsignedInt(soap, tag, a, type, SOAP_TYPE_unsignedInt);
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type);
	soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, "");
	soap_out_string(soap, "faultstring", -1, &a->faultstring, "");
	soap_out_string(soap, "faultactor", -1, &a->faultactor, "");
	soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, "");
	soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, "");
	soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, "");
	soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, "");
	soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, "");
	soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	short soap_flag_faultcode = 1, soap_flag_faultstring = 1, soap_flag_faultactor = 1, soap_flag_detail = 1, soap_flag_SOAP_ENV__Code = 1, soap_flag_SOAP_ENV__Reason = 1, soap_flag_SOAP_ENV__Node = 1, soap_flag_SOAP_ENV__Role = 1, soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type);
	soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	short soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__type = 0;
	a->fault = NULL;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type);
	soap_putelement(soap, a->fault, "fault", -1, a->__type);
	soap_outliteral(soap, "-any", &a->__any, NULL);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	short soap_flag_fault = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type);
	soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, "");
	soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	short soap_flag_SOAP_ENV__Value = 1, soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient dummy skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient dummy skipped */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type);
	/* transient dummy skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		/* transient dummy skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__removeAdviceDispatchSetting(struct soap *soap, struct ns__removeAdviceDispatchSetting *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_long(soap, &a->dispatchSettingId);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__removeAdviceDispatchSetting(struct soap *soap, const struct ns__removeAdviceDispatchSetting *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->dispatchSettingId, SOAP_TYPE_long);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__removeAdviceDispatchSetting(struct soap *soap, const struct ns__removeAdviceDispatchSetting *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__removeAdviceDispatchSetting);
	if (soap_out_ns__removeAdviceDispatchSetting(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__removeAdviceDispatchSetting(struct soap *soap, const char *tag, int id, const struct ns__removeAdviceDispatchSetting *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__removeAdviceDispatchSetting), type);
	soap_out_long(soap, "dispatchSettingId", -1, &a->dispatchSettingId, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__removeAdviceDispatchSetting * SOAP_FMAC4 soap_get_ns__removeAdviceDispatchSetting(struct soap *soap, struct ns__removeAdviceDispatchSetting *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__removeAdviceDispatchSetting(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__removeAdviceDispatchSetting * SOAP_FMAC4 soap_in_ns__removeAdviceDispatchSetting(struct soap *soap, const char *tag, struct ns__removeAdviceDispatchSetting *a, const char *type)
{
	short soap_flag_dispatchSettingId = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__removeAdviceDispatchSetting *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__removeAdviceDispatchSetting, sizeof(struct ns__removeAdviceDispatchSetting), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__removeAdviceDispatchSetting(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_dispatchSettingId && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_long(soap, "dispatchSettingId", &a->dispatchSettingId, "xsd:long"))
				{	soap_flag_dispatchSettingId--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__removeAdviceDispatchSetting *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__removeAdviceDispatchSetting, 0, sizeof(struct ns__removeAdviceDispatchSetting), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_dispatchSettingId > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__removeAdviceDispatchSettingResponse(struct soap *soap, struct ns__removeAdviceDispatchSettingResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__removeAdviceDispatchSettingResponse(struct soap *soap, const struct ns__removeAdviceDispatchSettingResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTolong(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__removeAdviceDispatchSettingResponse(struct soap *soap, const struct ns__removeAdviceDispatchSettingResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__removeAdviceDispatchSettingResponse);
	if (soap_out_ns__removeAdviceDispatchSettingResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__removeAdviceDispatchSettingResponse(struct soap *soap, const char *tag, int id, const struct ns__removeAdviceDispatchSettingResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__removeAdviceDispatchSettingResponse), type);
	if (a->result)
		soap_element_result(soap, "result");
	soap_out_PointerTolong(soap, "result", -1, &a->result, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__removeAdviceDispatchSettingResponse * SOAP_FMAC4 soap_get_ns__removeAdviceDispatchSettingResponse(struct soap *soap, struct ns__removeAdviceDispatchSettingResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__removeAdviceDispatchSettingResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__removeAdviceDispatchSettingResponse * SOAP_FMAC4 soap_in_ns__removeAdviceDispatchSettingResponse(struct soap *soap, const char *tag, struct ns__removeAdviceDispatchSettingResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__removeAdviceDispatchSettingResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__removeAdviceDispatchSettingResponse, sizeof(struct ns__removeAdviceDispatchSettingResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__removeAdviceDispatchSettingResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTolong(soap, "result", &a->result, "xsd:long"))
				{	soap_flag_result--;
					continue;
				}
			soap_check_result(soap, "result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__removeAdviceDispatchSettingResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__removeAdviceDispatchSettingResponse, 0, sizeof(struct ns__removeAdviceDispatchSettingResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__changeAdviceDispatchSetting(struct soap *soap, struct ns__changeAdviceDispatchSetting *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_long(soap, &a->dispatchSettingId);
	a->message = NULL;
	a->dateTime = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__changeAdviceDispatchSetting(struct soap *soap, const struct ns__changeAdviceDispatchSetting *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->dispatchSettingId, SOAP_TYPE_long);
	soap_serialize_PointerTons__awizoMessage(soap, &a->message);
	soap_serialize_PointerTons__dateTimeComplexList(soap, &a->dateTime);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__changeAdviceDispatchSetting(struct soap *soap, const struct ns__changeAdviceDispatchSetting *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__changeAdviceDispatchSetting);
	if (soap_out_ns__changeAdviceDispatchSetting(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__changeAdviceDispatchSetting(struct soap *soap, const char *tag, int id, const struct ns__changeAdviceDispatchSetting *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__changeAdviceDispatchSetting), type);
	soap_out_long(soap, "dispatchSettingId", -1, &a->dispatchSettingId, "");
	soap_out_PointerTons__awizoMessage(soap, "message", -1, &a->message, "");
	soap_out_PointerTons__dateTimeComplexList(soap, "dateTime", -1, &a->dateTime, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__changeAdviceDispatchSetting * SOAP_FMAC4 soap_get_ns__changeAdviceDispatchSetting(struct soap *soap, struct ns__changeAdviceDispatchSetting *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__changeAdviceDispatchSetting(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__changeAdviceDispatchSetting * SOAP_FMAC4 soap_in_ns__changeAdviceDispatchSetting(struct soap *soap, const char *tag, struct ns__changeAdviceDispatchSetting *a, const char *type)
{
	short soap_flag_dispatchSettingId = 1, soap_flag_message = 1, soap_flag_dateTime = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__changeAdviceDispatchSetting *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__changeAdviceDispatchSetting, sizeof(struct ns__changeAdviceDispatchSetting), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__changeAdviceDispatchSetting(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_dispatchSettingId && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_long(soap, "dispatchSettingId", &a->dispatchSettingId, "xsd:long"))
				{	soap_flag_dispatchSettingId--;
					continue;
				}
			if (soap_flag_message && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons__awizoMessage(soap, "message", &a->message, "ns:awizoMessage"))
				{	soap_flag_message--;
					continue;
				}
			if (soap_flag_dateTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons__dateTimeComplexList(soap, "dateTime", &a->dateTime, "ns:dateTimeComplexList"))
				{	soap_flag_dateTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__changeAdviceDispatchSetting *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__changeAdviceDispatchSetting, 0, sizeof(struct ns__changeAdviceDispatchSetting), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_dispatchSettingId > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__changeAdviceDispatchSettingResponse(struct soap *soap, struct ns__changeAdviceDispatchSettingResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__changeAdviceDispatchSettingResponse(struct soap *soap, const struct ns__changeAdviceDispatchSettingResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTolong(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__changeAdviceDispatchSettingResponse(struct soap *soap, const struct ns__changeAdviceDispatchSettingResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__changeAdviceDispatchSettingResponse);
	if (soap_out_ns__changeAdviceDispatchSettingResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__changeAdviceDispatchSettingResponse(struct soap *soap, const char *tag, int id, const struct ns__changeAdviceDispatchSettingResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__changeAdviceDispatchSettingResponse), type);
	if (a->result)
		soap_element_result(soap, "result");
	soap_out_PointerTolong(soap, "result", -1, &a->result, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__changeAdviceDispatchSettingResponse * SOAP_FMAC4 soap_get_ns__changeAdviceDispatchSettingResponse(struct soap *soap, struct ns__changeAdviceDispatchSettingResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__changeAdviceDispatchSettingResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__changeAdviceDispatchSettingResponse * SOAP_FMAC4 soap_in_ns__changeAdviceDispatchSettingResponse(struct soap *soap, const char *tag, struct ns__changeAdviceDispatchSettingResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__changeAdviceDispatchSettingResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__changeAdviceDispatchSettingResponse, sizeof(struct ns__changeAdviceDispatchSettingResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__changeAdviceDispatchSettingResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTolong(soap, "result", &a->result, "xsd:long"))
				{	soap_flag_result--;
					continue;
				}
			soap_check_result(soap, "result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__changeAdviceDispatchSettingResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__changeAdviceDispatchSettingResponse, 0, sizeof(struct ns__changeAdviceDispatchSettingResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__addAdviceDispatchSetting(struct soap *soap, struct ns__addAdviceDispatchSetting *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->message = NULL;
	a->dateTime = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__addAdviceDispatchSetting(struct soap *soap, const struct ns__addAdviceDispatchSetting *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons__awizoMessage(soap, &a->message);
	soap_serialize_PointerTons__dateTimeComplexList(soap, &a->dateTime);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__addAdviceDispatchSetting(struct soap *soap, const struct ns__addAdviceDispatchSetting *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__addAdviceDispatchSetting);
	if (soap_out_ns__addAdviceDispatchSetting(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__addAdviceDispatchSetting(struct soap *soap, const char *tag, int id, const struct ns__addAdviceDispatchSetting *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__addAdviceDispatchSetting), type);
	soap_out_PointerTons__awizoMessage(soap, "message", -1, &a->message, "");
	soap_out_PointerTons__dateTimeComplexList(soap, "dateTime", -1, &a->dateTime, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__addAdviceDispatchSetting * SOAP_FMAC4 soap_get_ns__addAdviceDispatchSetting(struct soap *soap, struct ns__addAdviceDispatchSetting *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__addAdviceDispatchSetting(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__addAdviceDispatchSetting * SOAP_FMAC4 soap_in_ns__addAdviceDispatchSetting(struct soap *soap, const char *tag, struct ns__addAdviceDispatchSetting *a, const char *type)
{
	short soap_flag_message = 1, soap_flag_dateTime = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__addAdviceDispatchSetting *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__addAdviceDispatchSetting, sizeof(struct ns__addAdviceDispatchSetting), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__addAdviceDispatchSetting(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_message && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons__awizoMessage(soap, "message", &a->message, "ns:awizoMessage"))
				{	soap_flag_message--;
					continue;
				}
			if (soap_flag_dateTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons__dateTimeComplexList(soap, "dateTime", &a->dateTime, "ns:dateTimeComplexList"))
				{	soap_flag_dateTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__addAdviceDispatchSetting *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__addAdviceDispatchSetting, 0, sizeof(struct ns__addAdviceDispatchSetting), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__addAdviceDispatchSettingResponse(struct soap *soap, struct ns__addAdviceDispatchSettingResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__addAdviceDispatchSettingResponse(struct soap *soap, const struct ns__addAdviceDispatchSettingResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTolong(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__addAdviceDispatchSettingResponse(struct soap *soap, const struct ns__addAdviceDispatchSettingResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__addAdviceDispatchSettingResponse);
	if (soap_out_ns__addAdviceDispatchSettingResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__addAdviceDispatchSettingResponse(struct soap *soap, const char *tag, int id, const struct ns__addAdviceDispatchSettingResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__addAdviceDispatchSettingResponse), type);
	if (a->result)
		soap_element_result(soap, "result");
	soap_out_PointerTolong(soap, "result", -1, &a->result, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__addAdviceDispatchSettingResponse * SOAP_FMAC4 soap_get_ns__addAdviceDispatchSettingResponse(struct soap *soap, struct ns__addAdviceDispatchSettingResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__addAdviceDispatchSettingResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__addAdviceDispatchSettingResponse * SOAP_FMAC4 soap_in_ns__addAdviceDispatchSettingResponse(struct soap *soap, const char *tag, struct ns__addAdviceDispatchSettingResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__addAdviceDispatchSettingResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__addAdviceDispatchSettingResponse, sizeof(struct ns__addAdviceDispatchSettingResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__addAdviceDispatchSettingResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTolong(soap, "result", &a->result, "xsd:long"))
				{	soap_flag_result--;
					continue;
				}
			soap_check_result(soap, "result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__addAdviceDispatchSettingResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__addAdviceDispatchSettingResponse, 0, sizeof(struct ns__addAdviceDispatchSettingResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__awizoSendSMS(struct soap *soap, struct ns__awizoSendSMS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->message);
	soap_default_string(soap, &a->to);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__awizoSendSMS(struct soap *soap, const struct ns__awizoSendSMS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->message);
	soap_serialize_string(soap, &a->to);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__awizoSendSMS(struct soap *soap, const struct ns__awizoSendSMS *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__awizoSendSMS);
	if (soap_out_ns__awizoSendSMS(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__awizoSendSMS(struct soap *soap, const char *tag, int id, const struct ns__awizoSendSMS *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__awizoSendSMS), type);
	soap_out_string(soap, "message", -1, &a->message, "");
	soap_out_string(soap, "to", -1, &a->to, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__awizoSendSMS * SOAP_FMAC4 soap_get_ns__awizoSendSMS(struct soap *soap, struct ns__awizoSendSMS *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__awizoSendSMS(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__awizoSendSMS * SOAP_FMAC4 soap_in_ns__awizoSendSMS(struct soap *soap, const char *tag, struct ns__awizoSendSMS *a, const char *type)
{
	short soap_flag_message = 1, soap_flag_to = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__awizoSendSMS *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__awizoSendSMS, sizeof(struct ns__awizoSendSMS), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__awizoSendSMS(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_message && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "message", &a->message, "xsd:string"))
				{	soap_flag_message--;
					continue;
				}
			if (soap_flag_to && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "to", &a->to, "xsd:string"))
				{	soap_flag_to--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__awizoSendSMS *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__awizoSendSMS, 0, sizeof(struct ns__awizoSendSMS), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__awizoSendSMSResponse(struct soap *soap, struct ns__awizoSendSMSResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__awizoSendSMSResponse(struct soap *soap, const struct ns__awizoSendSMSResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTolong(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__awizoSendSMSResponse(struct soap *soap, const struct ns__awizoSendSMSResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__awizoSendSMSResponse);
	if (soap_out_ns__awizoSendSMSResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__awizoSendSMSResponse(struct soap *soap, const char *tag, int id, const struct ns__awizoSendSMSResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__awizoSendSMSResponse), type);
	if (a->result)
		soap_element_result(soap, "result");
	soap_out_PointerTolong(soap, "result", -1, &a->result, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__awizoSendSMSResponse * SOAP_FMAC4 soap_get_ns__awizoSendSMSResponse(struct soap *soap, struct ns__awizoSendSMSResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__awizoSendSMSResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__awizoSendSMSResponse * SOAP_FMAC4 soap_in_ns__awizoSendSMSResponse(struct soap *soap, const char *tag, struct ns__awizoSendSMSResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__awizoSendSMSResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__awizoSendSMSResponse, sizeof(struct ns__awizoSendSMSResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__awizoSendSMSResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTolong(soap, "result", &a->result, "xsd:long"))
				{	soap_flag_result--;
					continue;
				}
			soap_check_result(soap, "result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__awizoSendSMSResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__awizoSendSMSResponse, 0, sizeof(struct ns__awizoSendSMSResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__changeConfiguration(struct soap *soap, struct ns__changeConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->conf = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__changeConfiguration(struct soap *soap, const struct ns__changeConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons__awizoConfig(soap, &a->conf);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__changeConfiguration(struct soap *soap, const struct ns__changeConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__changeConfiguration);
	if (soap_out_ns__changeConfiguration(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__changeConfiguration(struct soap *soap, const char *tag, int id, const struct ns__changeConfiguration *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__changeConfiguration), type);
	soap_out_PointerTons__awizoConfig(soap, "conf", -1, &a->conf, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__changeConfiguration * SOAP_FMAC4 soap_get_ns__changeConfiguration(struct soap *soap, struct ns__changeConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__changeConfiguration(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__changeConfiguration * SOAP_FMAC4 soap_in_ns__changeConfiguration(struct soap *soap, const char *tag, struct ns__changeConfiguration *a, const char *type)
{
	short soap_flag_conf = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__changeConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__changeConfiguration, sizeof(struct ns__changeConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__changeConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_conf && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons__awizoConfig(soap, "conf", &a->conf, "ns:awizoConfig"))
				{	soap_flag_conf--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__changeConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__changeConfiguration, 0, sizeof(struct ns__changeConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__changeConfigurationResponse(struct soap *soap, struct ns__changeConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__changeConfigurationResponse(struct soap *soap, const struct ns__changeConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTolong(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__changeConfigurationResponse(struct soap *soap, const struct ns__changeConfigurationResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__changeConfigurationResponse);
	if (soap_out_ns__changeConfigurationResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__changeConfigurationResponse(struct soap *soap, const char *tag, int id, const struct ns__changeConfigurationResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__changeConfigurationResponse), type);
	if (a->result)
		soap_element_result(soap, "result");
	soap_out_PointerTolong(soap, "result", -1, &a->result, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__changeConfigurationResponse * SOAP_FMAC4 soap_get_ns__changeConfigurationResponse(struct soap *soap, struct ns__changeConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__changeConfigurationResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__changeConfigurationResponse * SOAP_FMAC4 soap_in_ns__changeConfigurationResponse(struct soap *soap, const char *tag, struct ns__changeConfigurationResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__changeConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__changeConfigurationResponse, sizeof(struct ns__changeConfigurationResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__changeConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTolong(soap, "result", &a->result, "xsd:long"))
				{	soap_flag_result--;
					continue;
				}
			soap_check_result(soap, "result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__changeConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__changeConfigurationResponse, 0, sizeof(struct ns__changeConfigurationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__stopSendingProcess(struct soap *soap, struct ns__stopSendingProcess *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_long(soap, &a->awizo_switch);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__stopSendingProcess(struct soap *soap, const struct ns__stopSendingProcess *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->awizo_switch, SOAP_TYPE_long);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__stopSendingProcess(struct soap *soap, const struct ns__stopSendingProcess *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__stopSendingProcess);
	if (soap_out_ns__stopSendingProcess(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__stopSendingProcess(struct soap *soap, const char *tag, int id, const struct ns__stopSendingProcess *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__stopSendingProcess), type);
	soap_out_long(soap, "awizo-switch", -1, &a->awizo_switch, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__stopSendingProcess * SOAP_FMAC4 soap_get_ns__stopSendingProcess(struct soap *soap, struct ns__stopSendingProcess *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__stopSendingProcess(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__stopSendingProcess * SOAP_FMAC4 soap_in_ns__stopSendingProcess(struct soap *soap, const char *tag, struct ns__stopSendingProcess *a, const char *type)
{
	short soap_flag_awizo_switch = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__stopSendingProcess *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__stopSendingProcess, sizeof(struct ns__stopSendingProcess), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__stopSendingProcess(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_awizo_switch && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_long(soap, "awizo-switch", &a->awizo_switch, "xsd:long"))
				{	soap_flag_awizo_switch--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__stopSendingProcess *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__stopSendingProcess, 0, sizeof(struct ns__stopSendingProcess), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_awizo_switch > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__stopSendingProcessResponse(struct soap *soap, struct ns__stopSendingProcessResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__stopSendingProcessResponse(struct soap *soap, const struct ns__stopSendingProcessResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTolong(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__stopSendingProcessResponse(struct soap *soap, const struct ns__stopSendingProcessResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__stopSendingProcessResponse);
	if (soap_out_ns__stopSendingProcessResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__stopSendingProcessResponse(struct soap *soap, const char *tag, int id, const struct ns__stopSendingProcessResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__stopSendingProcessResponse), type);
	if (a->result)
		soap_element_result(soap, "result");
	soap_out_PointerTolong(soap, "result", -1, &a->result, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__stopSendingProcessResponse * SOAP_FMAC4 soap_get_ns__stopSendingProcessResponse(struct soap *soap, struct ns__stopSendingProcessResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__stopSendingProcessResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__stopSendingProcessResponse * SOAP_FMAC4 soap_in_ns__stopSendingProcessResponse(struct soap *soap, const char *tag, struct ns__stopSendingProcessResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__stopSendingProcessResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__stopSendingProcessResponse, sizeof(struct ns__stopSendingProcessResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__stopSendingProcessResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTolong(soap, "result", &a->result, "xsd:long"))
				{	soap_flag_result--;
					continue;
				}
			soap_check_result(soap, "result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__stopSendingProcessResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__stopSendingProcessResponse, 0, sizeof(struct ns__stopSendingProcessResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__countMailFromQueue(struct soap *soap, struct ns__countMailFromQueue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__countMailFromQueue(struct soap *soap, const struct ns__countMailFromQueue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__countMailFromQueue(struct soap *soap, const struct ns__countMailFromQueue *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__countMailFromQueue);
	if (soap_out_ns__countMailFromQueue(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__countMailFromQueue(struct soap *soap, const char *tag, int id, const struct ns__countMailFromQueue *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__countMailFromQueue), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__countMailFromQueue * SOAP_FMAC4 soap_get_ns__countMailFromQueue(struct soap *soap, struct ns__countMailFromQueue *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__countMailFromQueue(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__countMailFromQueue * SOAP_FMAC4 soap_in_ns__countMailFromQueue(struct soap *soap, const char *tag, struct ns__countMailFromQueue *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__countMailFromQueue *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__countMailFromQueue, sizeof(struct ns__countMailFromQueue), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__countMailFromQueue(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__countMailFromQueue *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__countMailFromQueue, 0, sizeof(struct ns__countMailFromQueue), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__countMailFromQueueResponse(struct soap *soap, struct ns__countMailFromQueueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__countMailFromQueueResponse(struct soap *soap, const struct ns__countMailFromQueueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTolong(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__countMailFromQueueResponse(struct soap *soap, const struct ns__countMailFromQueueResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__countMailFromQueueResponse);
	if (soap_out_ns__countMailFromQueueResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__countMailFromQueueResponse(struct soap *soap, const char *tag, int id, const struct ns__countMailFromQueueResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__countMailFromQueueResponse), type);
	if (a->result)
		soap_element_result(soap, "result");
	soap_out_PointerTolong(soap, "result", -1, &a->result, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__countMailFromQueueResponse * SOAP_FMAC4 soap_get_ns__countMailFromQueueResponse(struct soap *soap, struct ns__countMailFromQueueResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__countMailFromQueueResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__countMailFromQueueResponse * SOAP_FMAC4 soap_in_ns__countMailFromQueueResponse(struct soap *soap, const char *tag, struct ns__countMailFromQueueResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__countMailFromQueueResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__countMailFromQueueResponse, sizeof(struct ns__countMailFromQueueResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__countMailFromQueueResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTolong(soap, "result", &a->result, "xsd:long"))
				{	soap_flag_result--;
					continue;
				}
			soap_check_result(soap, "result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__countMailFromQueueResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__countMailFromQueueResponse, 0, sizeof(struct ns__countMailFromQueueResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__clearMailQueue(struct soap *soap, struct ns__clearMailQueue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__clearMailQueue(struct soap *soap, const struct ns__clearMailQueue *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__clearMailQueue(struct soap *soap, const struct ns__clearMailQueue *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__clearMailQueue);
	if (soap_out_ns__clearMailQueue(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__clearMailQueue(struct soap *soap, const char *tag, int id, const struct ns__clearMailQueue *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__clearMailQueue), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__clearMailQueue * SOAP_FMAC4 soap_get_ns__clearMailQueue(struct soap *soap, struct ns__clearMailQueue *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__clearMailQueue(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__clearMailQueue * SOAP_FMAC4 soap_in_ns__clearMailQueue(struct soap *soap, const char *tag, struct ns__clearMailQueue *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__clearMailQueue *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__clearMailQueue, sizeof(struct ns__clearMailQueue), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__clearMailQueue(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__clearMailQueue *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__clearMailQueue, 0, sizeof(struct ns__clearMailQueue), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__clearMailQueueResponse(struct soap *soap, struct ns__clearMailQueueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__clearMailQueueResponse(struct soap *soap, const struct ns__clearMailQueueResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTolong(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__clearMailQueueResponse(struct soap *soap, const struct ns__clearMailQueueResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__clearMailQueueResponse);
	if (soap_out_ns__clearMailQueueResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__clearMailQueueResponse(struct soap *soap, const char *tag, int id, const struct ns__clearMailQueueResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__clearMailQueueResponse), type);
	if (a->result)
		soap_element_result(soap, "result");
	soap_out_PointerTolong(soap, "result", -1, &a->result, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__clearMailQueueResponse * SOAP_FMAC4 soap_get_ns__clearMailQueueResponse(struct soap *soap, struct ns__clearMailQueueResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__clearMailQueueResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__clearMailQueueResponse * SOAP_FMAC4 soap_in_ns__clearMailQueueResponse(struct soap *soap, const char *tag, struct ns__clearMailQueueResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__clearMailQueueResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__clearMailQueueResponse, sizeof(struct ns__clearMailQueueResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__clearMailQueueResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTolong(soap, "result", &a->result, "xsd:long"))
				{	soap_flag_result--;
					continue;
				}
			soap_check_result(soap, "result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__clearMailQueueResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__clearMailQueueResponse, 0, sizeof(struct ns__clearMailQueueResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__clearCache(struct soap *soap, struct ns__clearCache *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__clearCache(struct soap *soap, const struct ns__clearCache *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__clearCache(struct soap *soap, const struct ns__clearCache *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__clearCache);
	if (soap_out_ns__clearCache(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__clearCache(struct soap *soap, const char *tag, int id, const struct ns__clearCache *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__clearCache), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__clearCache * SOAP_FMAC4 soap_get_ns__clearCache(struct soap *soap, struct ns__clearCache *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__clearCache(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__clearCache * SOAP_FMAC4 soap_in_ns__clearCache(struct soap *soap, const char *tag, struct ns__clearCache *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__clearCache *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__clearCache, sizeof(struct ns__clearCache), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__clearCache(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__clearCache *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__clearCache, 0, sizeof(struct ns__clearCache), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__clearCacheResponse(struct soap *soap, struct ns__clearCacheResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__clearCacheResponse(struct soap *soap, const struct ns__clearCacheResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTolong(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__clearCacheResponse(struct soap *soap, const struct ns__clearCacheResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__clearCacheResponse);
	if (soap_out_ns__clearCacheResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__clearCacheResponse(struct soap *soap, const char *tag, int id, const struct ns__clearCacheResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__clearCacheResponse), type);
	if (a->result)
		soap_element_result(soap, "result");
	soap_out_PointerTolong(soap, "result", -1, &a->result, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__clearCacheResponse * SOAP_FMAC4 soap_get_ns__clearCacheResponse(struct soap *soap, struct ns__clearCacheResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__clearCacheResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__clearCacheResponse * SOAP_FMAC4 soap_in_ns__clearCacheResponse(struct soap *soap, const char *tag, struct ns__clearCacheResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__clearCacheResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__clearCacheResponse, sizeof(struct ns__clearCacheResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__clearCacheResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTolong(soap, "result", &a->result, "xsd:long"))
				{	soap_flag_result--;
					continue;
				}
			soap_check_result(soap, "result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__clearCacheResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__clearCacheResponse, 0, sizeof(struct ns__clearCacheResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__awizoSetFromMsgQueueSend(struct soap *soap, struct ns__awizoSetFromMsgQueueSend *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__awizoSetFromMsgQueueSend(struct soap *soap, const struct ns__awizoSetFromMsgQueueSend *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__awizoSetFromMsgQueueSend(struct soap *soap, const struct ns__awizoSetFromMsgQueueSend *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__awizoSetFromMsgQueueSend);
	if (soap_out_ns__awizoSetFromMsgQueueSend(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__awizoSetFromMsgQueueSend(struct soap *soap, const char *tag, int id, const struct ns__awizoSetFromMsgQueueSend *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__awizoSetFromMsgQueueSend), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__awizoSetFromMsgQueueSend * SOAP_FMAC4 soap_get_ns__awizoSetFromMsgQueueSend(struct soap *soap, struct ns__awizoSetFromMsgQueueSend *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__awizoSetFromMsgQueueSend(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__awizoSetFromMsgQueueSend * SOAP_FMAC4 soap_in_ns__awizoSetFromMsgQueueSend(struct soap *soap, const char *tag, struct ns__awizoSetFromMsgQueueSend *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__awizoSetFromMsgQueueSend *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__awizoSetFromMsgQueueSend, sizeof(struct ns__awizoSetFromMsgQueueSend), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__awizoSetFromMsgQueueSend(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__awizoSetFromMsgQueueSend *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__awizoSetFromMsgQueueSend, 0, sizeof(struct ns__awizoSetFromMsgQueueSend), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__awizoSetFromMsgQueueSendResponse(struct soap *soap, struct ns__awizoSetFromMsgQueueSendResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__awizoSetFromMsgQueueSendResponse(struct soap *soap, const struct ns__awizoSetFromMsgQueueSendResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTolong(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__awizoSetFromMsgQueueSendResponse(struct soap *soap, const struct ns__awizoSetFromMsgQueueSendResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__awizoSetFromMsgQueueSendResponse);
	if (soap_out_ns__awizoSetFromMsgQueueSendResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__awizoSetFromMsgQueueSendResponse(struct soap *soap, const char *tag, int id, const struct ns__awizoSetFromMsgQueueSendResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__awizoSetFromMsgQueueSendResponse), type);
	if (a->result)
		soap_element_result(soap, "result");
	soap_out_PointerTolong(soap, "result", -1, &a->result, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__awizoSetFromMsgQueueSendResponse * SOAP_FMAC4 soap_get_ns__awizoSetFromMsgQueueSendResponse(struct soap *soap, struct ns__awizoSetFromMsgQueueSendResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__awizoSetFromMsgQueueSendResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__awizoSetFromMsgQueueSendResponse * SOAP_FMAC4 soap_in_ns__awizoSetFromMsgQueueSendResponse(struct soap *soap, const char *tag, struct ns__awizoSetFromMsgQueueSendResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__awizoSetFromMsgQueueSendResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__awizoSetFromMsgQueueSendResponse, sizeof(struct ns__awizoSetFromMsgQueueSendResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__awizoSetFromMsgQueueSendResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTolong(soap, "result", &a->result, "xsd:long"))
				{	soap_flag_result--;
					continue;
				}
			soap_check_result(soap, "result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__awizoSetFromMsgQueueSendResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__awizoSetFromMsgQueueSendResponse, 0, sizeof(struct ns__awizoSetFromMsgQueueSendResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__awizoSend(struct soap *soap, struct ns__awizoSend *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->message = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__awizoSend(struct soap *soap, const struct ns__awizoSend *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons__awizoMessage(soap, &a->message);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__awizoSend(struct soap *soap, const struct ns__awizoSend *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__awizoSend);
	if (soap_out_ns__awizoSend(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__awizoSend(struct soap *soap, const char *tag, int id, const struct ns__awizoSend *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__awizoSend), type);
	soap_out_PointerTons__awizoMessage(soap, "message", -1, &a->message, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__awizoSend * SOAP_FMAC4 soap_get_ns__awizoSend(struct soap *soap, struct ns__awizoSend *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__awizoSend(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__awizoSend * SOAP_FMAC4 soap_in_ns__awizoSend(struct soap *soap, const char *tag, struct ns__awizoSend *a, const char *type)
{
	short soap_flag_message = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__awizoSend *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__awizoSend, sizeof(struct ns__awizoSend), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__awizoSend(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_message && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons__awizoMessage(soap, "message", &a->message, "ns:awizoMessage"))
				{	soap_flag_message--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__awizoSend *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__awizoSend, 0, sizeof(struct ns__awizoSend), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__awizoSendResponse(struct soap *soap, struct ns__awizoSendResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->msgID = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__awizoSendResponse(struct soap *soap, const struct ns__awizoSendResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTostring(soap, &a->msgID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__awizoSendResponse(struct soap *soap, const struct ns__awizoSendResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__awizoSendResponse);
	if (soap_out_ns__awizoSendResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__awizoSendResponse(struct soap *soap, const char *tag, int id, const struct ns__awizoSendResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__awizoSendResponse), type);
	if (a->msgID)
		soap_element_result(soap, "msgID");
	soap_out_PointerTostring(soap, "msgID", -1, &a->msgID, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__awizoSendResponse * SOAP_FMAC4 soap_get_ns__awizoSendResponse(struct soap *soap, struct ns__awizoSendResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__awizoSendResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__awizoSendResponse * SOAP_FMAC4 soap_in_ns__awizoSendResponse(struct soap *soap, const char *tag, struct ns__awizoSendResponse *a, const char *type)
{
	short soap_flag_msgID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__awizoSendResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__awizoSendResponse, sizeof(struct ns__awizoSendResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__awizoSendResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_msgID && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTostring(soap, "msgID", &a->msgID, "xsd:string"))
				{	soap_flag_msgID--;
					continue;
				}
			soap_check_result(soap, "msgID");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__awizoSendResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__awizoSendResponse, 0, sizeof(struct ns__awizoSendResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__awizoChangeSenderInfo(struct soap *soap, struct ns__awizoChangeSenderInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_long(soap, &a->id);
	a->sender = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__awizoChangeSenderInfo(struct soap *soap, const struct ns__awizoChangeSenderInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->id, SOAP_TYPE_long);
	soap_serialize_PointerTons__senderComplex(soap, &a->sender);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__awizoChangeSenderInfo(struct soap *soap, const struct ns__awizoChangeSenderInfo *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__awizoChangeSenderInfo);
	if (soap_out_ns__awizoChangeSenderInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__awizoChangeSenderInfo(struct soap *soap, const char *tag, int id, const struct ns__awizoChangeSenderInfo *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__awizoChangeSenderInfo), type);
	soap_out_long(soap, "id", -1, &a->id, "");
	soap_out_PointerTons__senderComplex(soap, "sender", -1, &a->sender, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__awizoChangeSenderInfo * SOAP_FMAC4 soap_get_ns__awizoChangeSenderInfo(struct soap *soap, struct ns__awizoChangeSenderInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__awizoChangeSenderInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__awizoChangeSenderInfo * SOAP_FMAC4 soap_in_ns__awizoChangeSenderInfo(struct soap *soap, const char *tag, struct ns__awizoChangeSenderInfo *a, const char *type)
{
	short soap_flag_id = 1, soap_flag_sender = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__awizoChangeSenderInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__awizoChangeSenderInfo, sizeof(struct ns__awizoChangeSenderInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__awizoChangeSenderInfo(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_long(soap, "id", &a->id, "xsd:long"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_sender && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons__senderComplex(soap, "sender", &a->sender, "ns:senderComplex"))
				{	soap_flag_sender--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__awizoChangeSenderInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__awizoChangeSenderInfo, 0, sizeof(struct ns__awizoChangeSenderInfo), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__awizoChangeSenderInfoResponse(struct soap *soap, struct ns__awizoChangeSenderInfoResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__awizoChangeSenderInfoResponse(struct soap *soap, const struct ns__awizoChangeSenderInfoResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTolong(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__awizoChangeSenderInfoResponse(struct soap *soap, const struct ns__awizoChangeSenderInfoResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__awizoChangeSenderInfoResponse);
	if (soap_out_ns__awizoChangeSenderInfoResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__awizoChangeSenderInfoResponse(struct soap *soap, const char *tag, int id, const struct ns__awizoChangeSenderInfoResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__awizoChangeSenderInfoResponse), type);
	if (a->result)
		soap_element_result(soap, "result");
	soap_out_PointerTolong(soap, "result", -1, &a->result, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__awizoChangeSenderInfoResponse * SOAP_FMAC4 soap_get_ns__awizoChangeSenderInfoResponse(struct soap *soap, struct ns__awizoChangeSenderInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__awizoChangeSenderInfoResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__awizoChangeSenderInfoResponse * SOAP_FMAC4 soap_in_ns__awizoChangeSenderInfoResponse(struct soap *soap, const char *tag, struct ns__awizoChangeSenderInfoResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__awizoChangeSenderInfoResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__awizoChangeSenderInfoResponse, sizeof(struct ns__awizoChangeSenderInfoResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__awizoChangeSenderInfoResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTolong(soap, "result", &a->result, "xsd:long"))
				{	soap_flag_result--;
					continue;
				}
			soap_check_result(soap, "result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__awizoChangeSenderInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__awizoChangeSenderInfoResponse, 0, sizeof(struct ns__awizoChangeSenderInfoResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__awizoGetSenderInfo(struct soap *soap, struct ns__awizoGetSenderInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_long(soap, &a->id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__awizoGetSenderInfo(struct soap *soap, const struct ns__awizoGetSenderInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->id, SOAP_TYPE_long);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__awizoGetSenderInfo(struct soap *soap, const struct ns__awizoGetSenderInfo *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__awizoGetSenderInfo);
	if (soap_out_ns__awizoGetSenderInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__awizoGetSenderInfo(struct soap *soap, const char *tag, int id, const struct ns__awizoGetSenderInfo *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__awizoGetSenderInfo), type);
	soap_out_long(soap, "id", -1, &a->id, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__awizoGetSenderInfo * SOAP_FMAC4 soap_get_ns__awizoGetSenderInfo(struct soap *soap, struct ns__awizoGetSenderInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__awizoGetSenderInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__awizoGetSenderInfo * SOAP_FMAC4 soap_in_ns__awizoGetSenderInfo(struct soap *soap, const char *tag, struct ns__awizoGetSenderInfo *a, const char *type)
{
	short soap_flag_id = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__awizoGetSenderInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__awizoGetSenderInfo, sizeof(struct ns__awizoGetSenderInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__awizoGetSenderInfo(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_long(soap, "id", &a->id, "xsd:long"))
				{	soap_flag_id--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__awizoGetSenderInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__awizoGetSenderInfo, 0, sizeof(struct ns__awizoGetSenderInfo), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__awizoGetSenderInfoResponse(struct soap *soap, struct ns__awizoGetSenderInfoResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->sender = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__awizoGetSenderInfoResponse(struct soap *soap, const struct ns__awizoGetSenderInfoResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToPointerTons__senderComplex(soap, &a->sender);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__awizoGetSenderInfoResponse(struct soap *soap, const struct ns__awizoGetSenderInfoResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__awizoGetSenderInfoResponse);
	if (soap_out_ns__awizoGetSenderInfoResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__awizoGetSenderInfoResponse(struct soap *soap, const char *tag, int id, const struct ns__awizoGetSenderInfoResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__awizoGetSenderInfoResponse), type);
	if (a->sender)
		soap_element_result(soap, "sender");
	soap_out_PointerToPointerTons__senderComplex(soap, "sender", -1, &a->sender, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__awizoGetSenderInfoResponse * SOAP_FMAC4 soap_get_ns__awizoGetSenderInfoResponse(struct soap *soap, struct ns__awizoGetSenderInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__awizoGetSenderInfoResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__awizoGetSenderInfoResponse * SOAP_FMAC4 soap_in_ns__awizoGetSenderInfoResponse(struct soap *soap, const char *tag, struct ns__awizoGetSenderInfoResponse *a, const char *type)
{
	short soap_flag_sender = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__awizoGetSenderInfoResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__awizoGetSenderInfoResponse, sizeof(struct ns__awizoGetSenderInfoResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__awizoGetSenderInfoResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sender && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToPointerTons__senderComplex(soap, "sender", &a->sender, "ns:senderComplex"))
				{	soap_flag_sender--;
					continue;
				}
			soap_check_result(soap, "sender");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__awizoGetSenderInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__awizoGetSenderInfoResponse, 0, sizeof(struct ns__awizoGetSenderInfoResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__awizoDeleteSender(struct soap *soap, struct ns__awizoDeleteSender *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_long(soap, &a->id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__awizoDeleteSender(struct soap *soap, const struct ns__awizoDeleteSender *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->id, SOAP_TYPE_long);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__awizoDeleteSender(struct soap *soap, const struct ns__awizoDeleteSender *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__awizoDeleteSender);
	if (soap_out_ns__awizoDeleteSender(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__awizoDeleteSender(struct soap *soap, const char *tag, int id, const struct ns__awizoDeleteSender *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__awizoDeleteSender), type);
	soap_out_long(soap, "id", -1, &a->id, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__awizoDeleteSender * SOAP_FMAC4 soap_get_ns__awizoDeleteSender(struct soap *soap, struct ns__awizoDeleteSender *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__awizoDeleteSender(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__awizoDeleteSender * SOAP_FMAC4 soap_in_ns__awizoDeleteSender(struct soap *soap, const char *tag, struct ns__awizoDeleteSender *a, const char *type)
{
	short soap_flag_id = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__awizoDeleteSender *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__awizoDeleteSender, sizeof(struct ns__awizoDeleteSender), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__awizoDeleteSender(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_long(soap, "id", &a->id, "xsd:long"))
				{	soap_flag_id--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__awizoDeleteSender *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__awizoDeleteSender, 0, sizeof(struct ns__awizoDeleteSender), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__awizoDeleteSenderResponse(struct soap *soap, struct ns__awizoDeleteSenderResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__awizoDeleteSenderResponse(struct soap *soap, const struct ns__awizoDeleteSenderResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTolong(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__awizoDeleteSenderResponse(struct soap *soap, const struct ns__awizoDeleteSenderResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__awizoDeleteSenderResponse);
	if (soap_out_ns__awizoDeleteSenderResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__awizoDeleteSenderResponse(struct soap *soap, const char *tag, int id, const struct ns__awizoDeleteSenderResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__awizoDeleteSenderResponse), type);
	if (a->result)
		soap_element_result(soap, "result");
	soap_out_PointerTolong(soap, "result", -1, &a->result, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__awizoDeleteSenderResponse * SOAP_FMAC4 soap_get_ns__awizoDeleteSenderResponse(struct soap *soap, struct ns__awizoDeleteSenderResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__awizoDeleteSenderResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__awizoDeleteSenderResponse * SOAP_FMAC4 soap_in_ns__awizoDeleteSenderResponse(struct soap *soap, const char *tag, struct ns__awizoDeleteSenderResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__awizoDeleteSenderResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__awizoDeleteSenderResponse, sizeof(struct ns__awizoDeleteSenderResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__awizoDeleteSenderResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTolong(soap, "result", &a->result, "xsd:long"))
				{	soap_flag_result--;
					continue;
				}
			soap_check_result(soap, "result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__awizoDeleteSenderResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__awizoDeleteSenderResponse, 0, sizeof(struct ns__awizoDeleteSenderResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__awizoInsertSender(struct soap *soap, struct ns__awizoInsertSender *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->sender = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__awizoInsertSender(struct soap *soap, const struct ns__awizoInsertSender *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons__senderComplex(soap, &a->sender);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__awizoInsertSender(struct soap *soap, const struct ns__awizoInsertSender *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__awizoInsertSender);
	if (soap_out_ns__awizoInsertSender(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__awizoInsertSender(struct soap *soap, const char *tag, int id, const struct ns__awizoInsertSender *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__awizoInsertSender), type);
	soap_out_PointerTons__senderComplex(soap, "sender", -1, &a->sender, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__awizoInsertSender * SOAP_FMAC4 soap_get_ns__awizoInsertSender(struct soap *soap, struct ns__awizoInsertSender *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__awizoInsertSender(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__awizoInsertSender * SOAP_FMAC4 soap_in_ns__awizoInsertSender(struct soap *soap, const char *tag, struct ns__awizoInsertSender *a, const char *type)
{
	short soap_flag_sender = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__awizoInsertSender *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__awizoInsertSender, sizeof(struct ns__awizoInsertSender), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__awizoInsertSender(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sender && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons__senderComplex(soap, "sender", &a->sender, "ns:senderComplex"))
				{	soap_flag_sender--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__awizoInsertSender *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__awizoInsertSender, 0, sizeof(struct ns__awizoInsertSender), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__awizoInsertSenderResponse(struct soap *soap, struct ns__awizoInsertSenderResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__awizoInsertSenderResponse(struct soap *soap, const struct ns__awizoInsertSenderResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTolong(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__awizoInsertSenderResponse(struct soap *soap, const struct ns__awizoInsertSenderResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__awizoInsertSenderResponse);
	if (soap_out_ns__awizoInsertSenderResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__awizoInsertSenderResponse(struct soap *soap, const char *tag, int id, const struct ns__awizoInsertSenderResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__awizoInsertSenderResponse), type);
	if (a->result)
		soap_element_result(soap, "result");
	soap_out_PointerTolong(soap, "result", -1, &a->result, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__awizoInsertSenderResponse * SOAP_FMAC4 soap_get_ns__awizoInsertSenderResponse(struct soap *soap, struct ns__awizoInsertSenderResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__awizoInsertSenderResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__awizoInsertSenderResponse * SOAP_FMAC4 soap_in_ns__awizoInsertSenderResponse(struct soap *soap, const char *tag, struct ns__awizoInsertSenderResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__awizoInsertSenderResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__awizoInsertSenderResponse, sizeof(struct ns__awizoInsertSenderResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__awizoInsertSenderResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTolong(soap, "result", &a->result, "xsd:long"))
				{	soap_flag_result--;
					continue;
				}
			soap_check_result(soap, "result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__awizoInsertSenderResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__awizoInsertSenderResponse, 0, sizeof(struct ns__awizoInsertSenderResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__awizoChangeAttachmentInfo(struct soap *soap, struct ns__awizoChangeAttachmentInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_long(soap, &a->id);
	a->emailAttachment = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__awizoChangeAttachmentInfo(struct soap *soap, const struct ns__awizoChangeAttachmentInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->id, SOAP_TYPE_long);
	soap_serialize_PointerTons__attachmentComplex(soap, &a->emailAttachment);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__awizoChangeAttachmentInfo(struct soap *soap, const struct ns__awizoChangeAttachmentInfo *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__awizoChangeAttachmentInfo);
	if (soap_out_ns__awizoChangeAttachmentInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__awizoChangeAttachmentInfo(struct soap *soap, const char *tag, int id, const struct ns__awizoChangeAttachmentInfo *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__awizoChangeAttachmentInfo), type);
	soap_out_long(soap, "id", -1, &a->id, "");
	soap_out_PointerTons__attachmentComplex(soap, "emailAttachment", -1, &a->emailAttachment, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__awizoChangeAttachmentInfo * SOAP_FMAC4 soap_get_ns__awizoChangeAttachmentInfo(struct soap *soap, struct ns__awizoChangeAttachmentInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__awizoChangeAttachmentInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__awizoChangeAttachmentInfo * SOAP_FMAC4 soap_in_ns__awizoChangeAttachmentInfo(struct soap *soap, const char *tag, struct ns__awizoChangeAttachmentInfo *a, const char *type)
{
	short soap_flag_id = 1, soap_flag_emailAttachment = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__awizoChangeAttachmentInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__awizoChangeAttachmentInfo, sizeof(struct ns__awizoChangeAttachmentInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__awizoChangeAttachmentInfo(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_long(soap, "id", &a->id, "xsd:long"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_emailAttachment && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons__attachmentComplex(soap, "emailAttachment", &a->emailAttachment, "ns:attachmentComplex"))
				{	soap_flag_emailAttachment--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__awizoChangeAttachmentInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__awizoChangeAttachmentInfo, 0, sizeof(struct ns__awizoChangeAttachmentInfo), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__awizoChangeAttachmentInfoResponse(struct soap *soap, struct ns__awizoChangeAttachmentInfoResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__awizoChangeAttachmentInfoResponse(struct soap *soap, const struct ns__awizoChangeAttachmentInfoResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTolong(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__awizoChangeAttachmentInfoResponse(struct soap *soap, const struct ns__awizoChangeAttachmentInfoResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__awizoChangeAttachmentInfoResponse);
	if (soap_out_ns__awizoChangeAttachmentInfoResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__awizoChangeAttachmentInfoResponse(struct soap *soap, const char *tag, int id, const struct ns__awizoChangeAttachmentInfoResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__awizoChangeAttachmentInfoResponse), type);
	if (a->result)
		soap_element_result(soap, "result");
	soap_out_PointerTolong(soap, "result", -1, &a->result, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__awizoChangeAttachmentInfoResponse * SOAP_FMAC4 soap_get_ns__awizoChangeAttachmentInfoResponse(struct soap *soap, struct ns__awizoChangeAttachmentInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__awizoChangeAttachmentInfoResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__awizoChangeAttachmentInfoResponse * SOAP_FMAC4 soap_in_ns__awizoChangeAttachmentInfoResponse(struct soap *soap, const char *tag, struct ns__awizoChangeAttachmentInfoResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__awizoChangeAttachmentInfoResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__awizoChangeAttachmentInfoResponse, sizeof(struct ns__awizoChangeAttachmentInfoResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__awizoChangeAttachmentInfoResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTolong(soap, "result", &a->result, "xsd:long"))
				{	soap_flag_result--;
					continue;
				}
			soap_check_result(soap, "result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__awizoChangeAttachmentInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__awizoChangeAttachmentInfoResponse, 0, sizeof(struct ns__awizoChangeAttachmentInfoResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__awizoDownloadAttachment(struct soap *soap, struct ns__awizoDownloadAttachment *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_long(soap, &a->id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__awizoDownloadAttachment(struct soap *soap, const struct ns__awizoDownloadAttachment *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->id, SOAP_TYPE_long);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__awizoDownloadAttachment(struct soap *soap, const struct ns__awizoDownloadAttachment *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__awizoDownloadAttachment);
	if (soap_out_ns__awizoDownloadAttachment(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__awizoDownloadAttachment(struct soap *soap, const char *tag, int id, const struct ns__awizoDownloadAttachment *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__awizoDownloadAttachment), type);
	soap_out_long(soap, "id", -1, &a->id, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__awizoDownloadAttachment * SOAP_FMAC4 soap_get_ns__awizoDownloadAttachment(struct soap *soap, struct ns__awizoDownloadAttachment *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__awizoDownloadAttachment(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__awizoDownloadAttachment * SOAP_FMAC4 soap_in_ns__awizoDownloadAttachment(struct soap *soap, const char *tag, struct ns__awizoDownloadAttachment *a, const char *type)
{
	short soap_flag_id = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__awizoDownloadAttachment *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__awizoDownloadAttachment, sizeof(struct ns__awizoDownloadAttachment), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__awizoDownloadAttachment(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_long(soap, "id", &a->id, "xsd:long"))
				{	soap_flag_id--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__awizoDownloadAttachment *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__awizoDownloadAttachment, 0, sizeof(struct ns__awizoDownloadAttachment), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__awizoDownloadAttachmentResponse(struct soap *soap, struct ns__awizoDownloadAttachmentResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->emailAttachment = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__awizoDownloadAttachmentResponse(struct soap *soap, const struct ns__awizoDownloadAttachmentResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToPointerTons__attachmentComplex(soap, &a->emailAttachment);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__awizoDownloadAttachmentResponse(struct soap *soap, const struct ns__awizoDownloadAttachmentResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__awizoDownloadAttachmentResponse);
	if (soap_out_ns__awizoDownloadAttachmentResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__awizoDownloadAttachmentResponse(struct soap *soap, const char *tag, int id, const struct ns__awizoDownloadAttachmentResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__awizoDownloadAttachmentResponse), type);
	if (a->emailAttachment)
		soap_element_result(soap, "emailAttachment");
	soap_out_PointerToPointerTons__attachmentComplex(soap, "emailAttachment", -1, &a->emailAttachment, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__awizoDownloadAttachmentResponse * SOAP_FMAC4 soap_get_ns__awizoDownloadAttachmentResponse(struct soap *soap, struct ns__awizoDownloadAttachmentResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__awizoDownloadAttachmentResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__awizoDownloadAttachmentResponse * SOAP_FMAC4 soap_in_ns__awizoDownloadAttachmentResponse(struct soap *soap, const char *tag, struct ns__awizoDownloadAttachmentResponse *a, const char *type)
{
	short soap_flag_emailAttachment = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__awizoDownloadAttachmentResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__awizoDownloadAttachmentResponse, sizeof(struct ns__awizoDownloadAttachmentResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__awizoDownloadAttachmentResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_emailAttachment && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToPointerTons__attachmentComplex(soap, "emailAttachment", &a->emailAttachment, "ns:attachmentComplex"))
				{	soap_flag_emailAttachment--;
					continue;
				}
			soap_check_result(soap, "emailAttachment");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__awizoDownloadAttachmentResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__awizoDownloadAttachmentResponse, 0, sizeof(struct ns__awizoDownloadAttachmentResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__awizoDeleteAttachment(struct soap *soap, struct ns__awizoDeleteAttachment *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_long(soap, &a->id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__awizoDeleteAttachment(struct soap *soap, const struct ns__awizoDeleteAttachment *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->id, SOAP_TYPE_long);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__awizoDeleteAttachment(struct soap *soap, const struct ns__awizoDeleteAttachment *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__awizoDeleteAttachment);
	if (soap_out_ns__awizoDeleteAttachment(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__awizoDeleteAttachment(struct soap *soap, const char *tag, int id, const struct ns__awizoDeleteAttachment *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__awizoDeleteAttachment), type);
	soap_out_long(soap, "id", -1, &a->id, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__awizoDeleteAttachment * SOAP_FMAC4 soap_get_ns__awizoDeleteAttachment(struct soap *soap, struct ns__awizoDeleteAttachment *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__awizoDeleteAttachment(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__awizoDeleteAttachment * SOAP_FMAC4 soap_in_ns__awizoDeleteAttachment(struct soap *soap, const char *tag, struct ns__awizoDeleteAttachment *a, const char *type)
{
	short soap_flag_id = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__awizoDeleteAttachment *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__awizoDeleteAttachment, sizeof(struct ns__awizoDeleteAttachment), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__awizoDeleteAttachment(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_long(soap, "id", &a->id, "xsd:long"))
				{	soap_flag_id--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__awizoDeleteAttachment *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__awizoDeleteAttachment, 0, sizeof(struct ns__awizoDeleteAttachment), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__awizoDeleteAttachmentResponse(struct soap *soap, struct ns__awizoDeleteAttachmentResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__awizoDeleteAttachmentResponse(struct soap *soap, const struct ns__awizoDeleteAttachmentResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTolong(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__awizoDeleteAttachmentResponse(struct soap *soap, const struct ns__awizoDeleteAttachmentResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__awizoDeleteAttachmentResponse);
	if (soap_out_ns__awizoDeleteAttachmentResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__awizoDeleteAttachmentResponse(struct soap *soap, const char *tag, int id, const struct ns__awizoDeleteAttachmentResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__awizoDeleteAttachmentResponse), type);
	if (a->result)
		soap_element_result(soap, "result");
	soap_out_PointerTolong(soap, "result", -1, &a->result, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__awizoDeleteAttachmentResponse * SOAP_FMAC4 soap_get_ns__awizoDeleteAttachmentResponse(struct soap *soap, struct ns__awizoDeleteAttachmentResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__awizoDeleteAttachmentResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__awizoDeleteAttachmentResponse * SOAP_FMAC4 soap_in_ns__awizoDeleteAttachmentResponse(struct soap *soap, const char *tag, struct ns__awizoDeleteAttachmentResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__awizoDeleteAttachmentResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__awizoDeleteAttachmentResponse, sizeof(struct ns__awizoDeleteAttachmentResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__awizoDeleteAttachmentResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTolong(soap, "result", &a->result, "xsd:long"))
				{	soap_flag_result--;
					continue;
				}
			soap_check_result(soap, "result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__awizoDeleteAttachmentResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__awizoDeleteAttachmentResponse, 0, sizeof(struct ns__awizoDeleteAttachmentResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__awizoInsertAttachment(struct soap *soap, struct ns__awizoInsertAttachment *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->emailAttachment = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__awizoInsertAttachment(struct soap *soap, const struct ns__awizoInsertAttachment *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons__attachmentComplex(soap, &a->emailAttachment);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__awizoInsertAttachment(struct soap *soap, const struct ns__awizoInsertAttachment *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__awizoInsertAttachment);
	if (soap_out_ns__awizoInsertAttachment(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__awizoInsertAttachment(struct soap *soap, const char *tag, int id, const struct ns__awizoInsertAttachment *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__awizoInsertAttachment), type);
	soap_out_PointerTons__attachmentComplex(soap, "emailAttachment", -1, &a->emailAttachment, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__awizoInsertAttachment * SOAP_FMAC4 soap_get_ns__awizoInsertAttachment(struct soap *soap, struct ns__awizoInsertAttachment *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__awizoInsertAttachment(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__awizoInsertAttachment * SOAP_FMAC4 soap_in_ns__awizoInsertAttachment(struct soap *soap, const char *tag, struct ns__awizoInsertAttachment *a, const char *type)
{
	short soap_flag_emailAttachment = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__awizoInsertAttachment *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__awizoInsertAttachment, sizeof(struct ns__awizoInsertAttachment), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__awizoInsertAttachment(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_emailAttachment && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons__attachmentComplex(soap, "emailAttachment", &a->emailAttachment, "ns:attachmentComplex"))
				{	soap_flag_emailAttachment--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__awizoInsertAttachment *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__awizoInsertAttachment, 0, sizeof(struct ns__awizoInsertAttachment), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__awizoInsertAttachmentResponse(struct soap *soap, struct ns__awizoInsertAttachmentResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__awizoInsertAttachmentResponse(struct soap *soap, const struct ns__awizoInsertAttachmentResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTolong(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__awizoInsertAttachmentResponse(struct soap *soap, const struct ns__awizoInsertAttachmentResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__awizoInsertAttachmentResponse);
	if (soap_out_ns__awizoInsertAttachmentResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__awizoInsertAttachmentResponse(struct soap *soap, const char *tag, int id, const struct ns__awizoInsertAttachmentResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__awizoInsertAttachmentResponse), type);
	if (a->result)
		soap_element_result(soap, "result");
	soap_out_PointerTolong(soap, "result", -1, &a->result, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__awizoInsertAttachmentResponse * SOAP_FMAC4 soap_get_ns__awizoInsertAttachmentResponse(struct soap *soap, struct ns__awizoInsertAttachmentResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__awizoInsertAttachmentResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__awizoInsertAttachmentResponse * SOAP_FMAC4 soap_in_ns__awizoInsertAttachmentResponse(struct soap *soap, const char *tag, struct ns__awizoInsertAttachmentResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__awizoInsertAttachmentResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__awizoInsertAttachmentResponse, sizeof(struct ns__awizoInsertAttachmentResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__awizoInsertAttachmentResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTolong(soap, "result", &a->result, "xsd:long"))
				{	soap_flag_result--;
					continue;
				}
			soap_check_result(soap, "result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__awizoInsertAttachmentResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__awizoInsertAttachmentResponse, 0, sizeof(struct ns__awizoInsertAttachmentResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__awizoChangeTemplateInfo(struct soap *soap, struct ns__awizoChangeTemplateInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_long(soap, &a->id);
	a->emailTemplate = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__awizoChangeTemplateInfo(struct soap *soap, const struct ns__awizoChangeTemplateInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->id, SOAP_TYPE_long);
	soap_serialize_PointerTons__templateComplex(soap, &a->emailTemplate);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__awizoChangeTemplateInfo(struct soap *soap, const struct ns__awizoChangeTemplateInfo *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__awizoChangeTemplateInfo);
	if (soap_out_ns__awizoChangeTemplateInfo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__awizoChangeTemplateInfo(struct soap *soap, const char *tag, int id, const struct ns__awizoChangeTemplateInfo *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__awizoChangeTemplateInfo), type);
	soap_out_long(soap, "id", -1, &a->id, "");
	soap_out_PointerTons__templateComplex(soap, "emailTemplate", -1, &a->emailTemplate, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__awizoChangeTemplateInfo * SOAP_FMAC4 soap_get_ns__awizoChangeTemplateInfo(struct soap *soap, struct ns__awizoChangeTemplateInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__awizoChangeTemplateInfo(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__awizoChangeTemplateInfo * SOAP_FMAC4 soap_in_ns__awizoChangeTemplateInfo(struct soap *soap, const char *tag, struct ns__awizoChangeTemplateInfo *a, const char *type)
{
	short soap_flag_id = 1, soap_flag_emailTemplate = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__awizoChangeTemplateInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__awizoChangeTemplateInfo, sizeof(struct ns__awizoChangeTemplateInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__awizoChangeTemplateInfo(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_long(soap, "id", &a->id, "xsd:long"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_emailTemplate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons__templateComplex(soap, "emailTemplate", &a->emailTemplate, "ns:templateComplex"))
				{	soap_flag_emailTemplate--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__awizoChangeTemplateInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__awizoChangeTemplateInfo, 0, sizeof(struct ns__awizoChangeTemplateInfo), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__awizoChangeTemplateInfoResponse(struct soap *soap, struct ns__awizoChangeTemplateInfoResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__awizoChangeTemplateInfoResponse(struct soap *soap, const struct ns__awizoChangeTemplateInfoResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTolong(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__awizoChangeTemplateInfoResponse(struct soap *soap, const struct ns__awizoChangeTemplateInfoResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__awizoChangeTemplateInfoResponse);
	if (soap_out_ns__awizoChangeTemplateInfoResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__awizoChangeTemplateInfoResponse(struct soap *soap, const char *tag, int id, const struct ns__awizoChangeTemplateInfoResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__awizoChangeTemplateInfoResponse), type);
	if (a->result)
		soap_element_result(soap, "result");
	soap_out_PointerTolong(soap, "result", -1, &a->result, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__awizoChangeTemplateInfoResponse * SOAP_FMAC4 soap_get_ns__awizoChangeTemplateInfoResponse(struct soap *soap, struct ns__awizoChangeTemplateInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__awizoChangeTemplateInfoResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__awizoChangeTemplateInfoResponse * SOAP_FMAC4 soap_in_ns__awizoChangeTemplateInfoResponse(struct soap *soap, const char *tag, struct ns__awizoChangeTemplateInfoResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__awizoChangeTemplateInfoResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__awizoChangeTemplateInfoResponse, sizeof(struct ns__awizoChangeTemplateInfoResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__awizoChangeTemplateInfoResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTolong(soap, "result", &a->result, "xsd:long"))
				{	soap_flag_result--;
					continue;
				}
			soap_check_result(soap, "result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__awizoChangeTemplateInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__awizoChangeTemplateInfoResponse, 0, sizeof(struct ns__awizoChangeTemplateInfoResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__awizoDownloadTemplate(struct soap *soap, struct ns__awizoDownloadTemplate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_long(soap, &a->id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__awizoDownloadTemplate(struct soap *soap, const struct ns__awizoDownloadTemplate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->id, SOAP_TYPE_long);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__awizoDownloadTemplate(struct soap *soap, const struct ns__awizoDownloadTemplate *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__awizoDownloadTemplate);
	if (soap_out_ns__awizoDownloadTemplate(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__awizoDownloadTemplate(struct soap *soap, const char *tag, int id, const struct ns__awizoDownloadTemplate *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__awizoDownloadTemplate), type);
	soap_out_long(soap, "id", -1, &a->id, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__awizoDownloadTemplate * SOAP_FMAC4 soap_get_ns__awizoDownloadTemplate(struct soap *soap, struct ns__awizoDownloadTemplate *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__awizoDownloadTemplate(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__awizoDownloadTemplate * SOAP_FMAC4 soap_in_ns__awizoDownloadTemplate(struct soap *soap, const char *tag, struct ns__awizoDownloadTemplate *a, const char *type)
{
	short soap_flag_id = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__awizoDownloadTemplate *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__awizoDownloadTemplate, sizeof(struct ns__awizoDownloadTemplate), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__awizoDownloadTemplate(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_long(soap, "id", &a->id, "xsd:long"))
				{	soap_flag_id--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__awizoDownloadTemplate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__awizoDownloadTemplate, 0, sizeof(struct ns__awizoDownloadTemplate), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__awizoDownloadTemplateResponse(struct soap *soap, struct ns__awizoDownloadTemplateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->emailTemplate = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__awizoDownloadTemplateResponse(struct soap *soap, const struct ns__awizoDownloadTemplateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToPointerTons__templateComplex(soap, &a->emailTemplate);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__awizoDownloadTemplateResponse(struct soap *soap, const struct ns__awizoDownloadTemplateResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__awizoDownloadTemplateResponse);
	if (soap_out_ns__awizoDownloadTemplateResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__awizoDownloadTemplateResponse(struct soap *soap, const char *tag, int id, const struct ns__awizoDownloadTemplateResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__awizoDownloadTemplateResponse), type);
	if (a->emailTemplate)
		soap_element_result(soap, "emailTemplate");
	soap_out_PointerToPointerTons__templateComplex(soap, "emailTemplate", -1, &a->emailTemplate, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__awizoDownloadTemplateResponse * SOAP_FMAC4 soap_get_ns__awizoDownloadTemplateResponse(struct soap *soap, struct ns__awizoDownloadTemplateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__awizoDownloadTemplateResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__awizoDownloadTemplateResponse * SOAP_FMAC4 soap_in_ns__awizoDownloadTemplateResponse(struct soap *soap, const char *tag, struct ns__awizoDownloadTemplateResponse *a, const char *type)
{
	short soap_flag_emailTemplate = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__awizoDownloadTemplateResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__awizoDownloadTemplateResponse, sizeof(struct ns__awizoDownloadTemplateResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__awizoDownloadTemplateResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_emailTemplate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToPointerTons__templateComplex(soap, "emailTemplate", &a->emailTemplate, "ns:templateComplex"))
				{	soap_flag_emailTemplate--;
					continue;
				}
			soap_check_result(soap, "emailTemplate");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__awizoDownloadTemplateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__awizoDownloadTemplateResponse, 0, sizeof(struct ns__awizoDownloadTemplateResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__awizoDeleteTemplate(struct soap *soap, struct ns__awizoDeleteTemplate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_long(soap, &a->id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__awizoDeleteTemplate(struct soap *soap, const struct ns__awizoDeleteTemplate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->id, SOAP_TYPE_long);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__awizoDeleteTemplate(struct soap *soap, const struct ns__awizoDeleteTemplate *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__awizoDeleteTemplate);
	if (soap_out_ns__awizoDeleteTemplate(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__awizoDeleteTemplate(struct soap *soap, const char *tag, int id, const struct ns__awizoDeleteTemplate *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__awizoDeleteTemplate), type);
	soap_out_long(soap, "id", -1, &a->id, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__awizoDeleteTemplate * SOAP_FMAC4 soap_get_ns__awizoDeleteTemplate(struct soap *soap, struct ns__awizoDeleteTemplate *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__awizoDeleteTemplate(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__awizoDeleteTemplate * SOAP_FMAC4 soap_in_ns__awizoDeleteTemplate(struct soap *soap, const char *tag, struct ns__awizoDeleteTemplate *a, const char *type)
{
	short soap_flag_id = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__awizoDeleteTemplate *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__awizoDeleteTemplate, sizeof(struct ns__awizoDeleteTemplate), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__awizoDeleteTemplate(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_long(soap, "id", &a->id, "xsd:long"))
				{	soap_flag_id--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__awizoDeleteTemplate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__awizoDeleteTemplate, 0, sizeof(struct ns__awizoDeleteTemplate), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__awizoDeleteTemplateResponse(struct soap *soap, struct ns__awizoDeleteTemplateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__awizoDeleteTemplateResponse(struct soap *soap, const struct ns__awizoDeleteTemplateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTolong(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__awizoDeleteTemplateResponse(struct soap *soap, const struct ns__awizoDeleteTemplateResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__awizoDeleteTemplateResponse);
	if (soap_out_ns__awizoDeleteTemplateResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__awizoDeleteTemplateResponse(struct soap *soap, const char *tag, int id, const struct ns__awizoDeleteTemplateResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__awizoDeleteTemplateResponse), type);
	if (a->result)
		soap_element_result(soap, "result");
	soap_out_PointerTolong(soap, "result", -1, &a->result, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__awizoDeleteTemplateResponse * SOAP_FMAC4 soap_get_ns__awizoDeleteTemplateResponse(struct soap *soap, struct ns__awizoDeleteTemplateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__awizoDeleteTemplateResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__awizoDeleteTemplateResponse * SOAP_FMAC4 soap_in_ns__awizoDeleteTemplateResponse(struct soap *soap, const char *tag, struct ns__awizoDeleteTemplateResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__awizoDeleteTemplateResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__awizoDeleteTemplateResponse, sizeof(struct ns__awizoDeleteTemplateResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__awizoDeleteTemplateResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTolong(soap, "result", &a->result, "xsd:long"))
				{	soap_flag_result--;
					continue;
				}
			soap_check_result(soap, "result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__awizoDeleteTemplateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__awizoDeleteTemplateResponse, 0, sizeof(struct ns__awizoDeleteTemplateResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__awizoInsertTemplate(struct soap *soap, struct ns__awizoInsertTemplate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->emailTemplate = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__awizoInsertTemplate(struct soap *soap, const struct ns__awizoInsertTemplate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons__templateComplex(soap, &a->emailTemplate);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__awizoInsertTemplate(struct soap *soap, const struct ns__awizoInsertTemplate *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__awizoInsertTemplate);
	if (soap_out_ns__awizoInsertTemplate(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__awizoInsertTemplate(struct soap *soap, const char *tag, int id, const struct ns__awizoInsertTemplate *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__awizoInsertTemplate), type);
	soap_out_PointerTons__templateComplex(soap, "emailTemplate", -1, &a->emailTemplate, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__awizoInsertTemplate * SOAP_FMAC4 soap_get_ns__awizoInsertTemplate(struct soap *soap, struct ns__awizoInsertTemplate *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__awizoInsertTemplate(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__awizoInsertTemplate * SOAP_FMAC4 soap_in_ns__awizoInsertTemplate(struct soap *soap, const char *tag, struct ns__awizoInsertTemplate *a, const char *type)
{
	short soap_flag_emailTemplate = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__awizoInsertTemplate *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__awizoInsertTemplate, sizeof(struct ns__awizoInsertTemplate), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__awizoInsertTemplate(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_emailTemplate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons__templateComplex(soap, "emailTemplate", &a->emailTemplate, "ns:templateComplex"))
				{	soap_flag_emailTemplate--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__awizoInsertTemplate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__awizoInsertTemplate, 0, sizeof(struct ns__awizoInsertTemplate), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__awizoInsertTemplateResponse(struct soap *soap, struct ns__awizoInsertTemplateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__awizoInsertTemplateResponse(struct soap *soap, const struct ns__awizoInsertTemplateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTolong(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__awizoInsertTemplateResponse(struct soap *soap, const struct ns__awizoInsertTemplateResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__awizoInsertTemplateResponse);
	if (soap_out_ns__awizoInsertTemplateResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__awizoInsertTemplateResponse(struct soap *soap, const char *tag, int id, const struct ns__awizoInsertTemplateResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__awizoInsertTemplateResponse), type);
	if (a->result)
		soap_element_result(soap, "result");
	soap_out_PointerTolong(soap, "result", -1, &a->result, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__awizoInsertTemplateResponse * SOAP_FMAC4 soap_get_ns__awizoInsertTemplateResponse(struct soap *soap, struct ns__awizoInsertTemplateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__awizoInsertTemplateResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__awizoInsertTemplateResponse * SOAP_FMAC4 soap_in_ns__awizoInsertTemplateResponse(struct soap *soap, const char *tag, struct ns__awizoInsertTemplateResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__awizoInsertTemplateResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__awizoInsertTemplateResponse, sizeof(struct ns__awizoInsertTemplateResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__awizoInsertTemplateResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTolong(soap, "result", &a->result, "xsd:long"))
				{	soap_flag_result--;
					continue;
				}
			soap_check_result(soap, "result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__awizoInsertTemplateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__awizoInsertTemplateResponse, 0, sizeof(struct ns__awizoInsertTemplateResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__awizoGetSendersList(struct soap *soap, struct ns__awizoGetSendersList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__awizoGetSendersList(struct soap *soap, const struct ns__awizoGetSendersList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__awizoGetSendersList(struct soap *soap, const struct ns__awizoGetSendersList *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__awizoGetSendersList);
	if (soap_out_ns__awizoGetSendersList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__awizoGetSendersList(struct soap *soap, const char *tag, int id, const struct ns__awizoGetSendersList *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__awizoGetSendersList), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__awizoGetSendersList * SOAP_FMAC4 soap_get_ns__awizoGetSendersList(struct soap *soap, struct ns__awizoGetSendersList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__awizoGetSendersList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__awizoGetSendersList * SOAP_FMAC4 soap_in_ns__awizoGetSendersList(struct soap *soap, const char *tag, struct ns__awizoGetSendersList *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__awizoGetSendersList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__awizoGetSendersList, sizeof(struct ns__awizoGetSendersList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__awizoGetSendersList(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__awizoGetSendersList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__awizoGetSendersList, 0, sizeof(struct ns__awizoGetSendersList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__awizoGetSendersListResponse(struct soap *soap, struct ns__awizoGetSendersListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->senderList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__awizoGetSendersListResponse(struct soap *soap, const struct ns__awizoGetSendersListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToPointerTons__senderComplexList(soap, &a->senderList);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__awizoGetSendersListResponse(struct soap *soap, const struct ns__awizoGetSendersListResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__awizoGetSendersListResponse);
	if (soap_out_ns__awizoGetSendersListResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__awizoGetSendersListResponse(struct soap *soap, const char *tag, int id, const struct ns__awizoGetSendersListResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__awizoGetSendersListResponse), type);
	if (a->senderList)
		soap_element_result(soap, "senderList");
	soap_out_PointerToPointerTons__senderComplexList(soap, "senderList", -1, &a->senderList, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__awizoGetSendersListResponse * SOAP_FMAC4 soap_get_ns__awizoGetSendersListResponse(struct soap *soap, struct ns__awizoGetSendersListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__awizoGetSendersListResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__awizoGetSendersListResponse * SOAP_FMAC4 soap_in_ns__awizoGetSendersListResponse(struct soap *soap, const char *tag, struct ns__awizoGetSendersListResponse *a, const char *type)
{
	short soap_flag_senderList = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__awizoGetSendersListResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__awizoGetSendersListResponse, sizeof(struct ns__awizoGetSendersListResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__awizoGetSendersListResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_senderList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToPointerTons__senderComplexList(soap, "senderList", &a->senderList, "ns:senderComplexList"))
				{	soap_flag_senderList--;
					continue;
				}
			soap_check_result(soap, "senderList");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__awizoGetSendersListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__awizoGetSendersListResponse, 0, sizeof(struct ns__awizoGetSendersListResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__senderComplexList(struct soap *soap, struct ns__senderComplexList *a)
{
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__senderComplexList(struct soap *soap, struct ns__senderComplexList const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_ns__senderComplexList))
		for (i = 0; i < a->__size; i++)
		{	soap_embedded(soap, a->__ptr + i, SOAP_TYPE_ns__senderComplex);
			soap_serialize_ns__senderComplex(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__senderComplexList(struct soap *soap, const struct ns__senderComplexList *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_ns__senderComplexList);
	if (soap_out_ns__senderComplexList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__senderComplexList(struct soap *soap, const char *tag, int id, const struct ns__senderComplexList *a, const char *type)
{
	int i, n = a->__size;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ns__senderComplexList);
	if (id < 0)
		return soap->error;
	soap_element_begin_out(soap, tag, id, type);
	for (i = 0; i < n; i++)
	{
		soap_out_ns__senderComplex(soap, "item", -1, &a->__ptr[i], "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__senderComplexList * SOAP_FMAC4 soap_get_ns__senderComplexList(struct soap *soap, struct ns__senderComplexList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__senderComplexList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__senderComplexList * SOAP_FMAC4 soap_in_ns__senderComplexList(struct soap *soap, const char *tag, struct ns__senderComplexList *a, const char *type)
{	int i, j;
	struct ns__senderComplex *p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_array(soap, "ns:senderComplex") && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__senderComplexList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__senderComplexList, sizeof(struct ns__senderComplexList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__senderComplexList(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct ns__senderComplex *)soap_malloc(soap, sizeof(struct ns__senderComplex) * a->__size);
			for (i = 0; i < a->__size; i++)
				soap_default_ns__senderComplex(soap, a->__ptr+i);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_ns__senderComplex(soap, NULL, a->__ptr + i, "ns:senderComplex"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (struct ns__senderComplex *)soap_push_block(soap, sizeof(struct ns__senderComplex));
				if (!p)
					return NULL;
				soap_default_ns__senderComplex(soap, p);
				if (!soap_in_ns__senderComplex(soap, NULL, p, "ns:senderComplex"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (struct ns__senderComplex *)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__senderComplexList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__senderComplexList, 0, sizeof(struct ns__senderComplexList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__attachmentComplex(struct soap *soap, struct ns__attachmentComplex *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->id);
	soap_default_xsd__string(soap, &a->created);
	soap_default_xsd__string(soap, &a->deleted);
	soap_default_int(soap, &a->templateid);
	soap_default_xsd__string(soap, &a->filename);
	soap_default_xsd__string(soap, &a->mimetype);
	soap_default_xsd__string(soap, &a->disposition);
	soap_default_xsd__string(soap, &a->text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__attachmentComplex(struct soap *soap, const struct ns__attachmentComplex *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__string(soap, &a->created);
	soap_serialize_xsd__string(soap, &a->deleted);
	soap_serialize_xsd__string(soap, &a->filename);
	soap_serialize_xsd__string(soap, &a->mimetype);
	soap_serialize_xsd__string(soap, &a->disposition);
	soap_serialize_xsd__string(soap, &a->text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__attachmentComplex(struct soap *soap, const struct ns__attachmentComplex *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__attachmentComplex);
	if (soap_out_ns__attachmentComplex(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__attachmentComplex(struct soap *soap, const char *tag, int id, const struct ns__attachmentComplex *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__attachmentComplex), type);
	soap_out_int(soap, "id", -1, &a->id, "");
	soap_out_xsd__string(soap, "created", -1, &a->created, "");
	soap_out_xsd__string(soap, "deleted", -1, &a->deleted, "");
	soap_out_int(soap, "templateid", -1, &a->templateid, "");
	soap_out_xsd__string(soap, "filename", -1, &a->filename, "");
	soap_out_xsd__string(soap, "mimetype", -1, &a->mimetype, "");
	soap_out_xsd__string(soap, "disposition", -1, &a->disposition, "");
	soap_out_xsd__string(soap, "text", -1, &a->text, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__attachmentComplex * SOAP_FMAC4 soap_get_ns__attachmentComplex(struct soap *soap, struct ns__attachmentComplex *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__attachmentComplex(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__attachmentComplex * SOAP_FMAC4 soap_in_ns__attachmentComplex(struct soap *soap, const char *tag, struct ns__attachmentComplex *a, const char *type)
{
	short soap_flag_id = 1, soap_flag_created = 1, soap_flag_deleted = 1, soap_flag_templateid = 1, soap_flag_filename = 1, soap_flag_mimetype = 1, soap_flag_disposition = 1, soap_flag_text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__attachmentComplex *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__attachmentComplex, sizeof(struct ns__attachmentComplex), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__attachmentComplex(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "id", &a->id, "xsd:int"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_created && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "created", &a->created, "xsd:string"))
				{	soap_flag_created--;
					continue;
				}
			if (soap_flag_deleted && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "deleted", &a->deleted, "xsd:string"))
				{	soap_flag_deleted--;
					continue;
				}
			if (soap_flag_templateid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "templateid", &a->templateid, "xsd:int"))
				{	soap_flag_templateid--;
					continue;
				}
			if (soap_flag_filename && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "filename", &a->filename, "xsd:string"))
				{	soap_flag_filename--;
					continue;
				}
			if (soap_flag_mimetype && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "mimetype", &a->mimetype, "xsd:string"))
				{	soap_flag_mimetype--;
					continue;
				}
			if (soap_flag_disposition && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "disposition", &a->disposition, "xsd:string"))
				{	soap_flag_disposition--;
					continue;
				}
			if (soap_flag_text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "text", &a->text, "xsd:string"))
				{	soap_flag_text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__attachmentComplex *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__attachmentComplex, 0, sizeof(struct ns__attachmentComplex), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0 || soap_flag_templateid > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__templateComplex(struct soap *soap, struct ns__templateComplex *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->id);
	soap_default_xsd__string(soap, &a->created);
	soap_default_xsd__string(soap, &a->deleted);
	soap_default_int(soap, &a->messagesenderid);
	soap_default_xsd__string(soap, &a->name);
	soap_default_xsd__string(soap, &a->lang);
	soap_default_xsd__string(soap, &a->version);
	soap_default_xsd__string(soap, &a->description);
	soap_default_xsd__string(soap, &a->xsltohtml);
	soap_default_xsd__string(soap, &a->xsltotext);
	soap_default_int(soap, &a->sign);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__templateComplex(struct soap *soap, const struct ns__templateComplex *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__string(soap, &a->created);
	soap_serialize_xsd__string(soap, &a->deleted);
	soap_serialize_xsd__string(soap, &a->name);
	soap_serialize_xsd__string(soap, &a->lang);
	soap_serialize_xsd__string(soap, &a->version);
	soap_serialize_xsd__string(soap, &a->description);
	soap_serialize_xsd__string(soap, &a->xsltohtml);
	soap_serialize_xsd__string(soap, &a->xsltotext);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__templateComplex(struct soap *soap, const struct ns__templateComplex *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__templateComplex);
	if (soap_out_ns__templateComplex(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__templateComplex(struct soap *soap, const char *tag, int id, const struct ns__templateComplex *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__templateComplex), type);
	soap_out_int(soap, "id", -1, &a->id, "");
	soap_out_xsd__string(soap, "created", -1, &a->created, "");
	soap_out_xsd__string(soap, "deleted", -1, &a->deleted, "");
	soap_out_int(soap, "messagesenderid", -1, &a->messagesenderid, "");
	soap_out_xsd__string(soap, "name", -1, &a->name, "");
	soap_out_xsd__string(soap, "lang", -1, &a->lang, "");
	soap_out_xsd__string(soap, "version", -1, &a->version, "");
	soap_out_xsd__string(soap, "description", -1, &a->description, "");
	soap_out_xsd__string(soap, "xsltohtml", -1, &a->xsltohtml, "");
	soap_out_xsd__string(soap, "xsltotext", -1, &a->xsltotext, "");
	soap_out_int(soap, "sign", -1, &a->sign, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__templateComplex * SOAP_FMAC4 soap_get_ns__templateComplex(struct soap *soap, struct ns__templateComplex *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__templateComplex(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__templateComplex * SOAP_FMAC4 soap_in_ns__templateComplex(struct soap *soap, const char *tag, struct ns__templateComplex *a, const char *type)
{
	short soap_flag_id = 1, soap_flag_created = 1, soap_flag_deleted = 1, soap_flag_messagesenderid = 1, soap_flag_name = 1, soap_flag_lang = 1, soap_flag_version = 1, soap_flag_description = 1, soap_flag_xsltohtml = 1, soap_flag_xsltotext = 1, soap_flag_sign = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__templateComplex *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__templateComplex, sizeof(struct ns__templateComplex), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__templateComplex(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "id", &a->id, "xsd:int"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_created && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "created", &a->created, "xsd:string"))
				{	soap_flag_created--;
					continue;
				}
			if (soap_flag_deleted && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "deleted", &a->deleted, "xsd:string"))
				{	soap_flag_deleted--;
					continue;
				}
			if (soap_flag_messagesenderid && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "messagesenderid", &a->messagesenderid, "xsd:int"))
				{	soap_flag_messagesenderid--;
					continue;
				}
			if (soap_flag_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "name", &a->name, "xsd:string"))
				{	soap_flag_name--;
					continue;
				}
			if (soap_flag_lang && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "lang", &a->lang, "xsd:string"))
				{	soap_flag_lang--;
					continue;
				}
			if (soap_flag_version && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "version", &a->version, "xsd:string"))
				{	soap_flag_version--;
					continue;
				}
			if (soap_flag_description && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "description", &a->description, "xsd:string"))
				{	soap_flag_description--;
					continue;
				}
			if (soap_flag_xsltohtml && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "xsltohtml", &a->xsltohtml, "xsd:string"))
				{	soap_flag_xsltohtml--;
					continue;
				}
			if (soap_flag_xsltotext && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "xsltotext", &a->xsltotext, "xsd:string"))
				{	soap_flag_xsltotext--;
					continue;
				}
			if (soap_flag_sign && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "sign", &a->sign, "xsd:int"))
				{	soap_flag_sign--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__templateComplex *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__templateComplex, 0, sizeof(struct ns__templateComplex), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0 || soap_flag_messagesenderid > 0 || soap_flag_sign > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__senderComplex(struct soap *soap, struct ns__senderComplex *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->id);
	soap_default_xsd__string(soap, &a->name);
	soap_default_xsd__string(soap, &a->email);
	soap_default_xsd__string(soap, &a->created);
	soap_default_xsd__string(soap, &a->deleted);
	soap_default_xsd__string(soap, &a->smtpaddr);
	soap_default_xsd__string(soap, &a->smtpport);
	soap_default_xsd__string(soap, &a->smtpuser);
	soap_default_xsd__string(soap, &a->smtppassword);
	soap_default_xsd__string(soap, &a->pfxfile);
	soap_default_xsd__string(soap, &a->pfxpin);
	soap_default_xsd__string(soap, &a->maximagesize);
	soap_default_xsd__string(soap, &a->csvdir);
	soap_default_xsd__string(soap, &a->csvseparator);
	soap_default_int(soap, &a->awizoaction);
	soap_default_int(soap, &a->allowimageabsent);
	soap_default_xsd__string(soap, &a->smsapiurl);
	soap_default_xsd__string(soap, &a->smsapierror);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__senderComplex(struct soap *soap, const struct ns__senderComplex *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__string(soap, &a->name);
	soap_serialize_xsd__string(soap, &a->email);
	soap_serialize_xsd__string(soap, &a->created);
	soap_serialize_xsd__string(soap, &a->deleted);
	soap_serialize_xsd__string(soap, &a->smtpaddr);
	soap_serialize_xsd__string(soap, &a->smtpport);
	soap_serialize_xsd__string(soap, &a->smtpuser);
	soap_serialize_xsd__string(soap, &a->smtppassword);
	soap_serialize_xsd__string(soap, &a->pfxfile);
	soap_serialize_xsd__string(soap, &a->pfxpin);
	soap_serialize_xsd__string(soap, &a->maximagesize);
	soap_serialize_xsd__string(soap, &a->csvdir);
	soap_serialize_xsd__string(soap, &a->csvseparator);
	soap_serialize_xsd__string(soap, &a->smsapiurl);
	soap_serialize_xsd__string(soap, &a->smsapierror);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__senderComplex(struct soap *soap, const struct ns__senderComplex *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__senderComplex);
	if (soap_out_ns__senderComplex(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__senderComplex(struct soap *soap, const char *tag, int id, const struct ns__senderComplex *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__senderComplex), type);
	soap_out_int(soap, "id", -1, &a->id, "");
	soap_out_xsd__string(soap, "name", -1, &a->name, "");
	soap_out_xsd__string(soap, "email", -1, &a->email, "");
	soap_out_xsd__string(soap, "created", -1, &a->created, "");
	soap_out_xsd__string(soap, "deleted", -1, &a->deleted, "");
	soap_out_xsd__string(soap, "smtpaddr", -1, &a->smtpaddr, "");
	soap_out_xsd__string(soap, "smtpport", -1, &a->smtpport, "");
	soap_out_xsd__string(soap, "smtpuser", -1, &a->smtpuser, "");
	soap_out_xsd__string(soap, "smtppassword", -1, &a->smtppassword, "");
	soap_out_xsd__string(soap, "pfxfile", -1, &a->pfxfile, "");
	soap_out_xsd__string(soap, "pfxpin", -1, &a->pfxpin, "");
	soap_out_xsd__string(soap, "maximagesize", -1, &a->maximagesize, "");
	soap_out_xsd__string(soap, "csvdir", -1, &a->csvdir, "");
	soap_out_xsd__string(soap, "csvseparator", -1, &a->csvseparator, "");
	soap_out_int(soap, "awizoaction", -1, &a->awizoaction, "");
	soap_out_int(soap, "allowimageabsent", -1, &a->allowimageabsent, "");
	soap_out_xsd__string(soap, "smsapiurl", -1, &a->smsapiurl, "");
	soap_out_xsd__string(soap, "smsapierror", -1, &a->smsapierror, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__senderComplex * SOAP_FMAC4 soap_get_ns__senderComplex(struct soap *soap, struct ns__senderComplex *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__senderComplex(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__senderComplex * SOAP_FMAC4 soap_in_ns__senderComplex(struct soap *soap, const char *tag, struct ns__senderComplex *a, const char *type)
{
	short soap_flag_id = 1, soap_flag_name = 1, soap_flag_email = 1, soap_flag_created = 1, soap_flag_deleted = 1, soap_flag_smtpaddr = 1, soap_flag_smtpport = 1, soap_flag_smtpuser = 1, soap_flag_smtppassword = 1, soap_flag_pfxfile = 1, soap_flag_pfxpin = 1, soap_flag_maximagesize = 1, soap_flag_csvdir = 1, soap_flag_csvseparator = 1, soap_flag_awizoaction = 1, soap_flag_allowimageabsent = 1, soap_flag_smsapiurl = 1, soap_flag_smsapierror = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__senderComplex *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__senderComplex, sizeof(struct ns__senderComplex), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__senderComplex(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "id", &a->id, "xsd:int"))
				{	soap_flag_id--;
					continue;
				}
			if (soap_flag_name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "name", &a->name, "xsd:string"))
				{	soap_flag_name--;
					continue;
				}
			if (soap_flag_email && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "email", &a->email, "xsd:string"))
				{	soap_flag_email--;
					continue;
				}
			if (soap_flag_created && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "created", &a->created, "xsd:string"))
				{	soap_flag_created--;
					continue;
				}
			if (soap_flag_deleted && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "deleted", &a->deleted, "xsd:string"))
				{	soap_flag_deleted--;
					continue;
				}
			if (soap_flag_smtpaddr && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "smtpaddr", &a->smtpaddr, "xsd:string"))
				{	soap_flag_smtpaddr--;
					continue;
				}
			if (soap_flag_smtpport && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "smtpport", &a->smtpport, "xsd:string"))
				{	soap_flag_smtpport--;
					continue;
				}
			if (soap_flag_smtpuser && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "smtpuser", &a->smtpuser, "xsd:string"))
				{	soap_flag_smtpuser--;
					continue;
				}
			if (soap_flag_smtppassword && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "smtppassword", &a->smtppassword, "xsd:string"))
				{	soap_flag_smtppassword--;
					continue;
				}
			if (soap_flag_pfxfile && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "pfxfile", &a->pfxfile, "xsd:string"))
				{	soap_flag_pfxfile--;
					continue;
				}
			if (soap_flag_pfxpin && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "pfxpin", &a->pfxpin, "xsd:string"))
				{	soap_flag_pfxpin--;
					continue;
				}
			if (soap_flag_maximagesize && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "maximagesize", &a->maximagesize, "xsd:string"))
				{	soap_flag_maximagesize--;
					continue;
				}
			if (soap_flag_csvdir && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "csvdir", &a->csvdir, "xsd:string"))
				{	soap_flag_csvdir--;
					continue;
				}
			if (soap_flag_csvseparator && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "csvseparator", &a->csvseparator, "xsd:string"))
				{	soap_flag_csvseparator--;
					continue;
				}
			if (soap_flag_awizoaction && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "awizoaction", &a->awizoaction, "xsd:int"))
				{	soap_flag_awizoaction--;
					continue;
				}
			if (soap_flag_allowimageabsent && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "allowimageabsent", &a->allowimageabsent, "xsd:int"))
				{	soap_flag_allowimageabsent--;
					continue;
				}
			if (soap_flag_smsapiurl && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "smsapiurl", &a->smsapiurl, "xsd:string"))
				{	soap_flag_smsapiurl--;
					continue;
				}
			if (soap_flag_smsapierror && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "smsapierror", &a->smsapierror, "xsd:string"))
				{	soap_flag_smsapierror--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__senderComplex *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__senderComplex, 0, sizeof(struct ns__senderComplex), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id > 0 || soap_flag_awizoaction > 0 || soap_flag_allowimageabsent > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__dateTimeComplexList(struct soap *soap, struct ns__dateTimeComplexList *a)
{
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__dateTimeComplexList(struct soap *soap, struct ns__dateTimeComplexList const*a)
{
	int i;
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_ns__dateTimeComplexList))
		for (i = 0; i < a->__size; i++)
		{	soap_embedded(soap, a->__ptr + i, SOAP_TYPE_ns_dateTime);
			soap_serialize_ns_dateTime(soap, a->__ptr + i);
		}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__dateTimeComplexList(struct soap *soap, const struct ns__dateTimeComplexList *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_ns__dateTimeComplexList);
	if (soap_out_ns__dateTimeComplexList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__dateTimeComplexList(struct soap *soap, const char *tag, int id, const struct ns__dateTimeComplexList *a, const char *type)
{
	int i, n = a->__size;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ns__dateTimeComplexList);
	if (id < 0)
		return soap->error;
	soap_element_begin_out(soap, tag, id, type);
	for (i = 0; i < n; i++)
	{
		soap_out_ns_dateTime(soap, "item", -1, &a->__ptr[i], "");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__dateTimeComplexList * SOAP_FMAC4 soap_get_ns__dateTimeComplexList(struct soap *soap, struct ns__dateTimeComplexList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__dateTimeComplexList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__dateTimeComplexList * SOAP_FMAC4 soap_in_ns__dateTimeComplexList(struct soap *soap, const char *tag, struct ns__dateTimeComplexList *a, const char *type)
{	int i, j;
	struct ns_dateTime *p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_array(soap, "ns-dateTime") && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct ns__dateTimeComplexList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__dateTimeComplexList, sizeof(struct ns__dateTimeComplexList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__dateTimeComplexList(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (struct ns_dateTime *)soap_malloc(soap, sizeof(struct ns_dateTime) * a->__size);
			for (i = 0; i < a->__size; i++)
				soap_default_ns_dateTime(soap, a->__ptr+i);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_ns_dateTime(soap, NULL, a->__ptr + i, "ns-dateTime"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (struct ns_dateTime *)soap_push_block(soap, sizeof(struct ns_dateTime));
				if (!p)
					return NULL;
				soap_default_ns_dateTime(soap, p);
				if (!soap_in_ns_dateTime(soap, NULL, p, "ns-dateTime"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (struct ns_dateTime *)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__dateTimeComplexList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__dateTimeComplexList, 0, sizeof(struct ns__dateTimeComplexList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns_dateTime(struct soap *soap, struct ns_dateTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__string(soap, &a->dateTime);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns_dateTime(struct soap *soap, const struct ns_dateTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__string(soap, &a->dateTime);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns_dateTime(struct soap *soap, const struct ns_dateTime *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns_dateTime);
	if (soap_out_ns_dateTime(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns_dateTime(struct soap *soap, const char *tag, int id, const struct ns_dateTime *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns_dateTime), type);
	soap_out_xsd__string(soap, "dateTime", -1, &a->dateTime, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns_dateTime * SOAP_FMAC4 soap_get_ns_dateTime(struct soap *soap, struct ns_dateTime *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns_dateTime(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns_dateTime * SOAP_FMAC4 soap_in_ns_dateTime(struct soap *soap, const char *tag, struct ns_dateTime *a, const char *type)
{
	short soap_flag_dateTime = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns_dateTime *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns_dateTime, sizeof(struct ns_dateTime), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns_dateTime(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_dateTime && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__string(soap, "dateTime", &a->dateTime, "xsd:string"))
				{	soap_flag_dateTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns_dateTime *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns_dateTime, 0, sizeof(struct ns_dateTime), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__awizoMessage(struct soap *soap, struct ns__awizoMessage *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->value = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__awizoMessage(struct soap *soap, const struct ns__awizoMessage *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__base64Binary(soap, &a->value);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__awizoMessage(struct soap *soap, const struct ns__awizoMessage *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__awizoMessage);
	if (soap_out_ns__awizoMessage(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__awizoMessage(struct soap *soap, const char *tag, int id, const struct ns__awizoMessage *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__awizoMessage), type);
	soap_out_PointerToxsd__base64Binary(soap, "value", -1, &a->value, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__awizoMessage * SOAP_FMAC4 soap_get_ns__awizoMessage(struct soap *soap, struct ns__awizoMessage *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__awizoMessage(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__awizoMessage * SOAP_FMAC4 soap_in_ns__awizoMessage(struct soap *soap, const char *tag, struct ns__awizoMessage *a, const char *type)
{
	short soap_flag_value = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__awizoMessage *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__awizoMessage, sizeof(struct ns__awizoMessage), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__awizoMessage(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_value && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__base64Binary(soap, "value", &a->value, "xsd:base64Binary"))
				{	soap_flag_value--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__awizoMessage *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__awizoMessage, 0, sizeof(struct ns__awizoMessage), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns__awizoConfig(struct soap *soap, struct ns__awizoConfig *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->smtpAddr);
	soap_default_string(soap, &a->smtpPort);
	soap_default_string(soap, &a->smtpUser);
	soap_default_string(soap, &a->smtpPswd);
	soap_default_string(soap, &a->awizoSuccess);
	soap_default_string(soap, &a->awizoFailed);
	soap_default_string(soap, &a->allowImageAbsent);
	soap_default_string(soap, &a->csvDir);
	soap_default_string(soap, &a->csvSeparator);
	soap_default_string(soap, &a->pfxfile);
	soap_default_string(soap, &a->pfxPIN);
	soap_default_string(soap, &a->maxImageSize);
	soap_default_string(soap, &a->awizoAction);
	soap_default_string(soap, &a->mailqueue);
	soap_default_string(soap, &a->maxcachesize);
	soap_default_string(soap, &a->maxmailqueue);
	soap_default_string(soap, &a->sendingtime);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns__awizoConfig(struct soap *soap, const struct ns__awizoConfig *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->smtpAddr);
	soap_serialize_string(soap, &a->smtpPort);
	soap_serialize_string(soap, &a->smtpUser);
	soap_serialize_string(soap, &a->smtpPswd);
	soap_serialize_string(soap, &a->awizoSuccess);
	soap_serialize_string(soap, &a->awizoFailed);
	soap_serialize_string(soap, &a->allowImageAbsent);
	soap_serialize_string(soap, &a->csvDir);
	soap_serialize_string(soap, &a->csvSeparator);
	soap_serialize_string(soap, &a->pfxfile);
	soap_serialize_string(soap, &a->pfxPIN);
	soap_serialize_string(soap, &a->maxImageSize);
	soap_serialize_string(soap, &a->awizoAction);
	soap_serialize_string(soap, &a->mailqueue);
	soap_serialize_string(soap, &a->maxcachesize);
	soap_serialize_string(soap, &a->maxmailqueue);
	soap_serialize_string(soap, &a->sendingtime);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns__awizoConfig(struct soap *soap, const struct ns__awizoConfig *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns__awizoConfig);
	if (soap_out_ns__awizoConfig(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns__awizoConfig(struct soap *soap, const char *tag, int id, const struct ns__awizoConfig *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns__awizoConfig), type);
	soap_out_string(soap, "smtpAddr", -1, &a->smtpAddr, "");
	soap_out_string(soap, "smtpPort", -1, &a->smtpPort, "");
	soap_out_string(soap, "smtpUser", -1, &a->smtpUser, "");
	soap_out_string(soap, "smtpPswd", -1, &a->smtpPswd, "");
	soap_out_string(soap, "awizoSuccess", -1, &a->awizoSuccess, "");
	soap_out_string(soap, "awizoFailed", -1, &a->awizoFailed, "");
	soap_out_string(soap, "allowImageAbsent", -1, &a->allowImageAbsent, "");
	soap_out_string(soap, "csvDir", -1, &a->csvDir, "");
	soap_out_string(soap, "csvSeparator", -1, &a->csvSeparator, "");
	soap_out_string(soap, "pfxfile", -1, &a->pfxfile, "");
	soap_out_string(soap, "pfxPIN", -1, &a->pfxPIN, "");
	soap_out_string(soap, "maxImageSize", -1, &a->maxImageSize, "");
	soap_out_string(soap, "awizoAction", -1, &a->awizoAction, "");
	soap_out_string(soap, "mailqueue", -1, &a->mailqueue, "");
	soap_out_string(soap, "maxcachesize", -1, &a->maxcachesize, "");
	soap_out_string(soap, "maxmailqueue", -1, &a->maxmailqueue, "");
	soap_out_string(soap, "sendingtime", -1, &a->sendingtime, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct ns__awizoConfig * SOAP_FMAC4 soap_get_ns__awizoConfig(struct soap *soap, struct ns__awizoConfig *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns__awizoConfig(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__awizoConfig * SOAP_FMAC4 soap_in_ns__awizoConfig(struct soap *soap, const char *tag, struct ns__awizoConfig *a, const char *type)
{
	short soap_flag_smtpAddr = 1, soap_flag_smtpPort = 1, soap_flag_smtpUser = 1, soap_flag_smtpPswd = 1, soap_flag_awizoSuccess = 1, soap_flag_awizoFailed = 1, soap_flag_allowImageAbsent = 1, soap_flag_csvDir = 1, soap_flag_csvSeparator = 1, soap_flag_pfxfile = 1, soap_flag_pfxPIN = 1, soap_flag_maxImageSize = 1, soap_flag_awizoAction = 1, soap_flag_mailqueue = 1, soap_flag_maxcachesize = 1, soap_flag_maxmailqueue = 1, soap_flag_sendingtime = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns__awizoConfig *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns__awizoConfig, sizeof(struct ns__awizoConfig), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns__awizoConfig(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_smtpAddr && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "smtpAddr", &a->smtpAddr, "xsd:string"))
				{	soap_flag_smtpAddr--;
					continue;
				}
			if (soap_flag_smtpPort && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "smtpPort", &a->smtpPort, "xsd:string"))
				{	soap_flag_smtpPort--;
					continue;
				}
			if (soap_flag_smtpUser && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "smtpUser", &a->smtpUser, "xsd:string"))
				{	soap_flag_smtpUser--;
					continue;
				}
			if (soap_flag_smtpPswd && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "smtpPswd", &a->smtpPswd, "xsd:string"))
				{	soap_flag_smtpPswd--;
					continue;
				}
			if (soap_flag_awizoSuccess && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "awizoSuccess", &a->awizoSuccess, "xsd:string"))
				{	soap_flag_awizoSuccess--;
					continue;
				}
			if (soap_flag_awizoFailed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "awizoFailed", &a->awizoFailed, "xsd:string"))
				{	soap_flag_awizoFailed--;
					continue;
				}
			if (soap_flag_allowImageAbsent && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "allowImageAbsent", &a->allowImageAbsent, "xsd:string"))
				{	soap_flag_allowImageAbsent--;
					continue;
				}
			if (soap_flag_csvDir && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "csvDir", &a->csvDir, "xsd:string"))
				{	soap_flag_csvDir--;
					continue;
				}
			if (soap_flag_csvSeparator && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "csvSeparator", &a->csvSeparator, "xsd:string"))
				{	soap_flag_csvSeparator--;
					continue;
				}
			if (soap_flag_pfxfile && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "pfxfile", &a->pfxfile, "xsd:string"))
				{	soap_flag_pfxfile--;
					continue;
				}
			if (soap_flag_pfxPIN && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "pfxPIN", &a->pfxPIN, "xsd:string"))
				{	soap_flag_pfxPIN--;
					continue;
				}
			if (soap_flag_maxImageSize && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "maxImageSize", &a->maxImageSize, "xsd:string"))
				{	soap_flag_maxImageSize--;
					continue;
				}
			if (soap_flag_awizoAction && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "awizoAction", &a->awizoAction, "xsd:string"))
				{	soap_flag_awizoAction--;
					continue;
				}
			if (soap_flag_mailqueue && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "mailqueue", &a->mailqueue, "xsd:string"))
				{	soap_flag_mailqueue--;
					continue;
				}
			if (soap_flag_maxcachesize && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "maxcachesize", &a->maxcachesize, "xsd:string"))
				{	soap_flag_maxcachesize--;
					continue;
				}
			if (soap_flag_maxmailqueue && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "maxmailqueue", &a->maxmailqueue, "xsd:string"))
				{	soap_flag_maxmailqueue--;
					continue;
				}
			if (soap_flag_sendingtime && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "sendingtime", &a->sendingtime, "xsd:string"))
				{	soap_flag_sendingtime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns__awizoConfig *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns__awizoConfig, 0, sizeof(struct ns__awizoConfig), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__base64Binary(struct soap *soap, struct xsd__base64Binary *a)
{
	a->__size = 0;
	a->__ptr = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__base64Binary(struct soap *soap, struct xsd__base64Binary const*a)
{
	if (a->__ptr)
		soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE_xsd__base64Binary);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__base64Binary(struct soap *soap, const struct xsd__base64Binary *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE_xsd__base64Binary);
	if (soap_out_xsd__base64Binary(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__base64Binary(struct soap *soap, const char *tag, int id, const struct xsd__base64Binary *a, const char *type)
{
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_xsd__base64Binary);
	if (id < 0)
		return soap->error;
	soap_element_begin_out(soap, tag, id, type);
	soap_putbase64(soap, a->__ptr, a->__size);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct xsd__base64Binary * SOAP_FMAC4 soap_get_xsd__base64Binary(struct soap *soap, struct xsd__base64Binary *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__base64Binary(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct xsd__base64Binary * SOAP_FMAC4 soap_in_xsd__base64Binary(struct soap *soap, const char *tag, struct xsd__base64Binary *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":base64Binary") && soap_match_tag(soap, soap->type, ":base64"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct xsd__base64Binary *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__base64Binary, sizeof(struct xsd__base64Binary), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xsd__base64Binary(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__ptr = soap_getbase64(soap, &a->__size, 0);
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xsd__base64Binary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xsd__base64Binary, 0, sizeof(struct xsd__base64Binary), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons__dateTimeComplexList(struct soap *soap, struct ns__dateTimeComplexList *const*a)
{
	if (*a)
		soap_serialize_ns__dateTimeComplexList(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons__dateTimeComplexList(struct soap *soap, struct ns__dateTimeComplexList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons__dateTimeComplexList);
	if (soap_out_PointerTons__dateTimeComplexList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons__dateTimeComplexList(struct soap *soap, const char *tag, int id, struct ns__dateTimeComplexList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ns__dateTimeComplexList);
	if (id < 0)
		return soap->error;
	return soap_out_ns__dateTimeComplexList(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns__dateTimeComplexList ** SOAP_FMAC4 soap_get_PointerTons__dateTimeComplexList(struct soap *soap, struct ns__dateTimeComplexList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons__dateTimeComplexList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__dateTimeComplexList ** SOAP_FMAC4 soap_in_PointerTons__dateTimeComplexList(struct soap *soap, const char *tag, struct ns__dateTimeComplexList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns__dateTimeComplexList **)soap_malloc(soap, sizeof(struct ns__dateTimeComplexList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns__dateTimeComplexList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns__dateTimeComplexList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns__dateTimeComplexList, sizeof(struct ns__dateTimeComplexList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons__awizoConfig(struct soap *soap, struct ns__awizoConfig *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns__awizoConfig))
		soap_serialize_ns__awizoConfig(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons__awizoConfig(struct soap *soap, struct ns__awizoConfig *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons__awizoConfig);
	if (soap_out_PointerTons__awizoConfig(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons__awizoConfig(struct soap *soap, const char *tag, int id, struct ns__awizoConfig *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns__awizoConfig);
	if (id < 0)
		return soap->error;
	return soap_out_ns__awizoConfig(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns__awizoConfig ** SOAP_FMAC4 soap_get_PointerTons__awizoConfig(struct soap *soap, struct ns__awizoConfig **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons__awizoConfig(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__awizoConfig ** SOAP_FMAC4 soap_in_PointerTons__awizoConfig(struct soap *soap, const char *tag, struct ns__awizoConfig **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns__awizoConfig **)soap_malloc(soap, sizeof(struct ns__awizoConfig *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns__awizoConfig(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns__awizoConfig **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns__awizoConfig, sizeof(struct ns__awizoConfig), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostring(struct soap *soap, char **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_string))
		soap_serialize_string(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostring(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostring);
	if (soap_out_PointerTostring(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostring(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_string);
	if (id < 0)
		return soap->error;
	return soap_out_string(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTostring(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostring(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerTostring(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_string, sizeof(char *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons__awizoMessage(struct soap *soap, struct ns__awizoMessage *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns__awizoMessage))
		soap_serialize_ns__awizoMessage(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons__awizoMessage(struct soap *soap, struct ns__awizoMessage *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons__awizoMessage);
	if (soap_out_PointerTons__awizoMessage(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons__awizoMessage(struct soap *soap, const char *tag, int id, struct ns__awizoMessage *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns__awizoMessage);
	if (id < 0)
		return soap->error;
	return soap_out_ns__awizoMessage(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns__awizoMessage ** SOAP_FMAC4 soap_get_PointerTons__awizoMessage(struct soap *soap, struct ns__awizoMessage **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons__awizoMessage(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__awizoMessage ** SOAP_FMAC4 soap_in_PointerTons__awizoMessage(struct soap *soap, const char *tag, struct ns__awizoMessage **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns__awizoMessage **)soap_malloc(soap, sizeof(struct ns__awizoMessage *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns__awizoMessage(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns__awizoMessage **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns__awizoMessage, sizeof(struct ns__awizoMessage), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons__senderComplex(struct soap *soap, struct ns__senderComplex **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons__senderComplex))
		soap_serialize_PointerTons__senderComplex(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons__senderComplex(struct soap *soap, struct ns__senderComplex **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons__senderComplex);
	if (soap_out_PointerToPointerTons__senderComplex(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons__senderComplex(struct soap *soap, const char *tag, int id, struct ns__senderComplex **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons__senderComplex);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons__senderComplex(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns__senderComplex *** SOAP_FMAC4 soap_get_PointerToPointerTons__senderComplex(struct soap *soap, struct ns__senderComplex ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons__senderComplex(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__senderComplex *** SOAP_FMAC4 soap_in_PointerToPointerTons__senderComplex(struct soap *soap, const char *tag, struct ns__senderComplex ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns__senderComplex ***)soap_malloc(soap, sizeof(struct ns__senderComplex **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons__senderComplex(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns__senderComplex ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons__senderComplex, sizeof(struct ns__senderComplex *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons__attachmentComplex(struct soap *soap, struct ns__attachmentComplex **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons__attachmentComplex))
		soap_serialize_PointerTons__attachmentComplex(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons__attachmentComplex(struct soap *soap, struct ns__attachmentComplex **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons__attachmentComplex);
	if (soap_out_PointerToPointerTons__attachmentComplex(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons__attachmentComplex(struct soap *soap, const char *tag, int id, struct ns__attachmentComplex **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons__attachmentComplex);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons__attachmentComplex(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns__attachmentComplex *** SOAP_FMAC4 soap_get_PointerToPointerTons__attachmentComplex(struct soap *soap, struct ns__attachmentComplex ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons__attachmentComplex(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__attachmentComplex *** SOAP_FMAC4 soap_in_PointerToPointerTons__attachmentComplex(struct soap *soap, const char *tag, struct ns__attachmentComplex ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns__attachmentComplex ***)soap_malloc(soap, sizeof(struct ns__attachmentComplex **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons__attachmentComplex(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns__attachmentComplex ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons__attachmentComplex, sizeof(struct ns__attachmentComplex *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons__attachmentComplex(struct soap *soap, struct ns__attachmentComplex *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns__attachmentComplex))
		soap_serialize_ns__attachmentComplex(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons__attachmentComplex(struct soap *soap, struct ns__attachmentComplex *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons__attachmentComplex);
	if (soap_out_PointerTons__attachmentComplex(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons__attachmentComplex(struct soap *soap, const char *tag, int id, struct ns__attachmentComplex *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns__attachmentComplex);
	if (id < 0)
		return soap->error;
	return soap_out_ns__attachmentComplex(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns__attachmentComplex ** SOAP_FMAC4 soap_get_PointerTons__attachmentComplex(struct soap *soap, struct ns__attachmentComplex **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons__attachmentComplex(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__attachmentComplex ** SOAP_FMAC4 soap_in_PointerTons__attachmentComplex(struct soap *soap, const char *tag, struct ns__attachmentComplex **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns__attachmentComplex **)soap_malloc(soap, sizeof(struct ns__attachmentComplex *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns__attachmentComplex(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns__attachmentComplex **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns__attachmentComplex, sizeof(struct ns__attachmentComplex), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons__templateComplex(struct soap *soap, struct ns__templateComplex **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons__templateComplex))
		soap_serialize_PointerTons__templateComplex(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons__templateComplex(struct soap *soap, struct ns__templateComplex **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons__templateComplex);
	if (soap_out_PointerToPointerTons__templateComplex(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons__templateComplex(struct soap *soap, const char *tag, int id, struct ns__templateComplex **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons__templateComplex);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons__templateComplex(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns__templateComplex *** SOAP_FMAC4 soap_get_PointerToPointerTons__templateComplex(struct soap *soap, struct ns__templateComplex ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons__templateComplex(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__templateComplex *** SOAP_FMAC4 soap_in_PointerToPointerTons__templateComplex(struct soap *soap, const char *tag, struct ns__templateComplex ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns__templateComplex ***)soap_malloc(soap, sizeof(struct ns__templateComplex **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons__templateComplex(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns__templateComplex ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons__templateComplex, sizeof(struct ns__templateComplex *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTolong(struct soap *soap, long *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_long);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTolong(struct soap *soap, long *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTolong);
	if (soap_out_PointerTolong(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTolong(struct soap *soap, const char *tag, int id, long *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_long);
	if (id < 0)
		return soap->error;
	return soap_out_long(soap, tag, id, *a, type);
}

SOAP_FMAC3 long ** SOAP_FMAC4 soap_get_PointerTolong(struct soap *soap, long **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTolong(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 long ** SOAP_FMAC4 soap_in_PointerTolong(struct soap *soap, const char *tag, long **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (long **)soap_malloc(soap, sizeof(long *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_long(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (long **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_long, sizeof(long), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons__templateComplex(struct soap *soap, struct ns__templateComplex *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns__templateComplex))
		soap_serialize_ns__templateComplex(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons__templateComplex(struct soap *soap, struct ns__templateComplex *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons__templateComplex);
	if (soap_out_PointerTons__templateComplex(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons__templateComplex(struct soap *soap, const char *tag, int id, struct ns__templateComplex *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns__templateComplex);
	if (id < 0)
		return soap->error;
	return soap_out_ns__templateComplex(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns__templateComplex ** SOAP_FMAC4 soap_get_PointerTons__templateComplex(struct soap *soap, struct ns__templateComplex **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons__templateComplex(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__templateComplex ** SOAP_FMAC4 soap_in_PointerTons__templateComplex(struct soap *soap, const char *tag, struct ns__templateComplex **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns__templateComplex **)soap_malloc(soap, sizeof(struct ns__templateComplex *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns__templateComplex(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns__templateComplex **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns__templateComplex, sizeof(struct ns__templateComplex), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons__senderComplexList(struct soap *soap, struct ns__senderComplexList **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons__senderComplexList))
		soap_serialize_PointerTons__senderComplexList(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons__senderComplexList(struct soap *soap, struct ns__senderComplexList **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons__senderComplexList);
	if (soap_out_PointerToPointerTons__senderComplexList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons__senderComplexList(struct soap *soap, const char *tag, int id, struct ns__senderComplexList **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons__senderComplexList);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons__senderComplexList(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns__senderComplexList *** SOAP_FMAC4 soap_get_PointerToPointerTons__senderComplexList(struct soap *soap, struct ns__senderComplexList ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons__senderComplexList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__senderComplexList *** SOAP_FMAC4 soap_in_PointerToPointerTons__senderComplexList(struct soap *soap, const char *tag, struct ns__senderComplexList ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns__senderComplexList ***)soap_malloc(soap, sizeof(struct ns__senderComplexList **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons__senderComplexList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns__senderComplexList ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons__senderComplexList, sizeof(struct ns__senderComplexList *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons__senderComplexList(struct soap *soap, struct ns__senderComplexList *const*a)
{
	if (*a)
		soap_serialize_ns__senderComplexList(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons__senderComplexList(struct soap *soap, struct ns__senderComplexList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons__senderComplexList);
	if (soap_out_PointerTons__senderComplexList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons__senderComplexList(struct soap *soap, const char *tag, int id, struct ns__senderComplexList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ns__senderComplexList);
	if (id < 0)
		return soap->error;
	return soap_out_ns__senderComplexList(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns__senderComplexList ** SOAP_FMAC4 soap_get_PointerTons__senderComplexList(struct soap *soap, struct ns__senderComplexList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons__senderComplexList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__senderComplexList ** SOAP_FMAC4 soap_in_PointerTons__senderComplexList(struct soap *soap, const char *tag, struct ns__senderComplexList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns__senderComplexList **)soap_malloc(soap, sizeof(struct ns__senderComplexList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns__senderComplexList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns__senderComplexList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns__senderComplexList, sizeof(struct ns__senderComplexList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons__senderComplex(struct soap *soap, struct ns__senderComplex *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns__senderComplex))
		soap_serialize_ns__senderComplex(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons__senderComplex(struct soap *soap, struct ns__senderComplex *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons__senderComplex);
	if (soap_out_PointerTons__senderComplex(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons__senderComplex(struct soap *soap, const char *tag, int id, struct ns__senderComplex *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns__senderComplex);
	if (id < 0)
		return soap->error;
	return soap_out_ns__senderComplex(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns__senderComplex ** SOAP_FMAC4 soap_get_PointerTons__senderComplex(struct soap *soap, struct ns__senderComplex **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons__senderComplex(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns__senderComplex ** SOAP_FMAC4 soap_in_PointerTons__senderComplex(struct soap *soap, const char *tag, struct ns__senderComplex **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns__senderComplex **)soap_malloc(soap, sizeof(struct ns__senderComplex *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns__senderComplex(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns__senderComplex **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns__senderComplex, sizeof(struct ns__senderComplex), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons_dateTime(struct soap *soap, struct ns_dateTime *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns_dateTime))
		soap_serialize_ns_dateTime(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons_dateTime(struct soap *soap, struct ns_dateTime *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons_dateTime);
	if (soap_out_PointerTons_dateTime(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons_dateTime(struct soap *soap, const char *tag, int id, struct ns_dateTime *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns_dateTime);
	if (id < 0)
		return soap->error;
	return soap_out_ns_dateTime(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns_dateTime ** SOAP_FMAC4 soap_get_PointerTons_dateTime(struct soap *soap, struct ns_dateTime **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons_dateTime(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct ns_dateTime ** SOAP_FMAC4 soap_in_PointerTons_dateTime(struct soap *soap, const char *tag, struct ns_dateTime **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns_dateTime **)soap_malloc(soap, sizeof(struct ns_dateTime *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns_dateTime(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns_dateTime **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns_dateTime, sizeof(struct ns_dateTime), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__base64Binary(struct soap *soap, struct xsd__base64Binary *const*a)
{
	if (*a)
		soap_serialize_xsd__base64Binary(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__base64Binary(struct soap *soap, struct xsd__base64Binary *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__base64Binary);
	if (soap_out_PointerToxsd__base64Binary(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__base64Binary(struct soap *soap, const char *tag, int id, struct xsd__base64Binary *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_xsd__base64Binary);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__base64Binary(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct xsd__base64Binary ** SOAP_FMAC4 soap_get_PointerToxsd__base64Binary(struct soap *soap, struct xsd__base64Binary **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__base64Binary(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct xsd__base64Binary ** SOAP_FMAC4 soap_in_PointerToxsd__base64Binary(struct soap *soap, const char *tag, struct xsd__base64Binary **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct xsd__base64Binary **)soap_malloc(soap, sizeof(struct xsd__base64Binary *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__base64Binary(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct xsd__base64Binary **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__base64Binary, sizeof(struct xsd__base64Binary), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTounsignedByte(struct soap *soap, unsigned char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_unsignedByte);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTounsignedByte(struct soap *soap, unsigned char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTounsignedByte);
	if (soap_out_PointerTounsignedByte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTounsignedByte(struct soap *soap, const char *tag, int id, unsigned char *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_unsignedByte);
	if (id < 0)
		return soap->error;
	return soap_out_unsignedByte(soap, tag, id, *a, type);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_get_PointerTounsignedByte(struct soap *soap, unsigned char **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTounsignedByte(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_in_PointerTounsignedByte(struct soap *soap, const char *tag, unsigned char **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (unsigned char **)soap_malloc(soap, sizeof(unsigned char *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_unsignedByte(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (unsigned char **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_unsignedByte, sizeof(unsigned char), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__string(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__string(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__string);
	if (soap_out_xsd__string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__string);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__string(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__string(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__string, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__QName(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, -1, -1);
}

#ifdef __cplusplus
}
#endif

/* End of soapC.c */
